<script lang="ts">
	import type { TeamOrderField$options } from '$houdini';
	import { graphql, TeamOrderField } from '$houdini';
	import { truncateString } from '$lib/chart/util';
	import { isReducedMotion } from '$lib/reducedMotion';
	import {
		BodyLong,
		Heading,
		Loader,
		ToggleGroup,
		ToggleGroupItem
	} from '@nais/ds-svelte-community';
	import { BarChart, Bars, LinearGradient, Tooltip } from 'layerchart';

	let showByToggle = $state(TeamOrderField.RISK_SCORE) as TeamOrderField$options;

	const vulnLeaders = $derived(
		graphql(`
			query VulnerabilityLeaders(
				$mostVulnerableTeamsField: TeamOrderField!
				$mostVulnerableTeamsDirection: OrderDirection!
			) {
				mostVulnerableTeams: teams(
					first: 20
					filter: { hasWorkloads: true }
					orderBy: { field: $mostVulnerableTeamsField, direction: $mostVulnerableTeamsDirection }
				) {
					nodes {
						slug
						workloads {
							pageInfo {
								totalCount
							}
						}
						vulnerabilitySummary {
							riskScore
							critical
							high
							medium
							low
							unassigned
							coverage
						}
					}
				}
			}
		`)
	);

	const seriesData = $derived.by(() => {
		return ($vulnLeaders.data?.mostVulnerableTeams.nodes ?? []).map((s) => {
			switch (showByToggle) {
				case TeamOrderField.RISK_SCORE:
					return { team: s.slug, value: s.vulnerabilitySummary.riskScore };
				case TeamOrderField.CRITICAL_VULNERABILITIES:
					return { team: s.slug, value: s.vulnerabilitySummary.critical };
				case TeamOrderField.SBOM_COVERAGE:
					return { team: s.slug, value: s.vulnerabilitySummary.coverage.toPrecision(3) };
				default:
					return { team: s.slug, value: s.vulnerabilitySummary.riskScore };
			}
		});
	});

	const labelText = $derived.by(() => {
		switch (showByToggle) {
			case TeamOrderField.RISK_SCORE:
				return 'Risk Score';
			case TeamOrderField.CRITICAL_VULNERABILITIES:
				return 'Critical Vulnerabilities';
			case TeamOrderField.SBOM_COVERAGE:
				return 'SBOM Coverage (%)';
			default:
				return 'Risk Score';
		}
	});
</script>

<div>
	<Heading level="3" spacing
		>Most Vulnerable Teams - {showByToggle === TeamOrderField.RISK_SCORE
			? 'Highest Vulnerability Risk Score'
			: showByToggle === TeamOrderField.CRITICAL_VULNERABILITIES
				? 'Most Critical Vulnerabilities'
				: showByToggle === TeamOrderField.SBOM_COVERAGE
					? 'Lowest SBOM Coverage'
					: 'Should not print'}
	</Heading>
	<BodyLong spacing>
		A ranked view of teams with the highest security risk, based on overall Risk Score, the number
		of critical vulnerabilities, or low SBOM Coverage. This chart helps teams identify and
		prioritize areas that require the most security attention.
	</BodyLong>
	<div class="toggles">
		<ToggleGroup
			size="small"
			label="Show by"
			value={showByToggle.toString()}
			onchange={(val) => {
				showByToggle = val as TeamOrderField$options;
			}}
		>
			<ToggleGroupItem value={TeamOrderField.RISK_SCORE}>Risk Score</ToggleGroupItem>
			<ToggleGroupItem value={TeamOrderField.CRITICAL_VULNERABILITIES}
				>Critical Vulnerabilities</ToggleGroupItem
			>
			<ToggleGroupItem value={TeamOrderField.SBOM_COVERAGE}>SBOM Coverage</ToggleGroupItem>
		</ToggleGroup>
	</div>
	{#if seriesData.length > 0}
		<div class="h-[700px]">
			<BarChart
				data={seriesData}
				padding={{ top: 24, bottom: 120, left: 40, right: 40 }}
				x="team"
				y="value"
				onTooltipClick={(event, detail) => {
					goto(`/team/${detail.data.team}/vulnerabilities`);
				}}
				props={{
					bars: {
						motion: isReducedMotion ? 'none' : 'tween'
					},

					yAxis: {
						label: labelText
					},
					xAxis: {
						format(value: string) {
							return truncateString(value, 23);
						},
						tickLabelProps: {
							rotate: 300,
							textAnchor: 'end'
						}
					}
				}}
			>
				{#snippet marks({ series, getBarsProps })}
					{#each series as s, i (s.key)}
						<LinearGradient stops={['#ff0000', '#ffa500']} vertical units="userSpaceOnUse">
							{#snippet children({ gradient })}
								<Bars {...getBarsProps(s, i)} fill={gradient} />
							{/snippet}
						</LinearGradient>
					{/each}
				{/snippet}
				{#snippet tooltip()}
					<!-- More suitable single-value tooltip -->
					<Tooltip.Root>
						{#snippet children({ data })}
							<Tooltip.Header value={data.team} />
							<Tooltip.List>
								<Tooltip.Item label={labelText} value={data.value} />
							</Tooltip.List>
						{/snippet}
					</Tooltip.Root>
				{/snippet}
			</BarChart>
		</div>
	{:else}
		<div style="display: flex; justify-content: center; align-items: center; height: 500px;">
			<Loader size="3xlarge" />
		</div>
	{/if}
</div>

<style>
	.toggles {
		display: flex;
		gap: var(--spacing-layout);
		flex-direction: row;
		justify-content: flex-end;
	}
</style>
