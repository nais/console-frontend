<script lang="ts">
	import { graphql, PendingValue } from '$houdini';
	import VulnerabilityBadge from '$lib/icons/VulnerabilityBadge.svelte';
	import { percentageFormatter } from '$lib/utils/formatters';
	import { severityToColor } from '$lib/utils/vulnerabilities';
	import { HelpText, Skeleton, Tooltip } from '@nais/ds-svelte-community';
	import { TrendDownIcon, TrendFlatIcon, TrendUpIcon } from '@nais/ds-svelte-community/icons';
	import type { VulnerabilitiesSummaryVariables, VulnerabilityMetricsVariables } from './$houdini';

	export let teamName: string;

	export const _VulnerabilitiesSummaryVariables: VulnerabilitiesSummaryVariables = () => {
		return { team: teamName };
	};

	const vulnerabilities = graphql(`
		query VulnerabilitiesSummary($team: Slug!) @cache(policy: NetworkOnly) @load {
			team(slug: $team) @loading(cascade: true) {
				id
				slug
				apps {
					pageInfo {
						totalCount
					}
				}
				naisjobs {
					pageInfo {
						totalCount
					}
				}
				vulnerabilitiesSummary {
					critical
					high
					low
					medium
					riskScore
					unassigned
					bomCount
				}
			}
		}
	`);

	export const _VulnerabilityMetricsVariables: VulnerabilityMetricsVariables = () => {
		const toDate = new Date();
		toDate.setDate(toDate.getDate() - 1);

		const fromDate = new Date();
		fromDate.setDate(fromDate.getDate() - 31);

		return { from: fromDate, to: toDate, slug: teamName };
	};

	const metrics = graphql(`
		query VulnerabilityMetrics($slug: Slug!, $from: Date!, $to: Date!)
		@load
		@cache(policy: NetworkOnly) {
			team(slug: $slug) {
				environments {
					name
				}
				vulnerabilityMetrics(from: $from, to: $to) {
					minDate
					maxDate
					data {
						date
						critical
						high
						medium
						low
						unassigned
						riskScore
					}
				}
			}
		}
	`);

	$: team = $vulnerabilities.data?.team;
	$: teamMetrics = $metrics.data?.team.vulnerabilityMetrics;

	const trend = (
		metrics: {
			readonly date: Date;
			readonly critical: number;
			readonly high: number;
			readonly medium: number;
			readonly low: number;
			readonly unassigned: number;
			readonly riskScore: number;
		}[]
	): Trend => {
		const yesterday = new Date();
		yesterday.setDate(yesterday.getDate() - 1);
		const yesterdayMetrics = metrics.find(
			(m) => m.date.toDateString() === yesterday.toDateString()
		);
		const riskScore = metrics.reduce((acc, r) => acc + r.riskScore, 0);
		const critical = metrics.reduce((acc, r) => acc + r.critical, 0);
		const averageCritical = critical / metrics.length;
		const averageRiskScore = riskScore / metrics.length;

		if (!yesterdayMetrics) {
			return {
				critical: 0,
				trendRiskScore: 0
			};
		}

		return {
			critical: ((yesterdayMetrics?.critical - averageCritical) / averageCritical) * 100,
			trendRiskScore: ((yesterdayMetrics?.riskScore - averageRiskScore) / averageRiskScore) * 100
		};
	};

	type Trend = {
		critical: number;
		trendRiskScore: number;
	};
</script>

<h4>Vulnerabilities</h4>
{#if team}
	<div style="place-content: center; display: flex;">
		{#if team.vulnerabilitiesSummary.critical !== PendingValue}
			<Tooltip placement="right" content="severity: CRITICAL">
				<VulnerabilityBadge
					text={String(team.vulnerabilitiesSummary.critical)}
					color={severityToColor('critical')}
					size={'76px'}
				/></Tooltip
			>
		{:else}
			<Skeleton variant="circle" width="38px" height="38px" />
		{/if}
	</div>
	<div class="vulnerabilities">
		{#if team.vulnerabilitiesSummary.high !== PendingValue}
			<Tooltip placement="right" content="severity: HIGH">
				<VulnerabilityBadge
					text={String(team.vulnerabilitiesSummary.high)}
					color={severityToColor('high')}
					size={'38px'}
				/></Tooltip
			>
		{:else}
			<Skeleton variant="circle" width="38px" height="38px" />
		{/if}
		{#if team.vulnerabilitiesSummary.medium !== PendingValue}
			<Tooltip placement="right" content="severity: MEDIUM">
				<VulnerabilityBadge
					text={String(team.vulnerabilitiesSummary.medium)}
					color={severityToColor('medium')}
					size={'38px'}
				/></Tooltip
			>
		{:else}
			<Skeleton variant="circle" width="38px" height="38px" />
		{/if}
		{#if team.vulnerabilitiesSummary.low !== PendingValue}
			<Tooltip placement="right" content="severity: LOW">
				<VulnerabilityBadge
					text={String(team.vulnerabilitiesSummary.low)}
					color={severityToColor('low')}
					size={'38px'}
				/></Tooltip
			>
		{:else}
			<Skeleton variant="circle" width="38px" height="38px" />
		{/if}
		{#if team.vulnerabilitiesSummary.unassigned !== PendingValue}
			<Tooltip placement="right" content="severity: UNASSIGNED">
				<VulnerabilityBadge
					text={String(team.vulnerabilitiesSummary.unassigned)}
					color={severityToColor('unassigned')}
					size={'38px'}
				/></Tooltip
			>
		{:else}
			<Skeleton variant="circle" width="38px" height="38px" />
		{/if}
	</div>

	{#if team.vulnerabilitiesSummary.bomCount !== PendingValue && team.apps.pageInfo.totalCount !== PendingValue && team.naisjobs.pageInfo.totalCount !== PendingValue}
		{@const coverage =
			(team.vulnerabilitiesSummary.bomCount /
				(team.apps.pageInfo.totalCount + team.naisjobs.pageInfo.totalCount)) *
			100}
		<p class="container">
			Coverage
			<span class="container">
				{#if coverage}
					<span class={coverage < 100 ? 'red' : 'green'}
						>{percentageFormatter(coverage ? coverage : 0, 0)}</span
					>
				{:else}
					<span class={'red'}>{percentageFormatter(0, 0)}</span>
				{/if}
				<HelpText title="SBOM coverage"
					>The percentage of applications with a documented list of dependencies, known as a
					Software Bill of Materials (SBOM), is crucial for effectively monitoring vulnerabilities
					within the application. Red indicates that less than 100% of applications have an SBOM.
				</HelpText>
			</span>
		</p>
	{:else}
		<Skeleton variant="text" width="250px" />
	{/if}
	{#if teamMetrics}
		{@const vulnTrend = trend(teamMetrics.data)}
		<p class="container">
			Trend risk score <span
				class={vulnTrend.trendRiskScore > 0 ? 'container red' : 'container green'}
			>
				{#if vulnTrend.trendRiskScore > 0}
					<TrendUpIcon />
				{:else if vulnTrend.trendRiskScore < 0}
					<TrendDownIcon />
				{:else}
					<TrendFlatIcon />
				{/if}
				{percentageFormatter(vulnTrend.trendRiskScore ? vulnTrend.trendRiskScore : 0, 0)}
				<HelpText title="Trend risk score"
					><span style="color: black">
						The risk score is determined by both the total number of vulnerabilities and their
						weighted severity, with critical vulnerabilities assigned the highest weight. Trends are
						calculated by comparing the average risk score over the past 30 days with the current
						risk score. Red indicates an increase in risk score.
					</span>
				</HelpText>
			</span>
		</p>
		<p class="container">
			Trend critical <span class={vulnTrend.critical > 0 ? 'container red' : 'container green'}>
				{#if vulnTrend.critical > 0}
					<TrendUpIcon />
				{:else if vulnTrend.critical < 0}
					<TrendDownIcon />
				{:else}
					<TrendFlatIcon />
				{/if}
				{percentageFormatter(vulnTrend.critical ? vulnTrend.critical : 0, 0)}
				<HelpText title="Critical trend">
					<span style="color: black">
						The critical trend is calculated by comparing the average number of critical
						vulnerabilities over the last 30 days with the number of critical vulnerabilities today.
						Red indicates an increase in critical vulnerabilities.
					</span>
				</HelpText>
			</span>
		</p>
	{/if}
{/if}

<style>
	.vulnerabilities {
		display: flex;
		gap: 0.5rem;
		margin-top: 0.8rem;
		justify-content: space-evenly;
	}

	.container {
		display: flex;
		gap: 0.5rem;
		justify-content: space-between;
	}

	.red {
		color: var(--a-surface-danger);
	}

	.green {
		color: var(--a-surface-success);
	}
</style>
