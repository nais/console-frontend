"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

type AccessPolicy {
  inbound: Inbound!
  outbound: Outbound!
}

type Acl {
  access: String!
  application: String!
  team: String!
}

type App implements Node {
  accessPolicy: AccessPolicy!
  appState: AppState!
  authz: [Authz!]!
  autoScaling: AutoScaling!
  dependencyTrack: DependencyTrack
  deployInfo: DeployInfo!
  env: Env!
  id: ID!
  image: String!
  ingresses: [String!]!
  instances: [Instance!]!
  manifest: String!
  name: String!
  resources: Resources!
  storage: [Storage!]!
  team: Team!
  variables: [Variable!]!
}

type AppConnection implements Connection {
  edges: [AppEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"""App cost type."""
type AppCost {
  """The name of the application."""
  app: String!

  """A list of cost entries for the application."""
  cost: [CostEntry!]!

  """The sum of all cost entries for the application in euros."""
  sum: Float!
}

type AppEdge implements Edge {
  cursor: Cursor!
  node: App!
}

type AppState {
  errors: [StateError!]!
  state: State!
}

union Authz = AzureAD | IDPorten | Maskinporten | TokenX

type AutoScaling {
  """CPU threshold in percent"""
  cpuThreshold: Int!
  disabled: Boolean!
  max: Int!
  min: Int!
}

type AzureAD {
  application: AzureApplication
  sidecar: Sidecar
}

type AzureApplication {
  allowAllUsers: Boolean!
  claims: Claims!
  replyURLs: [String!]!
  singlePageApplication: Boolean!
  tenant: String!
}

type BigQueryDataset implements Storage {
  cascadingDelete: Boolean!
  description: String!
  name: String!
  permission: String!
}

type Bucket implements Storage {
  cascadingDelete: Boolean!
  name: String!
  publicAccessPrevention: Boolean!
  retentionPeriodDays: Int!
  uniformBucketLevelAccess: Boolean!
}

type Claims {
  extra: [String!]!
  groups: [Group!]!
}

"""Connection interface."""
interface Connection {
  """A list of edges."""
  edges: [Edge]!

  """Pagination information."""
  pageInfo: PageInfo!

  """The total count of items in the connection."""
  totalCount: Int!
}

type Consume {
  name: String!
}

type Consumer {
  name: String!
  orgno: String!
}

"""Cost entry type."""
type CostEntry {
  """The cost in euros."""
  cost: Float!

  """The date for the entry."""
  date: Date!
}

"""Cost series type."""
type CostSeries {
  """The type of cost."""
  costType: String!

  """The cost data."""
  data: [CostEntry!]!

  """The sum of all daily costs in the series for this cost type in euros."""
  sum: Float!
}

"""
Cursor is a string that can be used to paginate through a list of objects. It is opaque to the client and may change at any time.
"""
scalar Cursor

"""Daily cost type."""
type DailyCost {
  """The cost series."""
  series: [CostSeries!]!

  """The sum of all costs in the cost series in euros."""
  sum: Float!
}

type Database {
  envVarPrefix: String!
  name: String!
  users: [DatabaseUser!]!
}

type DatabaseUser {
  name: String!
}

"""Date type in YYYY-MM-DD format."""
scalar Date

type DependencyTrack implements Node {
  findingsLink: String!
  id: ID!
  projectName: String!
  projectUUID: String!
  summary: VulnerabilitySummary
  vulnerabilities: [Vulnerability!]
}

type DeployInfo {
  commitSha: String!
  deployer: String!
  history(after: Cursor, before: Cursor, first: Int, last: Int): DeploymentResponse!
  timestamp: Time
  url: String!
}

type Deployment {
  created: Time!
  env: String!
  id: ID!
  repository: String!
  resources: [DeploymentResource!]!
  statuses: [DeploymentStatus!]!
  team: Team!
}

type DeploymentConnection implements Connection {
  edges: [DeploymentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeploymentEdge implements Edge {
  cursor: Cursor!
  node: Deployment!
}

"""Deployment key type."""
type DeploymentKey implements Node {
  """The date the deployment key was created."""
  created: Time!

  """The date the deployment key expires."""
  expires: Time!

  """The unique identifier of the deployment key."""
  id: ID!

  """The actual key."""
  key: String!
}

type DeploymentResource {
  group: String!
  id: ID!
  kind: String!
  name: String!
  namespace: String!
  version: String!
}

union DeploymentResponse = DeploymentConnection | Error

type DeploymentStatus {
  created: Time!
  id: ID!
  message: String
  status: String!
}

type DeprecatedIngressError implements StateError {
  ingress: String!
  level: ErrorLevel!
  revision: String!
}

type DeprecatedRegistryError implements StateError {
  level: ErrorLevel!
  name: String!
  registry: String!
  repository: String!
  revision: String!
  tag: String!
}

"""Edge interface."""
interface Edge {
  """A cursor for use in pagination."""
  cursor: Cursor!
}

type Env implements Node {
  id: ID!
  name: String!
}

"""Env cost type."""
type EnvCost {
  """A list of app costs in the environment."""
  apps: [AppCost!]!

  """The name of the environment."""
  env: String!

  """The sum of all app costs for the environment in euros."""
  sum: Float!
}

"""Env cost filter input type."""
input EnvCostFilter {
  """Start date for the cost series, inclusive."""
  from: Date!

  """The name of the team to get costs for."""
  team: String!

  """End date for cost series, inclusive."""
  to: Date!
}

type Error {
  message: String!
}

enum ErrorLevel {
  ERROR
  INFO
  WARNING
}

type Expose {
  allowedIntegrations: [String!]!
  atMaxAge: Int!
  consumers: [Consumer!]!
  enabled: Boolean!
  name: String!
  product: String!
}

type External {
  host: String!
  ports: [Port!]!
}

type FailedRunError implements StateError {
  level: ErrorLevel!
  revision: String!
  runMessage: String!
  runName: String!
}

type Flag {
  name: String!
  value: String!
}

"""GCP project type."""
type GcpProject {
  """The environment for the GCP project."""
  environment: String!

  """The unique identifier of the GCP project."""
  id: String!

  """The name of the GCP project."""
  name: String!
}

"""GitHub repository type."""
type GithubRepository {
  """The name of the GitHub repository."""
  name: String!
}

"""GitHub repository connection type."""
type GithubRepositoryConnection implements Connection {
  """A list of GitHub repository edges."""
  edges: [GithubRepositoryEdge!]!

  """Pagination information."""
  pageInfo: PageInfo!

  """The total count of available GitHub repositories."""
  totalCount: Int!
}

"""GitHub repository edge type."""
type GithubRepositoryEdge implements Edge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The GitHub repository at the end of the edge."""
  node: GithubRepository!
}

type Group {
  id: String!
}

type IDPorten {
  accessTokenLifetime: Int
  clientURI: String
  frontchannelLogoutPath: String
  integrationType: String
  postLogoutRedirectURIs: [String]
  redirectPath: String
  scopes: [String]
  sessionLifetime: Int
  sidecar: IDPortenSidecar
}

type IDPortenSidecar {
  autoLogin: Boolean
  autoLoginIgnorePaths: [String]
  enabled: Boolean
  level: String
  locale: String
  resources: Resources
}

type Inbound {
  rules: [Rule!]!
}

type InboundAccessError implements StateError {
  level: ErrorLevel!
  revision: String!
  rule: Rule!
}

type InfluxDb implements Storage {
  name: String!
}

type Insights {
  enabled: Boolean!
  queryStringLength: Int!
  recordApplicationTags: Boolean!
  recordClientAddress: Boolean!
}

type Instance implements Node {
  created: Time!
  id: ID!
  image: String!
  message: String!
  name: String!
  restarts: Int!
  state: InstanceState!
}

enum InstanceState {
  FAILING
  RUNNING
  UNKNOWN
}

type InvalidNaisYamlError implements StateError {
  detail: String!
  level: ErrorLevel!
  revision: String!
}

type JobState {
  errors: [StateError!]!
  state: State!
}

type Kafka implements Storage {
  """The kafka pool name"""
  name: String!
  streams: Boolean!
  topics: [Topic!]!
}

type Limits {
  cpu: String!
  memory: String!
}

type LogLine {
  instance: String!
  message: String!
  time: Time!
}

input LogSubscriptionInput {
  app: String
  env: String!
  instances: [String!]
  job: String
  team: String!
}

type Maintenance {
  day: Int!
  hour: Int!
}

type Maskinporten {
  enabled: Boolean!
  scopes: MaskinportenScope!
}

type MaskinportenScope {
  consumes: [Consume!]!
  exposes: [Expose!]!
}

"""Montly cost type."""
type MonthlyCost {
  """A list of monthly cost entries."""
  cost: [CostEntry!]!

  """Sum for all months in the series in euros."""
  sum: Float!
}

"""Monthly cost filter input type."""
input MonthlyCostFilter {
  """The name of the application to get costs for."""
  app: String!

  """The name of the environment to get costs for."""
  env: String!

  """The name of the team to get costs for."""
  team: String!
}

"""The root query for implementing GraphQL mutations."""
type Mutation {
  """Update the deploy key of a team. Returns the updated deploy key."""
  changeDeployKey(
    """The name of the team to update the deploy key for."""
    team: String!
  ): DeploymentKey!
}

type NaisJob implements Node {
  accessPolicy: AccessPolicy!
  authz: [Authz!]!
  completions: Int!
  deployInfo: DeployInfo!
  env: Env!
  id: ID!
  image: String!
  jobState: JobState!
  manifest: String!
  name: String!
  parallelism: Int!
  resources: Resources!
  retries: Int!
  runs: [Run!]!
  schedule: String!
  storage: [Storage!]!
  team: Team!
}

type NaisJobConnection implements Connection {
  edges: [NaisJobEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NaisJobEdge implements Edge {
  cursor: Cursor!
  node: NaisJob!
}

type NewInstancesFailingError implements StateError {
  failingInstances: [String!]!
  level: ErrorLevel!
  revision: String!
}

type NoRunningInstancesError implements StateError {
  level: ErrorLevel!
  revision: String!
}

"""Node interface."""
interface Node {
  """The unique ID of an object."""
  id: ID!
}

type OpenSearch implements Storage {
  access: String!

  """The opensearch instance name"""
  name: String!
}

type Outbound {
  external: [External!]!
  rules: [Rule!]!
}

type OutboundAccessError implements StateError {
  level: ErrorLevel!
  revision: String!
  rule: Rule!
}

"""
PageInfo is a type that contains pagination information in a Relay style.
"""
type PageInfo {
  """A cursor corresponding to the last node in the connection."""
  endCursor: Cursor
  from: Int!

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """A cursor corresponding to the first node in the connection."""
  startCursor: Cursor
  to: Int!
}

type Port {
  port: Int!
}

"""The query root for the console-backend GraphQL API."""
type Query {
  """Get an app by name, team and env."""
  app(
    """The environment the application is deployed to."""
    env: String!

    """The name of the application."""
    name: String!

    """The name of the team who owns the application."""
    team: String!
  ): App!

  """Get the daily cost for a team application in a specific environment."""
  dailyCostForApp(
    """The name of the application to get costs for."""
    app: String!

    """The environment that the application runs in."""
    env: String!

    """Start date for the cost series, inclusive."""
    from: Date!

    """The name of the team that owns the application."""
    team: String!

    """End date for cost series, inclusive."""
    to: Date!
  ): DailyCost!

  """Get the daily cost for a team across all apps and environments."""
  dailyCostForTeam(
    """Start date for the cost series, inclusive."""
    from: Date!

    """The name of the team that owns the application."""
    team: String!

    """End date for cost series, inclusive."""
    to: Date!
  ): DailyCost!

  """Get a list of deployments."""
  deployments(after: Cursor, before: Cursor, first: Int, last: Int, limit: Int): DeploymentConnection!

  """Get env cost for a team."""
  envCost(filter: EnvCostFilter!): [EnvCost!]!

  """Get monthly costs."""
  monthlyCost(filter: MonthlyCostFilter!): MonthlyCost!

  """Get a naisjob by name, team and env."""
  naisjob(
    """The environment the naisjob is deployed in."""
    env: String!

    """The name of the naisjob."""
    name: String!

    """The name of the team who owns the naisjob."""
    team: String!
  ): NaisJob!

  """Fetches an object given its ID."""
  node(
    """The ID of an object."""
    id: ID!
  ): Node
  search(after: Cursor, before: Cursor, filter: SearchFilter, first: Int, last: Int, query: String!): SearchConnection!

  """Get a specific NAIS-team by the team name."""
  team(
    """The name of the NAIS-team to get."""
    name: String!
  ): Team!

  """Get a list of NAIS-teams, in alphabetical order."""
  teams(
    """Get entries after the cursor."""
    after: Cursor

    """Get entries before the cursor."""
    before: Cursor

    """Returns the first n entries from the list."""
    first: Int

    """Returns the last n entries from the list."""
    last: Int
  ): TeamConnection!

  """Get the currently logged in user."""
  user: User!

  """The vulnerabilities for the team's applications."""
  vulnerabilitiesByTeam(
    """Get entries after the cursor."""
    after: Cursor

    """Get entries before the cursor."""
    before: Cursor

    """Returns the first n entries from the list."""
    first: Int

    """Returns the last n entries from the list."""
    last: Int

    """Order apps by"""
    orderBy: VulnerabilitiesOrderBy

    """The team name"""
    team: String!
  ): VulnerabilitiesConnection!
}

type Redis implements Storage {
  access: String!
  name: String!
}

type Requests {
  cpu: String!
  memory: String!
}

type Resources {
  limits: Limits!
  requests: Requests!
}

type Rule {
  application: String!
  cluster: String!
  mutual: Boolean!
  mutualExplanation: String!
  namespace: String!
}

type Run implements Node {
  completionTime: Time
  duration: String!
  failed: Boolean!
  id: ID!
  image: String!
  message: String!
  name: String!
  podNames: [String!]!
  startTime: Time
}

type SearchConnection implements Connection {
  edges: [SearchEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SearchEdge implements Edge {
  cursor: Cursor!
  node: SearchNode!
}

input SearchFilter {
  type: SearchType
}

union SearchNode = App | NaisJob | Team

enum SearchType {
  APP
  NAISJOB
  TEAM
}

type Sidecar {
  autoLogin: Boolean!
  autoLoginIgnorePaths: [String!]!
  resources: Resources!
}

"""Slack alerts channel type."""
type SlackAlertsChannel {
  """The environment for the Slack alerts channel."""
  env: String!

  """The name of the Slack alerts channel."""
  name: String!
}

enum Sort {
  """Ascending sort order."""
  ASC

  """Descending sort order."""
  DESC
}

type SqlInstance implements Storage {
  autoBackupHour: Int!
  cascadingDelete: Boolean!
  collation: String!
  databases: [Database!]!
  diskAutoresize: Boolean!
  diskSize: Int!
  diskType: String!
  flags: [Flag!]!
  highAvailability: Boolean!
  insights: Insights!
  maintenance: Maintenance!
  name: String!
  pointInTimeRecovery: Boolean!
  retainedBackups: Int!
  tier: String!
  type: String!
}

enum State {
  FAILING
  NAIS
  NOTNAIS
  UNKNOWN
}

interface StateError {
  level: ErrorLevel!
  revision: String!
}

interface Storage {
  name: String!
}

"""The root subscription type for implementing GraphQL subscriptions."""
type Subscription {
  log(input: LogSubscriptionInput): LogLine!
}

"""Team type."""
type Team implements Node {
  """The NAIS applications owned by the team."""
  apps(
    """Get entries after the cursor."""
    after: Cursor

    """Get entries before the cursor."""
    before: Cursor

    """Returns the first n entries from the list."""
    first: Int

    """Returns the last n entries from the list."""
    last: Int
  ): AppConnection!

  """The deploy key of the team."""
  deployKey: DeploymentKey!

  """The deployments of the team's applications."""
  deployments(
    """Get entries after the cursor."""
    after: Cursor

    """Get entries before the cursor."""
    before: Cursor

    """Returns the first n entries from the list."""
    first: Int

    """Returns the last n entries from the list."""
    last: Int

    """Limit the number of entries returned."""
    limit: Int
  ): DeploymentConnection!

  """The description of the team."""
  description: String!
  gcpProjects: [GcpProject!]!

  """The GitHub repositories that the team has access to."""
  githubRepositories(
    """Get entries after the cursor."""
    after: Cursor

    """Returns the first n entries from the list."""
    first: Int
  ): GithubRepositoryConnection!

  """The unique identifier of the team."""
  id: ID!

  """Team members."""
  members(
    """Get entries after the cursor."""
    after: Cursor

    """Get entries before the cursor."""
    before: Cursor

    """Returns the first n entries from the list."""
    first: Int

    """Returns the last n entries from the list."""
    last: Int
  ): TeamMemberConnection!

  """The NAIS jobs owned by the team."""
  naisjobs(
    """Get entries after the cursor."""
    after: Cursor

    """Get entries before the cursor."""
    before: Cursor

    """Returns the first n entries from the list."""
    first: Int

    """Returns the last n entries from the list."""
    last: Int
  ): NaisJobConnection!

  """The name of the team."""
  name: String!

  """Slack alerts channels for the team."""
  slackAlertsChannels: [SlackAlertsChannel!]!

  """The main Slack channel for the team."""
  slackChannel: String!

  """Whether or not the viewer is an administrator of the team."""
  viewerIsAdmin: Boolean!

  """Whether or not the viewer is a member of the team."""
  viewerIsMember: Boolean!

  """The vulnerabilities for the team's applications."""
  vulnerabilitiesForTeam(
    """Get entries after the cursor."""
    after: Cursor

    """Get entries before the cursor."""
    before: Cursor

    """Returns the first n entries from the list."""
    first: Int

    """Returns the last n entries from the list."""
    last: Int

    """Order apps by"""
    orderBy: VulnerabilitiesOrderBy
  ): VulnerabilitiesConnection!
}

"""Team connection type."""
type TeamConnection implements Connection {
  """A list of team edges."""
  edges: [TeamEdge!]!

  """Pagination information."""
  pageInfo: PageInfo!

  """The total count of available teams."""
  totalCount: Int!
}

"""Team edge type."""
type TeamEdge implements Edge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The team at the end of the edge."""
  node: Team!
}

"""Team member type."""
type TeamMember implements Node {
  """The email of the team member."""
  email: String!

  """The unique identifier of the team member."""
  id: ID!

  """The name of the team member."""
  name: String!

  """The role of the team member."""
  role: TeamRole!
}

"""Team member connection type."""
type TeamMemberConnection implements Connection {
  """A list of team member edges."""
  edges: [TeamMemberEdge!]!

  """Pagination information."""
  pageInfo: PageInfo!

  """The total count of available team members."""
  totalCount: Int!
}

"""Team member edge type."""
type TeamMemberEdge implements Edge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The team member at the end of the edge."""
  node: TeamMember!
}

"""Team member roles."""
enum TeamRole {
  """A regular team member."""
  MEMBER

  """A team owner/administrator."""
  OWNER
}

"""
Time is a string in [RFC 3339](https://rfc-editor.org/rfc/rfc3339.html) format, with sub-second precision added if present.
"""
scalar Time

type TokenX {
  mountSecretsAsFilesOnly: Boolean!
}

type Topic {
  acl: [Acl!]!
  name: String!
}

type User implements Node {
  """The user's email address."""
  email: String!

  """The unique identifier for the user."""
  id: ID!

  """The user's full name."""
  name: String!

  """Teams that the user is a member and/or owner of."""
  teams(after: Cursor, before: Cursor, first: Int, last: Int): TeamConnection!
}

type Variable {
  name: String!
  value: String!
}

type VulnerabilitiesConnection implements Connection {
  edges: [VulnerabilitiesEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type VulnerabilitiesEdge implements Edge {
  cursor: Cursor!
  node: VulnerabilitiesNode!
}

type VulnerabilitiesNode implements Node {
  appName: String!
  env: String!
  id: ID!
  image: String!
  project: DependencyTrack
  team: String!
}

input VulnerabilitiesOrderBy {
  """Order direction"""
  direction: Sort!
  field: VulnerabilitiesOrderByField!
}

enum VulnerabilitiesOrderByField {
  """Order by appName."""
  APP_NAME

  """Order by env."""
  ENV_NAME

  """Order apps by vulnerability severity critical"""
  SEVERITY_CRITICAL

  """Order apps by vulnerability severity high"""
  SEVERITY_HIGH

  """Order apps by vulnerability severity low"""
  SEVERITY_LOW

  """Order apps by vulnerability severity medium"""
  SEVERITY_MEDIUM
}

type Vulnerability {
  componentPurl: String!
  id: String!
  name: String!
  severity: String!
  severityRank: Int!
}

type VulnerabilitySummary {
  critical: Int!
  high: Int!
  low: Int!
  medium: Int!
  total: Int!
  unassigned: Int!
}
