"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

type AccessPolicy {
  inbound: Inbound!
  outbound: Outbound!
}

type Acl {
  access: String!
  application: String!
  team: String!
}

type App implements Node {
  accessPolicy: AccessPolicy!
  authz: [Authz!]!
  autoScaling: AutoScaling!
  deployInfo: DeployInfo!
  env: Env!
  id: ID!
  image: String!
  ingresses: [String!]!
  instances: [Instance!]!
  manifest: String!
  messages: [String!]
  name: String!
  resources: Resources!
  state: AppState!
  storage: [Storage!]!
  team: Team!
  variables: [Variable!]!
}

type AppConnection {
  edges: [AppEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AppEdge {
  cursor: Cursor!
  node: App!
}

enum AppState {
  FAILING
  NAIS
  NOTNAIS
  UNKNOWN
}

union Authz = AzureAD | IDPorten | Maskinporten | TokenX

type AutoScaling {
  """CPU threshold in percent"""
  cpuThreshold: Int!
  disabled: Boolean!
  max: Int!
  min: Int!
}

type AzureAD {
  application: AzureApplication
  sidecar: Sidecar
}

type AzureApplication {
  allowAllUsers: Boolean!
  claims: Claims!
  replyURLs: [String!]!
  singlePageApplication: Boolean!
  tenant: String!
}

type BigQueryDataset implements Storage {
  cascadingDelete: Boolean!
  description: String!
  name: String!
  permission: String!
}

type Bucket implements Storage {
  cascadingDelete: Boolean!
  name: String!
  publicAccessPrevention: Boolean!
  retentionPeriodDays: Int!
  uniformBucketLevelAccess: Boolean!
}

type Claims {
  extra: [String!]!
  groups: [Group!]!
}

type Consume {
  name: String!
}

type Consumer {
  name: String!
  orgno: String!
}

scalar Cursor

type Database {
  envVarPrefix: String!
  name: String!
  users: [DatabaseUser!]!
}

type DatabaseUser {
  name: String!
}

type DeployInfo {
  commitSha: String!
  deployer: String!
  history(after: Cursor, before: Cursor, first: Int, last: Int): DeploymentResponse!
  timestamp: Time
  url: String!
}

type Deployment {
  created: Time!
  env: String!
  id: ID!
  repository: String
  resources: [DeploymentResource!]!
  statuses: [DeploymentStatus!]!
  team: Team!
}

type DeploymentConnection {
  edges: [DeploymentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DeploymentEdge {
  cursor: Cursor!
  node: Deployment!
}

type DeploymentKey implements Node {
  created: Time!
  expires: Time!
  id: ID!
  key: String!
}

type DeploymentResource {
  group: String!
  id: ID!
  kind: String!
  name: String!
  namespace: String!
  version: String!
}

union DeploymentResponse = DeploymentConnection | Error

type DeploymentStatus {
  created: Time!
  id: ID!
  message: String
  status: String!
}

type Env implements Node {
  id: ID!
  name: String!
}

type Error {
  message: String!
}

type Expose {
  allowedIntegrations: [String!]!
  atMaxAge: Int!
  consumers: [Consumer!]!
  enabled: Boolean!
  name: String!
  product: String!
}

type External {
  host: String!
  ports: [Port!]!
}

type Flag {
  name: String!
  value: String!
}

type GithubRepository {
  name: String!
}

type GithubRepositoryConnection {
  edges: [GithubRepositoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type GithubRepositoryEdge {
  cursor: Cursor!
  node: GithubRepository!
}

type Group {
  id: String!
}

type IDPorten {
  accessTokenLifetime: Int
  clientURI: String
  frontchannelLogoutPath: String
  integrationType: String
  postLogoutRedirectURIs: [String]
  redirectPath: String
  scopes: [String]
  sessionLifetime: Int
  sidecar: IDPortenSidecar
}

type IDPortenSidecar {
  autoLogin: Boolean
  autoLoginIgnorePaths: [String]
  enabled: Boolean
  level: String
  locale: String
  resources: Resources
}

type Inbound {
  rules: [Rule!]!
}

type Insights {
  enabled: Boolean!
  queryStringLength: Int!
  recordApplicationTags: Boolean!
  recordClientAddress: Boolean!
}

type Instance implements Node {
  created: Time!
  id: ID!
  image: String!
  message: String!
  name: String!
  restarts: Int!
  state: InstanceState!
}

enum InstanceState {
  FAILING
  RUNNING
  UNKNOWN
}

type Kafka implements Storage {
  """The kafka pool name"""
  name: String!
  streams: Boolean!
  topics: [Topic!]!
}

type Limits {
  cpu: String!
  memory: String!
}

type LogLine {
  instance: String!
  message: String!
  time: Time!
}

input LogSubscriptionInput {
  app: String
  env: String!
  instances: [String!]
  job: String
  team: String!
}

type Maintenance {
  day: Int!
  hour: Int!
}

type Maskinporten {
  enabled: Boolean!
  scopes: MaskinportenScope!
}

type MaskinportenScope {
  consumes: [Consume!]!
  exposes: [Expose!]!
}

type Mutation {
  changeDeployKey(team: String!): DeploymentKey!
}

type NaisJob implements Node {
  accessPolicy: AccessPolicy!
  authz: [Authz!]!
  completions: Int!
  deployInfo: DeployInfo!
  env: Env!
  id: ID!
  image: String!
  manifest: String!
  name: String!
  parallelism: Int!
  resources: Resources!
  retries: Int!
  runs: [Run!]!
  schedule: String!
  storage: [Storage!]!
  team: Team!
}

type NaisJobConnection {
  edges: [NaisJobEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type NaisJobEdge {
  cursor: Cursor!
  node: NaisJob!
}

interface Node {
  id: ID!
}

type OpenSearch implements Storage {
  access: String!

  """The opensearch instance name"""
  name: String!
}

type Outbound {
  external: [External!]!
  rules: [Rule!]!
}

type PageInfo {
  endCursor: Cursor
  from: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: Cursor
  to: Int!
}

type Port {
  port: Int!
}

type Query {
  app(env: String!, name: String!, team: String!): App!
  deployments(after: Cursor, before: Cursor, first: Int, last: Int, limit: Int): DeploymentConnection!
  naisjob(env: String!, name: String!, team: String!): NaisJob!
  node(id: ID!): Node
  search(after: Cursor, before: Cursor, filter: SearchFilter, first: Int, last: Int, query: String!): SearchConnection!
  team(name: String!): Team!
  teams(after: Cursor, before: Cursor, first: Int, last: Int): TeamConnection!
  user: User!
}

type Requests {
  cpu: String!
  memory: String!
}

type Resources {
  limits: Limits!
  requests: Requests!
}

type Rule {
  application: String!
  cluster: String!
  namespace: String!
}

type Run implements Node {
  completionTime: Time
  duration: String!
  failed: Boolean!
  id: ID!
  image: String!
  message: String!
  name: String!
  podNames: [String!]!
  startTime: Time
}

type SearchConnection {
  edges: [SearchEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SearchEdge {
  cursor: Cursor!
  node: SearchNode!
}

input SearchFilter {
  type: SearchType
}

union SearchNode = App | NaisJob | Team

enum SearchType {
  APP
  NAISJOB
  TEAM
}

type Sidecar {
  autoLogin: Boolean!
  autoLoginIgnorePaths: [String!]!
  resources: Resources!
}

type SlackAlertsChannel {
  env: String!
  name: String!
}

type SqlInstance implements Storage {
  autoBackupHour: Int!
  cascadingDelete: Boolean!
  collation: String!
  databases: [Database!]!
  diskAutoresize: Boolean!
  diskSize: Int!
  diskType: String!
  flags: [Flag!]!
  highAvailability: Boolean!
  insights: Insights!
  maintenance: Maintenance!
  name: String!
  pointInTimeRecovery: Boolean!
  retainedBackups: Int!
  tier: String!
  type: String!
}

interface Storage {
  name: String!
}

type Subscription {
  log(input: LogSubscriptionInput): LogLine!
}

type Team implements Node {
  apps(after: Cursor, before: Cursor, first: Int, last: Int): AppConnection!
  deployKey: DeploymentKey!
  deployments(after: Cursor, before: Cursor, first: Int, last: Int, limit: Int): DeploymentConnection!
  description: String
  githubRepositories(after: Cursor, first: Int): GithubRepositoryConnection!
  id: ID!
  members(after: Cursor, before: Cursor, first: Int, last: Int): TeamMemberConnection!
  naisjobs(after: Cursor, before: Cursor, first: Int, last: Int): NaisJobConnection!
  name: String!
  slackAlertsChannels: [SlackAlertsChannel!]
  slackChannel: String
  viewerIsAdmin: Boolean!
  viewerIsMember: Boolean!
}

type TeamConnection {
  edges: [TeamEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TeamEdge {
  cursor: Cursor!
  node: Team!
}

type TeamMember implements Node {
  email: String!
  id: ID!
  name: String!
  role: TeamRole!
}

type TeamMemberConnection {
  edges: [TeamMemberEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type TeamMemberEdge {
  cursor: Cursor!
  node: TeamMember!
}

enum TeamRole {
  MEMBER
  OWNER
}

"""
Time is a string in [RFC 3339](https://rfc-editor.org/rfc/rfc3339.html) format, with sub-second precision added if present.
"""
scalar Time

type TokenX {
  mountSecretsAsFilesOnly: Boolean!
}

type Topic {
  acl: [Acl!]!
  name: String!
}

type User implements Node {
  email: String!
  id: ID!
  name: String!
  teams(after: Cursor, before: Cursor, first: Int, last: Int): TeamConnection!
}

type Variable {
  name: String!
  value: String!
}
