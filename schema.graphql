"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

input AddRepositoryToTeamInput {
  """Name of the repository, with the org prefix, for instance 'org/repo'."""
  repositoryName: String!

  """Slug of the team to add the repository to."""
  teamSlug: Slug!
}

type AddRepositoryToTeamPayload {
  """Repository that was added to the team."""
  repository: Repository
}

input AddTeamMemberInput {
  """The role that the user will have in the team."""
  role: TeamMemberRole!

  """Slug of the team that should receive a new member."""
  teamSlug: Slug!

  """The email address of the user to add to the team."""
  userEmail: String!
}

type AddTeamMemberPayload {
  """The added team member."""
  member: TeamMember
}

"""TODO: write"""
type Application implements Node & Workload {
  """List of authentication and authorization for the application."""
  authIntegrations: [ApplicationAuthIntegrations!]!

  """
  BigQuery datasets referenced by the application. This does not currently support pagination, but will return all available datasets.
  """
  bigQueryDatasets(
    """Ordering options for items returned from the connection."""
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """
  Google Cloud Storage referenced by the application. This does not currently support pagination, but will return all available buckets.
  """
  buckets(
    """Ordering options for items returned from the connection."""
    orderBy: BucketOrder
  ): BucketConnection!

  """The cost for the application."""
  cost: WorkloadCost!

  """The environment the application is deployed in."""
  environment: TeamEnvironment!

  """The globally unique ID of the application."""
  id: ID!

  """The container image of the application."""
  image: ContainerImage!

  """List of ingresses for the application."""
  ingresses: [Ingress!]!
  instances(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): InstanceConnection!

  """
  Kafka topics the application has access to. This does not currently support pagination, but will return all available Kafka topics.
  """
  kafkaTopicAcls(
    """Ordering options for items returned from the connection."""
    orderBy: KafkaTopicAclOrder
  ): KafkaTopicAclConnection!

  """The application manifest."""
  manifest: ApplicationManifest!

  """The name of the application."""
  name: String!

  """Network policies for the application."""
  networkPolicy: NetworkPolicy!

  """OpenSearch instance referenced by the workload."""
  openSearch: OpenSearch

  """
  Redis instances referenced by the application. This does not currently support pagination, but will return all available Redis instances.
  """
  redisInstances(
    """Ordering options for items returned from the connection."""
    orderBy: RedisInstanceOrder
  ): RedisInstanceConnection!

  """Resources for the application."""
  resources: ApplicationResources!

  """
  SQL instances referenced by the application. This does not currently support pagination, but will return all available SQL instances.
  """
  sqlInstances(
    """Ordering options for items returned from the connection."""
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!

  """Status of the application"""
  status: WorkloadStatus!

  """The team that owns the application."""
  team: Team!
  utilization: WorkloadUtilization!
}

union ApplicationAuthIntegrations = EntraIDAuthIntegration | IDPortenAuthIntegration | MaskinportenAuthIntegration | TokenXAuthIntegration

type ApplicationConnection {
  """List of edges."""
  edges: [ApplicationEdge!]!

  """List of nodes."""
  nodes: [Application!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type ApplicationEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The application."""
  node: Application!
}

type ApplicationManifest implements WorkloadManifest {
  """The manifest content, serialized as a YAML document."""
  content: String!
}

"""Ordering options when fetching applications."""
input ApplicationOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: ApplicationOrderField!
}

enum ApplicationOrderField {
  """Order applications by the deployment time."""
  DEPLOYMENT_TIME

  """Order applications by the name of the environment."""
  ENVIRONMENT

  """Order applications by name."""
  NAME

  """Order applications by status."""
  STATUS
}

type ApplicationResources implements WorkloadResources {
  """Instances using resources above this threshold will be killed."""
  limits: WorkloadResourceQuantity!

  """How many resources are allocated to each instance."""
  requests: WorkloadResourceQuantity!

  """Scaling strategies for the application."""
  scaling: ApplicationScaling!
}

"""TODO: write"""
type ApplicationScaling {
  """The maximum number of application instances."""
  maxInstances: Int!

  """The minimum number of application instances."""
  minInstances: Int!

  """Scaling strategies for the application."""
  strategies: [ScalingStrategy!]!
}

interface AuditEntry {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

type AuditEntryConnection {
  """List of edges."""
  edges: [AuditEntryEdge!]!

  """List of nodes."""
  nodes: [AuditEntry!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type AuditEntryEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The audit entry."""
  node: AuditEntry!
}

"""The type of the resource that was affected by the action."""
enum AuditResourceType {
  """All audit entries related to teams will use this resource type."""
  TEAM
  UNKNOWN
}

interface AuthIntegration {
  """The name of the integration."""
  name: String!
}

"""Authenticated user type. Can be a user or a service account."""
union AuthenticatedUser = User

type BigQueryDataset implements Node & Persistence {
  access(after: Cursor, before: Cursor, first: Int, last: Int, orderBy: BigQueryDatasetAccessOrder): BigQueryDatasetAccessConnection!
  cascadingDelete: Boolean!
  cost: BigQueryDatasetCost!
  description: String
  environment: TeamEnvironment!
  id: ID!
  name: String!
  status: BigQueryDatasetStatus!
  team: Team!
  workload: Workload
}

type BigQueryDatasetAccess {
  email: String!
  role: String!
}

type BigQueryDatasetAccessConnection {
  edges: [BigQueryDatasetAccessEdge!]!
  nodes: [BigQueryDatasetAccess!]!
  pageInfo: PageInfo!
}

type BigQueryDatasetAccessEdge {
  cursor: Cursor!
  node: BigQueryDatasetAccess!
}

input BigQueryDatasetAccessOrder {
  direction: OrderDirection!
  field: BigQueryDatasetAccessOrderField!
}

enum BigQueryDatasetAccessOrderField {
  EMAIL
  ROLE
}

type BigQueryDatasetConnection {
  edges: [BigQueryDatasetEdge!]!
  nodes: [BigQueryDataset!]!
  pageInfo: PageInfo!
}

type BigQueryDatasetCost {
  sum: Float!
}

type BigQueryDatasetEdge {
  cursor: Cursor!
  node: BigQueryDataset!
}

input BigQueryDatasetOrder {
  direction: OrderDirection!
  field: BigQueryDatasetOrderField!
}

enum BigQueryDatasetOrderField {
  ENVIRONMENT
  NAME
}

type BigQueryDatasetStatus {
  creationTime: Time!
  lastModifiedTime: Time
}

type Bucket implements Node & Persistence {
  cascadingDelete: Boolean!
  environment: TeamEnvironment!
  id: ID!
  name: String!
  publicAccessPrevention: String!
  status: BucketStatus!
  team: Team!
  uniformBucketLevelAccess: Boolean!
  workload: Workload
}

type BucketConnection {
  edges: [BucketEdge!]!
  nodes: [Bucket!]!
  pageInfo: PageInfo!
}

type BucketEdge {
  cursor: Cursor!
  node: Bucket!
}

input BucketOrder {
  direction: OrderDirection!
  field: BucketOrderField!
}

enum BucketOrderField {
  ENVIRONMENT
  NAME
}

type BucketStatus {
  state: String!
}

"""
A scaling strategy based on CPU usage

Read more: https://docs.nais.io/workloads/application/reference/automatic-scaling/#cpu-based-scaling
"""
type CPUScalingStrategy {
  """The threshold that must be met for the scaling to trigger."""
  threshold: Int!
}

input ConfirmTeamDeletionInput {
  """Deletion key, acquired using the requestTeamDeletion mutation."""
  key: String!

  """Slug of the team to confirm deletion for."""
  slug: Slug!
}

type ConfirmTeamDeletionPayload {
  """Whether or not the asynchronous deletion process was started."""
  deletionStarted: Boolean
}

type ContainerImage implements Node {
  """
  Whether the image has a software bill of materials (SBOM) attached to it.
  """
  hasSBOM: Boolean!

  """The globally unique ID of the container image node."""
  id: ID!

  """Name of the container image."""
  name: String!

  """Tag of the container image."""
  tag: String!

  """Get the vulnerabilities of the image."""
  vulnerabilities(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: ImageVulnerabilityOrder
  ): ImageVulnerabilityConnection!

  """Get the summary of the vulnerabilities of the image."""
  vulnerabilitySummary: ImageVulnerabilitySummary

  """Workloads using this container image."""
  workloadReferences(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ContainerImageWorkloadReferenceConnection!
}

type ContainerImageWorkloadReference {
  """The workload using the container image."""
  workload: Workload!
}

type ContainerImageWorkloadReferenceConnection {
  """List of edges."""
  edges: [ContainerImageWorkloadReferenceEdge!]!

  """List of nodes."""
  nodes: [ContainerImageWorkloadReference!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type ContainerImageWorkloadReferenceEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The workload reference."""
  node: ContainerImageWorkloadReference!
}

input CreateSecretInput {
  """The environment the secret exists in."""
  environment: String!

  """The name of the secret."""
  name: String!

  """The team that owns the secret."""
  team: Slug!
}

type CreateSecretPayload {
  """The created secret."""
  secret: Secret
}

input CreateTeamInput {
  """
  The purpose / description of the team.
  
  What is the team for? What is the team working on? This value is meant for human consumption, and should be enough
  to give a newcomer an idea of what the team is about.
  """
  purpose: String!

  """
  The main Slack channel for the team.
  
  Where does the team communicate? This value is used to link to the team's main Slack channel.
  """
  slackChannel: String!

  """
  Unique team slug.
  
  After creation, this value can not be changed. Also, after a potential deletion of the team, the slug can not be
  reused, so please choose wisely.
  """
  slug: Slug!
}

type CreateTeamPayload {
  """The newly created team."""
  team: Team
}

"""
A cursor for use in pagination

Cursors are opaque strings that are returned by the server for paginated results, and used when performing backwards / forwards pagination.
"""
scalar Cursor

"""Date type in YYYY-MM-DD format."""
scalar Date

input DeleteApplicationInput {
  """Name of the environment where the application runs."""
  environmentName: String!

  """Name of the application."""
  name: String!

  """Slug of the team that owns the application."""
  teamSlug: Slug!
}

type DeleteApplicationPayload {
  """The team that owned the deleted application."""
  team: Team
}

input DeleteJobInput {
  """Name of the environment where the job runs."""
  environmentName: String!

  """Name of the job."""
  name: String!

  """Slug of the team that owns the job."""
  teamSlug: Slug!
}

type DeleteJobPayload {
  """The team that owned the deleted job."""
  team: Team
}

input DeleteSecretInput {
  """The environment the secret exists in."""
  environment: String!

  """The name of the secret."""
  name: String!

  """The team that owns the secret."""
  team: Slug!
}

type DeleteSecretPayload {
  """The deleted secret."""
  secretDeleted: Boolean
}

type EntraIDAuthIntegration implements AuthIntegration {
  """The name of the integration."""
  name: String!
}

type ExternalNetworkPolicyHost implements ExternalNetworkPolicyTarget {
  ports: [Int!]!
  target: String!
}

type ExternalNetworkPolicyIpv4 implements ExternalNetworkPolicyTarget {
  ports: [Int!]!
  target: String!
}

interface ExternalNetworkPolicyTarget {
  ports: [Int!]!
  target: String!
}

type IDPortenAuthIntegration implements AuthIntegration {
  """The name of the integration."""
  name: String!
}

type ImageVulnerability implements Node {
  """Description of the vulnerability."""
  description: String!

  """The globally unique ID of the image vulnerability node."""
  id: ID!

  """The unique identifier of the vulnerability. E.g. CVE-****-****."""
  identifier: String!

  """Package name of the vulnerability."""
  package: String!

  """Severity of the vulnerability."""
  severity: ImageVulnerabilitySeverity!

  """State of the vulnerability."""
  state: ImageVulnerabilityState!

  """External URL to the vulnerability."""
  url: String!
}

type ImageVulnerabilityConnection {
  """List of edges."""
  edges: [ImageVulnerabilityEdge!]!

  """List of nodes."""
  nodes: [ImageVulnerability!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type ImageVulnerabilityEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The image vulnerability."""
  node: ImageVulnerability!
}

"""Ordering options when fetching teams."""
input ImageVulnerabilityOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: ImageVulnerabilityOrderField!
}

enum ImageVulnerabilityOrderField {
  RISK_SCORE
  SEVERITY
}

enum ImageVulnerabilitySeverity {
  CRITICAL
  HIGH
  LOW
  MEDIUM
  UNASSIGNED
}

enum ImageVulnerabilityState {
  FALSE_POSITIVE
  NOT_AFFECTED
  RESOLVED
  TRIAGE
}

type ImageVulnerabilitySummary {
  """Number of vulnerabilities with severity CRITICAL."""
  critical: Int!

  """Number of vulnerabilities with severity HIGH."""
  high: Int!

  """Number of vulnerabilities with severity LOW."""
  low: Int!

  """Number of vulnerabilities with severity MEDIUM."""
  medium: Int!

  """Risk score of the image."""
  riskScore: Int!

  """Total number of vulnerabilities."""
  total: Int!

  """Number of vulnerabilities with severity UNASSIGNED."""
  unassigned: Int!
}

type InboundNetworkPolicy {
  rules: [NetworkPolicyRule!]!
}

type Ingress {
  """Type of ingress."""
  type: IngressType!

  """URL for the ingress."""
  url: String!
}

enum IngressType {
  AUTHENTICATED
  EXTERNAL
  INTERNAL
  UNKNOWN
}

type Instance implements Node {
  created: Time!
  id: ID!
  image: ContainerImage!
  name: String!
  restarts: Int!
  status: InstanceStatus!
}

type InstanceConnection {
  """List of edges."""
  edges: [InstanceEdge!]!

  """List of nodes."""
  nodes: [Instance!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type InstanceEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The instance."""
  node: Instance!
}

enum InstanceState {
  FAILING
  RUNNING
  UNKNOWN
}

type InstanceStatus {
  message: String!
  state: InstanceState!
}

type Job implements Node & Workload {
  """List of authentication and authorization for the job."""
  authIntegrations: [JobAuthIntegrations!]!

  """
  BigQuery datasets referenced by the job. This does not currently support pagination, but will return all available datasets.
  """
  bigQueryDatasets(
    """Ordering options for items returned from the connection."""
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """
  Google Cloud Storage referenced by the job. This does not currently support pagination, but will return all available buckets.
  """
  buckets(
    """Ordering options for items returned from the connection."""
    orderBy: BucketOrder
  ): BucketConnection!

  """The cost for the job."""
  cost: WorkloadCost!

  """The environment the job is deployed in."""
  environment: TeamEnvironment!

  """The globally unique ID of the job."""
  id: ID!

  """The container image of the job."""
  image: ContainerImage!

  """
  Kafka topics the job has access to. This does not currently support pagination, but will return all available Kafka topics.
  """
  kafkaTopicAcls(
    """Ordering options for items returned from the connection."""
    orderBy: KafkaTopicAclOrder
  ): KafkaTopicAclConnection!

  """The job manifest."""
  manifest: JobManifest!

  """The name of the job."""
  name: String!

  """Network policies for the job."""
  networkPolicy: NetworkPolicy!

  """OpenSearch instance referenced by the workload."""
  openSearch: OpenSearch

  """
  Redis instances referenced by the job. This does not currently support pagination, but will return all available Redis instances.
  """
  redisInstances(
    """Ordering options for items returned from the connection."""
    orderBy: RedisInstanceOrder
  ): RedisInstanceConnection!

  """Resources for the job."""
  resources: JobResources!

  """The job runs."""
  runs(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): JobRunConnection!

  """Optional schedule for the job. Jobs with no schedule are run once."""
  schedule: JobSchedule

  """
  SQL instances referenced by the job. This does not currently support pagination, but will return all available SQL instances.
  """
  sqlInstances(
    """Ordering options for items returned from the connection."""
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!

  """Status of the job"""
  status: WorkloadStatus!

  """The team that owns the job."""
  team: Team!
}

union JobAuthIntegrations = EntraIDAuthIntegration | MaskinportenAuthIntegration

type JobConnection {
  """List of edges."""
  edges: [JobEdge!]!

  """List of nodes."""
  nodes: [Job!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type JobEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The job."""
  node: Job!
}

type JobManifest implements WorkloadManifest {
  """The manifest content, serialized as a YAML document."""
  content: String!
}

input JobOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: JobOrderField!
}

enum JobOrderField {
  """Order Jobs by the deployment time."""
  DEPLOYMENT_TIME

  """Order jobs by the name of the environment."""
  ENVIRONMENT

  """Order jobs by name."""
  NAME

  """Order jobs by status."""
  STATUS
}

type JobResources implements WorkloadResources {
  limits: WorkloadResourceQuantity!
  requests: WorkloadResourceQuantity!
}

type JobRun implements Node {
  """The completion time of the job."""
  completionTime: Time

  """The globally unique ID of the job run."""
  id: ID!
  image: ContainerImage!

  """The name of the job run."""
  name: String!

  """The start time of the job."""
  startTime: Time

  """The status of the job run."""
  status: JobRunStatus!
}

type JobRunConnection {
  """List of edges."""
  edges: [JobRunEdge!]!

  """List of nodes."""
  nodes: [JobRun!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type JobRunEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The job run."""
  node: JobRun!
}

enum JobRunStatus {
  """Job run is failed."""
  FAILED

  """Job run is pending."""
  PENDING

  """Job run is running."""
  RUNNING

  """Job run is succeeded."""
  SUCCEEDED

  """Job run is unknown."""
  UNKNOWN
}

type JobSchedule {
  """The cron expression for the job."""
  expression: String!

  """The time zone for the job. Defaults to UTC."""
  timeZone: String!
}

type KafkaLagScalingStrategy {
  """The consumer group of the topic."""
  consumerGroup: String!

  """The threshold that must be met for the scaling to trigger."""
  threshold: Int!

  """The name of the Kafka topic."""
  topicName: String!
}

type KafkaTopic implements Node & Persistence {
  acl(after: Cursor, before: Cursor, filter: KafkaTopicAclFilter, first: Int, last: Int, orderBy: KafkaTopicAclOrder): KafkaTopicAclConnection!
  configuration: KafkaTopicConfiguration
  environment: TeamEnvironment!
  id: ID!
  name: String!
  pool: String!
  status: KafkaTopicStatus!
  team: Team!
}

type KafkaTopicAcl {
  access: String!
  team: Team
  teamName: String!
  topic: KafkaTopic!
  workload: Workload
  workloadName: String!
}

type KafkaTopicAclConnection {
  edges: [KafkaTopicAclEdge!]!
  nodes: [KafkaTopicAcl!]!
  pageInfo: PageInfo!
}

type KafkaTopicAclEdge {
  cursor: Cursor!
  node: KafkaTopicAcl!
}

input KafkaTopicAclFilter {
  team: Slug
  workload: String
}

input KafkaTopicAclOrder {
  direction: OrderDirection!
  field: KafkaTopicAclOrderField!
}

enum KafkaTopicAclOrderField {
  ACCESS
  CONSUMER
  TEAM_SLUG
  TOPIC_NAME
}

type KafkaTopicConfiguration {
  cleanupPolicy: String
  maxMessageBytes: Int
  minimumInSyncReplicas: Int
  partitions: Int
  replication: Int
  retentionBytes: Int
  retentionHours: Int
  segmentHours: Int
}

type KafkaTopicConnection {
  edges: [KafkaTopicEdge!]!
  nodes: [KafkaTopic!]!
  pageInfo: PageInfo!
}

type KafkaTopicEdge {
  cursor: Cursor!
  node: KafkaTopic!
}

input KafkaTopicOrder {
  direction: OrderDirection!
  field: KafkaTopicOrderField!
}

enum KafkaTopicOrderField {
  ENVIRONMENT
  NAME
}

type KafkaTopicStatus {
  state: String!
}

type MaskinportenAuthIntegration implements AuthIntegration {
  """The name of the integration."""
  name: String!
}

"""The mutation root for the NAIS GraphQL API."""
type Mutation {
  """Add a team repository."""
  addRepositoryToTeam(input: AddRepositoryToTeamInput!): AddRepositoryToTeamPayload!

  """
  Add a team member
  
  If the user is already a member or an owner of the team, the mutation will result in an error.
  """
  addTeamMember(input: AddTeamMemberInput!): AddTeamMemberPayload!

  """Configure a reconciler."""
  configureReconciler(
    """List of reconciler config inputs."""
    config: [ReconcilerConfigInput!]!

    """The name of the reconciler to configure."""
    name: String!
  ): Reconciler!

  """
  Confirm a team deletion
  
  This will start the actual team deletion process, which will be done in an asynchronous manner. All external
  entities controlled by NAIS will also be deleted.
  
  WARNING: There is no going back after starting this process.
  
  Note: Service accounts are not allowed to confirm a team deletion.
  """
  confirmTeamDeletion(input: ConfirmTeamDeletionInput!): ConfirmTeamDeletionPayload!

  """Create a new secret."""
  createSecret(input: CreateSecretInput!): CreateSecretPayload!

  """
  Create a new NAIS team
  
  The user creating the team will be granted team ownership, unless the user is a service account, in which case the
  team will not get an initial owner. To add one or more owners to the team, refer to the `addTeamOwners` mutation.
  
  Creation of a team will also create external resources for the team, which will be managed by the NAIS API
  reconcilers. This will be done asynchronously.
  
  Refer to the [official NAIS documentation](https://docs.nais.io/explanations/team/) for more information regarding
  NAIS teams.
  """
  createTeam(input: CreateTeamInput!): CreateTeamPayload!

  """Delete an application."""
  deleteApplication(input: DeleteApplicationInput!): DeleteApplicationPayload!

  """Delete a job."""
  deleteJob(input: DeleteJobInput!): DeleteJobPayload!

  """Delete a secret and the values it contains."""
  deleteSecret(input: DeleteSecretInput!): DeleteSecretPayload!

  """
  Disable a reconciler
  
  The reconciler configuration will be left intact.
  """
  disableReconciler(
    """The name of the reconciler to disable."""
    name: String!
  ): Reconciler!

  """
  Enable a reconciler
  
  A reconciler must be fully configured before it can be enabled.
  """
  enableReconciler(
    """The name of the reconciler to enable."""
    name: String!
  ): Reconciler!

  """Remove a team repository."""
  removeRepositoryFromTeam(input: RemoveRepositoryFromTeamInput!): RemoveRepositoryFromTeamPayload!

  """Remove a secret value from a secret."""
  removeSecretValue(input: RemoveSecretValueInput!): RemoveSecretValuePayload!

  """
  Remove a team member
  
  If the user is not already a member or an owner of the team, the mutation will result in an error.
  """
  removeTeamMember(input: RemoveTeamMemberInput!): RemoveTeamMemberPayload!

  """
  Request a key that can be used to trigger a team deletion process
  
  Deleting a team is a two step process. First an owner of the team (or an admin) must request a team deletion key,
  and then a second owner of the team (or an admin) must confirm the deletion using the confirmTeamDeletion mutation.
  
  The returned delete key is valid for an hour, and can only be used once.
  
  Note: Service accounts are not allowed to request team delete keys.
  """
  requestTeamDeletion(input: RequestTeamDeletionInput!): RequestTeamDeletionPayload!

  """Restart an application."""
  restartApplication(input: RestartApplicationInput!): RestartApplicationPayload!

  """
  Set a secret value in a secret. If the value already exists the secret value will be updated.
  """
  setSecretValue(input: SetSecretValueInput!): SetSecretValuePayload!

  """
  Assign a role to a team member
  
  The user must already be a member of the team for this mutation to succeed.
  """
  setTeamMemberRole(input: SetTeamMemberRoleInput!): SetTeamMemberRolePayload!

  """
  Manually synchronize a team
  
  This action will trigger a full synchronization of the team with the configured third party systems. The process is
  asynchronous.
  """
  synchronizeTeam(input: SynchronizeTeamInput!): SynchronizeTeamPayload!

  """Trigger a job"""
  triggerJob(input: TriggerJobInput!): TriggerJobPayload!

  """
  Update an existing NAIS team
  
  This mutation can be used to update the team purpose and the main Slack channel. It is not possible to update the
  team slug.
  """
  updateTeam(input: UpdateTeamInput!): UpdateTeamPayload!

  """Update an environment for a team"""
  updateTeamEnvironment(input: UpdateTeamEnvironmentInput!): UpdateTeamEnvironmentPayload!
}

type NetworkPolicy {
  inbound: InboundNetworkPolicy!
  outbound: OutboundNetworkPolicy!
}

type NetworkPolicyRule {
  mutual: Boolean!
  targetTeam: Team
  targetTeamSlug: Slug!
  targetWorkload: Workload
  targetWorkloadName: String!
}

"""
This interface is implemented by types that supports the [Global Object Identification specification](https://graphql.org/learn/global-object-identification/).
"""
interface Node {
  """Globally unique ID of the object."""
  id: ID!
}

type OpenSearch implements Node & Persistence {
  access(after: Cursor, before: Cursor, first: Int, last: Int, orderBy: OpenSearchAccessOrder): OpenSearchAccessConnection!
  cost: OpenSearchCost!
  environment: TeamEnvironment!
  id: ID!
  name: String!
  status: OpenSearchStatus!
  team: Team!
  workload: Workload
}

type OpenSearchAccess {
  access: String!
  workload: Workload!
}

type OpenSearchAccessConnection {
  edges: [OpenSearchAccessEdge!]!
  nodes: [OpenSearchAccess!]!
  pageInfo: PageInfo!
}

type OpenSearchAccessEdge {
  cursor: Cursor!
  node: OpenSearchAccess!
}

input OpenSearchAccessOrder {
  direction: OrderDirection!
  field: OpenSearchAccessOrderField!
}

enum OpenSearchAccessOrderField {
  ACCESS
  WORKLOAD
}

type OpenSearchConnection {
  edges: [OpenSearchEdge!]!
  nodes: [OpenSearch!]!
  pageInfo: PageInfo!
}

type OpenSearchCost {
  sum: Float!
}

type OpenSearchEdge {
  cursor: Cursor!
  node: OpenSearch!
}

input OpenSearchOrder {
  direction: OrderDirection!
  field: OpenSearchOrderField!
}

enum OpenSearchOrderField {
  ENVIRONMENT
  NAME
}

type OpenSearchStatus {
  state: String!
}

"""Possible directions in which to order a list of items."""
enum OrderDirection {
  """Ascending sort order."""
  ASC

  """Descending sort order."""
  DESC
}

type OutboundNetworkPolicy {
  external: [ExternalNetworkPolicyTarget!]!
  rules: [NetworkPolicyRule!]!
}

"""
This type is used for paginating the connection

Learn more about how we have implemented pagination in the [GraphQL Best Practices documentation](https://graphql.org/learn/pagination/).
"""
type PageInfo {
  """
  The cursor for the last item in the edges. This cursor is used when paginating forwards.
  """
  endCursor: Cursor

  """Whether or not there exists a next page in the connection."""
  hasNextPage: Boolean!

  """Whether or not there exists a previous page in the connection."""
  hasPreviousPage: Boolean!

  """The offset of the last item in the connection."""
  pageEnd: Int!

  """The offset of the first item in the connection."""
  pageStart: Int!

  """
  The cursor for the first item in the edges. This cursor is used when paginating backwards.
  """
  startCursor: Cursor

  """The total amount of items in the connection."""
  totalCount: Int!
}

interface Persistence {
  environment: TeamEnvironment!
  id: ID!
  name: String!
  team: Team!
}

"""The query root for the NAIS GraphQL API."""
type Query {
  """The currently authenticated user."""
  me: AuthenticatedUser!

  """Fetch an object using its globally unique ID."""
  node(id: ID!): Node

  """Get a collection of reconcilers."""
  reconcilers(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ReconcilerConnection!
  search(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor
    filter: SearchFilter!

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): SearchNodeConnection!

  """Get a team by its slug."""
  team(slug: Slug!): Team!

  """Get a list of teams."""
  teams(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: TeamOrder
  ): TeamConnection!
  teamsUtilization(resourceType: UtilizationResourceType!): [TeamUtilizationData!]!

  """Get a user by its ID."""
  user(id: ID!): User!

  """Get a list of users."""
  users(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: UserOrder
  ): UserConnection!
}

"""Reconciler type."""
type Reconciler {
  """Reconciler configuration keys and descriptions."""
  config: [ReconcilerConfig!]!

  """
  Whether or not the reconciler is fully configured and ready to be enabled.
  """
  configured: Boolean!

  """Description of what the reconciler is responsible for."""
  description: String!

  """The human-friendly name of the reconciler."""
  displayName: String!

  """Whether or not the reconciler is enabled."""
  enabled: Boolean!

  """The name of the reconciler."""
  name: String!
}

"""Reconciler configuration type."""
type ReconcilerConfig {
  """Whether or not the configuration key has a value."""
  configured: Boolean!

  """Configuration description."""
  description: String!

  """The human-friendly name of the configuration key."""
  displayName: String!

  """Configuration key."""
  key: String!

  """
  Whether or not the configuration value is considered a secret. Secret values will not be exposed through the API.
  """
  secret: Boolean!

  """
  Configuration value. This will be set to null if the value is considered a secret.
  """
  value: String
}

"""Reconciler configuration input."""
input ReconcilerConfigInput {
  """Configuration key."""
  key: String!

  """Configuration value."""
  value: String!
}

type ReconcilerConnection {
  """List of edges."""
  edges: [ReconcilerEdge!]!

  """List of nodes."""
  nodes: [Reconciler!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type ReconcilerEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The reconciler."""
  node: Reconciler!
}

type RedisInstance implements Node & Persistence {
  access(after: Cursor, before: Cursor, first: Int, last: Int, orderBy: RedisInstanceAccessOrder): RedisInstanceAccessConnection!
  cost: RedisInstanceCost!
  environment: TeamEnvironment!
  id: ID!
  name: String!
  status: RedisInstanceStatus!
  team: Team!
  workload: Workload
}

type RedisInstanceAccess {
  access: String!
  workload: Workload!
}

type RedisInstanceAccessConnection {
  edges: [RedisInstanceAccessEdge!]!
  nodes: [RedisInstanceAccess!]!
  pageInfo: PageInfo!
}

type RedisInstanceAccessEdge {
  cursor: Cursor!
  node: RedisInstanceAccess!
}

input RedisInstanceAccessOrder {
  direction: OrderDirection!
  field: RedisInstanceAccessOrderField!
}

enum RedisInstanceAccessOrderField {
  ACCESS
  WORKLOAD
}

type RedisInstanceConnection {
  edges: [RedisInstanceEdge!]!
  nodes: [RedisInstance!]!
  pageInfo: PageInfo!
}

type RedisInstanceCost {
  sum: Float!
}

type RedisInstanceEdge {
  cursor: Cursor!
  node: RedisInstance!
}

input RedisInstanceOrder {
  direction: OrderDirection!
  field: RedisInstanceOrderField!
}

enum RedisInstanceOrderField {
  ENVIRONMENT
  NAME
}

type RedisInstanceStatus {
  state: String!
}

input RemoveRepositoryFromTeamInput {
  """Name of the repository, with the org prefix, for instance 'org/repo'."""
  repositoryName: String!

  """Slug of the team to remove the repository from."""
  teamSlug: Slug!
}

type RemoveRepositoryFromTeamPayload {
  """Whether or not the repository was removed from the team."""
  success: Boolean
}

input RemoveSecretValueInput {
  """The environment the secret exists in."""
  environment: String!

  """The name of the secret."""
  secretName: String!

  """The team that owns the secret."""
  team: Slug!

  """The secret value to remove."""
  valueName: String!
}

type RemoveSecretValuePayload {
  """The updated secret."""
  secret: Secret
}

input RemoveTeamMemberInput {
  """Slug of the team that the member should be removed from."""
  teamSlug: Slug!

  """The email address of the user to remove from the team."""
  userEmail: String!
}

type RemoveTeamMemberPayload {
  """The team that the member was removed from."""
  team: Team

  """The user that was removed from the team."""
  user: User
}

type Repository implements Node {
  """ID of the repository."""
  id: ID!

  """Name of the repository, with the organization prefix."""
  name: String!

  """Team this repository is connected to."""
  team: Team!
}

type RepositoryConnection {
  """List of edges."""
  edges: [RepositoryEdge!]!

  """List of nodes."""
  nodes: [Repository!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type RepositoryEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The GitHub repository."""
  node: Repository!
}

input RequestTeamDeletionInput {
  """Slug of the team to request a team deletion key for."""
  slug: Slug!
}

type RequestTeamDeletionPayload {
  """
  The delete key for the team. This can be used to confirm the deletion of the team.
  """
  key: TeamDeleteKey
}

input RestartApplicationInput {
  """Name of the environment where the application runs."""
  environmentName: String!

  """Name of the application."""
  name: String!

  """Slug of the team that owns the application."""
  teamSlug: Slug!
}

type RestartApplicationPayload {
  """The application that was restarted."""
  application: Application
}

union ScalingStrategy = CPUScalingStrategy | KafkaLagScalingStrategy

input SearchFilter {
  query: String!
  type: SearchType
}

union SearchNode = Application | BigQueryDataset | Bucket | Job | KafkaTopic | OpenSearch | RedisInstance | SqlInstance | Team

type SearchNodeConnection {
  """List of edges."""
  edges: [SearchNodeEdge!]!

  """List of nodes."""
  nodes: [SearchNode!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type SearchNodeEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The SearchNode."""
  node: SearchNode!
}

enum SearchType {
  APPLICATION
  BIGQUERY_DATASET
  BUCKET
  JOB
  KAFKA_TOPIC
  OPENSEARCH
  REDIS_INSTANCE
  SQL_INSTANCE
  TEAM
}

"""A secret is a collection of secret values."""
type Secret implements Node {
  """Applications that use the secret."""
  applications(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ApplicationConnection!

  """The environment the secret exists in."""
  environment: TeamEnvironment!

  """The globally unique ID of the secret."""
  id: ID!

  """Jobs that use the secret."""
  jobs(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): JobConnection!

  """Last time the secret was modified."""
  lastModifiedAt: Time

  """User who last modified the secret."""
  lastModifiedBy: User

  """The name of the secret."""
  name: String!

  """The team that owns the secret."""
  team: Team!

  """The secret values contained within the secret."""
  values: [SecretValue!]!

  """Workloads that use the secret."""
  workloads(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): WorkloadConnection!
}

type SecretConnection {
  """List of edges."""
  edges: [SecretEdge!]!

  """List of nodes."""
  nodes: [Secret!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type SecretCreatedAuditEntry implements AuditEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type SecretEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The Secret."""
  node: Secret!
}

type SecretValue {
  """The name of the secret value."""
  name: String!

  """The secret value itself."""
  value: String!
}

input SecretValueInput {
  """The name of the secret value."""
  name: String!

  """The secret value to set."""
  value: String!
}

type ServiceCost {
  """The cost in euros."""
  cost: Float!

  """The name of the service."""
  service: String!
}

type ServiceCostSeries {
  """
  The date for the cost. When calculating the cost for a monthly period, the date will be the last day of the month that has cost data.
  """
  date: Date!

  """The cost for the services used by the workload."""
  services: [ServiceCost!]!

  """The sum of the cost across all services."""
  sum: Float!
}

input SetSecretValueInput {
  """The environment the secret exists in."""
  environment: String!

  """The name of the secret."""
  name: String!

  """The team that owns the secret."""
  team: Slug!

  """The secret value to set."""
  value: SecretValueInput!
}

type SetSecretValuePayload {
  """The added / updated secret."""
  secret: Secret
}

input SetTeamMemberRoleInput {
  """The role to assign."""
  role: TeamMemberRole!

  """The slug of the team."""
  teamSlug: Slug!

  """The email address of the user."""
  userEmail: String!
}

type SetTeamMemberRolePayload {
  """The updated team member."""
  member: TeamMember
}

"""
The slug must:

- contain only lowercase alphanumeric characters or hyphens
- contain at least 3 characters and at most 30 characters
- start with an alphabetic character
- end with an alphanumeric character
- not contain two hyphens in a row

Examples of valid slugs:

- `some-value`
- `someothervalue`
- `my-team-123`
"""
scalar Slug

type SqlDatabase implements Node & Persistence {
  charset: String
  collation: String
  deletionPolicy: String
  environment: TeamEnvironment!
  healthy: Boolean!
  id: ID!
  name: String!
  team: Team!
}

type SqlInstance implements Node & Persistence {
  backupConfiguration: SqlInstanceBackupConfiguration
  cascadingDelete: Boolean!
  connectionName: String
  database: SqlDatabase
  diskAutoresize: Boolean
  diskAutoresizeLimit: Int
  environment: TeamEnvironment!
  flags(after: Cursor, before: Cursor, first: Int, last: Int): SqlInstanceFlagConnection!
  healthy: Boolean!
  highAvailability: Boolean!
  id: ID!
  maintenanceVersion: String
  maintenanceWindow: SqlInstanceMaintenanceWindow
  name: String!
  projectID: String!
  status: SqlInstanceStatus!
  team: Team!
  tier: String!
  users(after: Cursor, before: Cursor, first: Int, last: Int, orderBy: SqlInstanceUserOrder): SqlInstanceUserConnection!
  version: String
  workload: Workload
}

type SqlInstanceBackupConfiguration {
  enabled: Boolean
  pointInTimeRecovery: Boolean
  retainedBackups: Int
  startTime: String
  transactionLogRetentionDays: Int
}

type SqlInstanceConnection {
  edges: [SqlInstanceEdge!]!
  nodes: [SqlInstance!]!
  pageInfo: PageInfo!
}

type SqlInstanceEdge {
  cursor: Cursor!
  node: SqlInstance!
}

type SqlInstanceFlag {
  name: String!
  value: String!
}

type SqlInstanceFlagConnection {
  edges: [SqlInstanceFlagEdge!]!
  nodes: [SqlInstanceFlag!]!
  pageInfo: PageInfo!
}

type SqlInstanceFlagEdge {
  cursor: Cursor!
  node: SqlInstanceFlag!
}

type SqlInstanceMaintenanceWindow {
  day: Int!
  hour: Int!
}

input SqlInstanceOrder {
  direction: OrderDirection!
  field: SqlInstanceOrderField!
}

enum SqlInstanceOrderField {
  ENVIRONMENT
  NAME
  VERSION
}

type SqlInstanceStatus {
  privateIpAddress: String
  publicIpAddress: String
}

type SqlInstanceUser {
  authentication: String!
  name: String!
}

type SqlInstanceUserConnection {
  edges: [SqlInstanceUserEdge!]!
  nodes: [SqlInstanceUser!]!
  pageInfo: PageInfo!
}

type SqlInstanceUserEdge {
  cursor: Cursor!
  node: SqlInstanceUser!
}

input SqlInstanceUserOrder {
  direction: OrderDirection!
  field: SqlInstanceUserOrderField!
}

enum SqlInstanceUserOrderField {
  AUTHENTICATION
  NAME
}

type Subscription {
  """
  Subscribe to workload logs
  
  This subscription is used to stream logs from a specific workload. When filtering logs you must either specify an
  application or a job owned by a team that is running in a specific environment. You can also filter logs on instance
  name(s).
  """
  workloadLog(filter: WorkloadLogSubscriptionFilter!): WorkloadLogLine!
}

input SynchronizeTeamInput {
  """Slug of the team to synchronize."""
  slug: Slug!
}

type SynchronizeTeamPayload {
  """The synchronized team."""
  team: Team
}

"""
The team type represents a team on the [NAIS platform](https://nais.io/).

Learn more about what NAIS teams are and what they can be used for in the [official NAIS documentation](https://docs.nais.io/explanations/team/).

External resources (e.g. azureGroupID, gitHubTeamSlug) are managed by [NAIS API reconcilers](https://github.com/nais/api-reconcilers).
"""
type Team implements Node {
  """NAIS applications owned by the team."""
  applications(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: ApplicationOrder
  ): ApplicationConnection!

  """Audit entries associated with the team."""
  auditEntries(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): AuditEntryConnection!

  """
  The ID of the Azure AD group for the team. This value is managed by the Azure AD reconciler.
  """
  azureGroupID: String

  """BigQuery datasets owned by the team."""
  bigQueryDatasets(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """Google Cloud Storage buckets owned by the team."""
  buckets(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: BucketOrder
  ): BucketConnection!

  """
  The CDN bucket for the team. This value is managed by the Google CDN reconciler.
  """
  cdnBucket: String

  """The cost for the team."""
  cost: TeamCost!

  """Get a delete key for the team."""
  deleteKey(key: String!): TeamDeleteKey!

  """Whether or not the team is currently being deleted."""
  deletionInProgress: Boolean!

  """Get a specific environment for the team."""
  environment(name: String!): TeamEnvironment!

  """Environments for the team."""
  environments: [TeamEnvironment!]!

  """
  The slug of the GitHub team. This value is managed by the GitHub reconciler.
  """
  gitHubTeamSlug: String

  """
  The Google Artifact Registry for the team. This value is managed by the Google Artifact Registry (GAR) reconciler.
  """
  googleArtifactRegistry: String

  """
  The email address of the Google Workspace group for the team. This value is managed by the Google Workspace reconciler.
  """
  googleGroupEmail: String

  """The globally unique ID of the team."""
  id: ID!

  """Overall inventory of resources for the team."""
  inventoryCounts: TeamInventoryCounts!

  """NAIS jobs owned by the team."""
  jobs(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: JobOrder
  ): JobConnection!

  """Kafka topics owned by the team."""
  kafkaTopics(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: KafkaTopicOrder
  ): KafkaTopicConnection!

  """Timestamp of the last successful synchronization of the team."""
  lastSuccessfulSync: Time

  """Get a specific member of the team."""
  member(email: String!): TeamMember!

  """Team members."""
  members(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: TeamMemberOrder
  ): TeamMemberConnection!

  """OpenSearch instances owned by the team."""
  openSearchInstances(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: OpenSearchOrder
  ): OpenSearchConnection!

  """Purpose of the team."""
  purpose: String!

  """Redis instances owned by the team."""
  redisInstances(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: RedisInstanceOrder
  ): RedisInstanceConnection!
  repositories(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor
    filter: TeamRepositoryFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): RepositoryConnection!

  """Secrets owned by the team."""
  secrets(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): SecretConnection!

  """Main Slack channel for the team."""
  slackChannel: String!

  """Unique slug of the team."""
  slug: Slug!

  """SQL instances owned by the team."""
  sqlInstances(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!

  """Whether or not the viewer is a member of the team."""
  viewerIsMember: Boolean!

  """Whether or not the viewer is an owner of the team."""
  viewerIsOwner: Boolean!
  vulnerabilitySummary: TeamVulnerabilitySummary!
  workloadUtilization(resourceType: UtilizationResourceType!): [WorkloadUtilizationData]!

  """NAIS Workloads owned by the team."""
  workloads(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: WorkloadOrder
  ): WorkloadConnection!
}

type TeamConfirmDeleteKeyAuditEntry implements AuditEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamConnection {
  """List of edges."""
  edges: [TeamEdge!]!

  """List of nodes."""
  nodes: [Team!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type TeamCost {
  daily(
    """Start date of the period, inclusive."""
    from: Date!

    """End date of the period, inclusive."""
    to: Date!
  ): TeamCostPeriod!
  monthlySummary: TeamCostMonthlySummary!
}

type TeamCostMonthlySample {
  """The total cost for the month."""
  cost: Float!

  """The last date with cost data in the month."""
  date: Date!
}

type TeamCostMonthlySummary {
  """The cost series."""
  series: [TeamCostMonthlySample!]!

  """The total cost for the last 12 months."""
  sum: Float!
}

type TeamCostPeriod {
  """The cost series."""
  series: [ServiceCostSeries!]!

  """The total cost for the period."""
  sum: Float!
}

type TeamCreateDeleteKeyAuditEntry implements AuditEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamCreatedAuditEntry implements AuditEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamDeleteKey {
  """The creation timestamp of the key."""
  createdAt: Time!

  """The user who created the key."""
  createdBy: User!

  """Expiration timestamp of the key."""
  expires: Time!

  """The unique key used to confirm the deletion of a team."""
  key: String!

  """The team the delete key is for."""
  team: Team!
}

type TeamEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The team."""
  node: Team!
}

type TeamEnvironment implements Node {
  """NAIS application in the team environment."""
  application(name: String!): Application!

  """BigQuery datasets in the team environment."""
  bigQueryDataset(name: String!): BigQueryDataset!

  """Storage bucket in the team environment."""
  bucket(name: String!): Bucket!

  """The GCP project ID for the team environment."""
  gcpProjectID: String

  """The globally unique ID of the team environment."""
  id: ID!

  """NAIS job in the team environment."""
  job(name: String!): Job!

  """Kafka topic in the team environment."""
  kafkaTopic(name: String!): KafkaTopic!

  """Name of the team environment."""
  name: String!

  """OpenSearch instance in the team environment."""
  openSearchInstance(name: String!): OpenSearch!

  """Redis instance in the team environment."""
  redisInstance(name: String!): RedisInstance!

  """Get a secret by name."""
  secret(name: String!): Secret!

  """The Slack alerts channel for the team environment."""
  slackAlertsChannel: String!

  """SQL instance in the team environment."""
  sqlInstance(name: String!): SqlInstance!

  """The connected team."""
  team: Team!
}

type TeamEnvironmentUpdatedAuditEntry implements AuditEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the action."""
  data: TeamEnvironmentUpdatedAuditEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamEnvironmentUpdatedAuditEntryData {
  """The name of the environment that was updated."""
  environmentName: String!

  """Fields that were updated."""
  updatedFields: [TeamEnvironmentUpdatedAuditEntryDataUpdatedField!]!
}

type TeamEnvironmentUpdatedAuditEntryDataUpdatedField {
  """The name of the field."""
  field: String!

  """The new value of the field."""
  newValue: String

  """The old value of the field."""
  oldValue: String
}

type TeamInventoryCountApplications {
  """Number of applications considered not nais."""
  notNais: Int!

  """Total number of applications."""
  total: Int!
}

type TeamInventoryCountBigQueryDatasets {
  """Total number of BigQuery datasets."""
  total: Int!
}

type TeamInventoryCountBuckets {
  """Total number of Google Cloud Storage buckets."""
  total: Int!
}

type TeamInventoryCountJobs {
  """Number of jobs considered not nais."""
  notNais: Int!

  """Total number of jobs."""
  total: Int!
}

type TeamInventoryCountKafkaTopics {
  """Total number of Kafka topics."""
  total: Int!
}

type TeamInventoryCountOpenSearchInstances {
  """Total number of OpenSearch instances."""
  total: Int!
}

type TeamInventoryCountRedisInstances {
  """Total number of Redis instances."""
  total: Int!
}

type TeamInventoryCountSqlInstances {
  """Total number of SQL instances."""
  total: Int!
}

type TeamInventoryCounts {
  applications: TeamInventoryCountApplications!
  bigQueryDatasets: TeamInventoryCountBigQueryDatasets!
  buckets: TeamInventoryCountBuckets!
  jobs: TeamInventoryCountJobs!
  kafkaTopics: TeamInventoryCountKafkaTopics!
  openSearchInstances: TeamInventoryCountOpenSearchInstances!
  redisInstances: TeamInventoryCountRedisInstances!
  sqlInstances: TeamInventoryCountSqlInstances!
}

type TeamMember {
  """The role that the user has in the team."""
  role: TeamMemberRole!

  """Team instance."""
  team: Team!

  """User instance."""
  user: User!
}

type TeamMemberAddedAuditEntry implements AuditEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the action."""
  data: TeamMemberAddedAuditEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamMemberAddedAuditEntryData {
  """The role that the user was added with."""
  role: TeamMemberRole!

  """The user itself."""
  user: User

  """The email address of the user that was added."""
  userEmail: String!

  """The ID of the user that was added."""
  userID: ID!
}

type TeamMemberConnection {
  """List of edges."""
  edges: [TeamMemberEdge!]!

  """List of nodes."""
  nodes: [TeamMember!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type TeamMemberEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The team member."""
  node: TeamMember!
}

"""Ordering options for team members."""
input TeamMemberOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: TeamMemberOrderField!
}

"""Possible fields to order team members by."""
enum TeamMemberOrderField {
  """The email address of the user."""
  EMAIL

  """The name of user."""
  NAME

  """The role the user has in the team."""
  ROLE
}

type TeamMemberRemovedAuditEntry implements AuditEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the action."""
  data: TeamMemberRemovedAuditEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamMemberRemovedAuditEntryData {
  """The user itself."""
  user: User

  """The email address of the user that was removed."""
  userEmail: String!

  """The ID of the user that was removed."""
  userID: ID!
}

"""Team member roles."""
enum TeamMemberRole {
  """Regular member, read only access."""
  MEMBER

  """Team owner, full access to the team."""
  OWNER
}

type TeamMemberSetRoleAuditEntry implements AuditEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the action."""
  data: TeamMemberSetRoleAuditEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamMemberSetRoleAuditEntryData {
  """The role that the user was assigned."""
  role: TeamMemberRole!

  """The user itself."""
  user: User

  """The email address of the user that was added."""
  userEmail: String!

  """The ID of the user that was added."""
  userID: ID!
}

"""Ordering options when fetching teams."""
input TeamOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: TeamOrderField!
}

"""Possible fields to order teams by."""
enum TeamOrderField {
  """The unique slug of the team."""
  TEAM_SLUG
}

input TeamRepositoryFilter {
  """Filter by repository name containing the phrase."""
  name: String
}

type TeamUpdatedAuditEntry implements AuditEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the update."""
  data: TeamUpdatedAuditEntryData

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamUpdatedAuditEntryData {
  """Fields that were updated."""
  updatedFields: [TeamUpdatedAuditEntryDataUpdatedField!]!
}

type TeamUpdatedAuditEntryDataUpdatedField {
  """The name of the field."""
  field: String!

  """The new value of the field."""
  newValue: String

  """The old value of the field."""
  oldValue: String
}

type TeamUtilizationData {
  """The environment for the utilization data."""
  environment: TeamEnvironment!

  """The requested amount of resources"""
  requested: Float!

  """The team."""
  team: Team!

  """The current resource usage."""
  used: Float!
}

type TeamUtilizationEnvironmentDataPoint {
  """The team environment"""
  environment: TeamEnvironment!

  """Value of the used resource at the given timestamp."""
  value: Float!
}

type TeamVulnerabilitySummary {
  """Number of workloads with a software bill of materials (SBOM) attached."""
  bomCount: Int!

  """Coverage of the team."""
  coverage: Float!

  """Number of vulnerabilities with severity CRITICAL."""
  critical: Int!

  """Number of vulnerabilities with severity HIGH."""
  high: Int!

  """Number of vulnerabilities with severity LOW."""
  low: Int!

  """Number of vulnerabilities with severity MEDIUM."""
  medium: Int!

  """Risk score of the team."""
  riskScore: Int!

  """Number of vulnerabilities with severity UNASSIGNED."""
  unassigned: Int!
}

"""
Time is a string in [RFC 3339](https://rfc-editor.org/rfc/rfc3339.html) format, with sub-second precision added if present.
"""
scalar Time

type TokenXAuthIntegration implements AuthIntegration {
  """The name of the integration."""
  name: String!
}

input TriggerJobInput {
  """Name of the environment where the job runs."""
  environmentName: String!

  """Name of the job."""
  name: String!

  """Name of the new run. Must be unique within the team."""
  runName: String!

  """Slug of the team that owns the job."""
  teamSlug: Slug!
}

type TriggerJobPayload {
  """The job that was triggered."""
  job: Job

  """The new job run."""
  jobRun: JobRun
}

input UpdateTeamEnvironmentInput {
  """Name of the environment to update."""
  environmentName: String!

  """
  Slack alerts channel for the environment. Set to an empty string to remove the existing value.
  """
  slackAlertsChannel: String

  """Slug of the team to update."""
  slug: Slug!
}

type UpdateTeamEnvironmentPayload {
  """The updated team environment."""
  environment: TeamEnvironment
}

input UpdateTeamInput {
  """
  An optional new purpose / description of the team.
  
  When omitted the existing value will not be updated.
  """
  purpose: String

  """
  An optional new Slack channel for the team.
  
  When omitted the existing value will not be updated.
  """
  slackChannel: String

  """Slug of the team to update."""
  slug: Slug!
}

type UpdateTeamPayload {
  """The updated team."""
  team: Team
}

"""
The user type represents a user of the NAIS platform and the NAIS GraphQL API.
"""
type User implements Node {
  """The email address of the user."""
  email: String!

  """
  The external ID of the user. This value is managed by the NAIS API user synchronization.
  """
  externalID: String!

  """The globally unique ID of the user."""
  id: ID!

  """The full name of the user."""
  name: String!

  """List of teams the user is connected to."""
  teams(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: UserTeamOrder
  ): TeamMemberConnection!
}

type UserConnection {
  """List of edges."""
  edges: [UserEdge!]!

  """List of nodes."""
  nodes: [User!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type UserEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The user."""
  node: User!
}

"""Ordering options when fetching users."""
input UserOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: UserOrderField!
}

"""Possible fields to order users by."""
enum UserOrderField {
  """The email address of the user."""
  EMAIL

  """The name of user."""
  NAME
}

"""Ordering options when fetching the teams a user is connected to."""
input UserTeamOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: UserTeamOrderField!
}

"""Possible fields to order user teams by."""
enum UserTeamOrderField {
  """The unique slug of the team."""
  TEAM_SLUG
}

"""Resource utilization type."""
type UtilizationDataPoint {
  """Timestamp of the value."""
  timestamp: Time!

  """Value of the used resource at the given timestamp."""
  value: Float!
}

"""Resource type."""
enum UtilizationResourceType {
  CPU
  MEMORY
}

interface Workload {
  """
  BigQuery datasets referenced by the workload. This does not currently support pagination, but will return all available datasets.
  """
  bigQueryDatasets(
    """Ordering options for items returned from the connection."""
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """
  Google Cloud Storage referenced by the workload. This does not currently support pagination, but will return all available buckets.
  """
  buckets(
    """Ordering options for items returned from the connection."""
    orderBy: BucketOrder
  ): BucketConnection!

  """The cost for a workload."""
  cost: WorkloadCost!

  """The environment the workload is deployed in."""
  environment: TeamEnvironment!

  """The globally unique ID of the workload."""
  id: ID!

  """The container image of the workload."""
  image: ContainerImage!

  """
  Kafka topics the workload has access to. This does not currently support pagination, but will return all available Kafka topics.
  """
  kafkaTopicAcls(
    """Ordering options for items returned from the connection."""
    orderBy: KafkaTopicAclOrder
  ): KafkaTopicAclConnection!

  """The workload manifest."""
  manifest: WorkloadManifest!

  """The name of the workload."""
  name: String!

  """Network policies for the workload."""
  networkPolicy: NetworkPolicy!

  """OpenSearch instance referenced by the workload."""
  openSearch: OpenSearch

  """
  Redis instances referenced by the workload. This does not currently support pagination, but will return all available Redis instances.
  """
  redisInstances(
    """Ordering options for items returned from the connection."""
    orderBy: RedisInstanceOrder
  ): RedisInstanceConnection!

  """The resources allocated to the workload."""
  resources: WorkloadResources!

  """
  SQL instances referenced by the workload. This does not currently support pagination, but will return all available SQL instances.
  """
  sqlInstances(
    """Ordering options for items returned from the connection."""
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!

  """Status of the workload"""
  status: WorkloadStatus!

  """The team that owns the workload."""
  team: Team!
}

type WorkloadConnection {
  """List of edges."""
  edges: [WorkloadEdge!]!

  """List of nodes."""
  nodes: [Workload!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type WorkloadCost {
  """Get the cost for a workload within a time period."""
  daily(
    """Start date of the period, inclusive."""
    from: Date!

    """End date of the period, inclusive."""
    to: Date!
  ): WorkloadCostPeriod!

  """The cost for the last 12 months."""
  monthly: WorkloadCostPeriod!
}

type WorkloadCostPeriod {
  """The cost series."""
  series: [ServiceCostSeries!]!

  """The total cost for the period."""
  sum: Float!
}

type WorkloadEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The Workload."""
  node: Workload!
}

type WorkloadLogLine {
  """The name of the instance that generated the log line."""
  instance: String!

  """The log message."""
  message: String!

  """The timestamp of the log line."""
  time: Time!
}

input WorkloadLogSubscriptionFilter {
  """Filter logs to a specific application."""
  application: String

  """Filter logs to a specific environment."""
  environment: String!

  """Filter logs to a set of specific instance names."""
  instances: [String!]

  """Filter logs to a specific job."""
  job: String

  """Filter logs to a specific team."""
  team: Slug!
}

interface WorkloadManifest {
  """The manifest content, serialized as a YAML document."""
  content: String!
}

"""Ordering options when fetching workloads."""
input WorkloadOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: WorkloadOrderField!
}

enum WorkloadOrderField {
  """Order Workloads by the deployment time."""
  DEPLOYMENT_TIME

  """Order Workloads by the name of the environment."""
  ENVIRONMENT

  """Order Workloads by name."""
  NAME

  """Order Workloads by status."""
  STATUS
}

type WorkloadResourceQuantity {
  """The number of CPU cores."""
  cpu: Float!

  """The amount of memory in bytes."""
  memory: Int!
}

interface WorkloadResources {
  """Instances using resources above this threshold will be killed."""
  limits: WorkloadResourceQuantity!

  """Resources requested by the workload."""
  requests: WorkloadResourceQuantity!
}

"""State of the workload"""
enum WorkloadState {
  """Something is failing"""
  FAILING

  """Everything is nais"""
  NAIS

  """Something is not nais"""
  NOT_NAIS

  """Unknown state"""
  UNKNOWN
}

type WorkloadStatus {
  """Errors related to the workload"""
  errors: [WorkloadStatusError!]!

  """State of the workload"""
  state: WorkloadState!
}

"""Error describing usage of a deprecated ingress"""
type WorkloadStatusDeprecatedIngress implements WorkloadStatusError {
  """Deprecated ingress"""
  ingress: String!

  """Error level"""
  level: WorkloadStatusErrorLevel!
}

"""Error describing usage of a deprecated registry"""
type WorkloadStatusDeprecatedRegistry implements WorkloadStatusError {
  """Error level"""
  level: WorkloadStatusErrorLevel!

  """Image name"""
  name: String!

  """Image registry"""
  registry: String!

  """Image repository"""
  repository: String!

  """Image tag"""
  tag: String!
}

"""An error for a workload"""
interface WorkloadStatusError {
  """Error level"""
  level: WorkloadStatusErrorLevel!
}

"""Workload status error level"""
enum WorkloadStatusErrorLevel {
  """ERROR are errors that must be fixed"""
  ERROR

  """TODO are errors that should be fixed when possible"""
  TODO

  """WARNING are errors that should be fixed, but are not critical"""
  WARNING
}

"""Error describing that the workload is failing to run"""
type WorkloadStatusFailedRun implements WorkloadStatusError {
  """Error message"""
  detail: String!

  """Error level"""
  level: WorkloadStatusErrorLevel!

  """Name of the run"""
  name: String!
}

"""An inbound network policies are not met"""
type WorkloadStatusInboundNetwork implements WorkloadStatusError {
  """Error level"""
  level: WorkloadStatusErrorLevel!

  """Network policy"""
  policy: NetworkPolicyRule!
}

"""The last deployed YAML is invalid"""
type WorkloadStatusInvalidNaisYaml implements WorkloadStatusError {
  """Error message"""
  detail: String!

  """Error level"""
  level: WorkloadStatusErrorLevel!
}

"""Error describing that a workload has new instances that are failing"""
type WorkloadStatusNewInstancesFailing implements WorkloadStatusError {
  """Names of the failing instances"""
  failingInstances: [String!]!

  """Error level"""
  level: WorkloadStatusErrorLevel!
}

"""
A workload does not have any active instances, but is requested to have some
"""
type WorkloadStatusNoRunningInstances implements WorkloadStatusError {
  """Error level"""
  level: WorkloadStatusErrorLevel!
}

"""An outbound network policies are not met"""
type WorkloadStatusOutboundNetwork implements WorkloadStatusError {
  """Error level"""
  level: WorkloadStatusErrorLevel!

  """Network policy"""
  policy: NetworkPolicyRule!
}

"""Error describing that the workload is failing to synchronize"""
type WorkloadStatusSynchronizationFailing implements WorkloadStatusError {
  """Error message"""
  detail: String!

  """Error level"""
  level: WorkloadStatusErrorLevel!
}

type WorkloadUtilization {
  """Get the current usage for the requested resource type."""
  current(resourceType: UtilizationResourceType!): Float!

  """
  Gets the requested amount of resources for the requested resource type.
  """
  requested(resourceType: UtilizationResourceType!): Float!

  """Usage between start and end with step size for given resource type."""
  series(input: WorkloadUtilizationSeriesInput!): [UtilizationDataPoint!]!
}

type WorkloadUtilizationData {
  """The requested amount of resources"""
  requested: Float!

  """The current resource usage."""
  used: Float!

  """The workload."""
  workload: Workload!
}

input WorkloadUtilizationSeriesInput {
  """Fetch resource usage until this timestamp."""
  end: Time!

  """Resource type."""
  resourceType: UtilizationResourceType!

  """Fetch resource usage from this timestamp."""
  start: Time!
}
