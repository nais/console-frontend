"""
Require an authenticated user with the admin role for all requests with this directive.
"""
directive @admin on FIELD_DEFINITION

"""Require an authenticated user for all requests with this directive."""
directive @auth on FIELD_DEFINITION

"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

type AccessPolicy {
  inbound: Inbound!
  outbound: Outbound!
}

type App implements Workload {
  accessPolicy: AccessPolicy!
  authz: [Authz!]!
  autoScaling: AutoScaling!
  deployInfo: DeployInfo!
  env: Env!
  id: ID!
  image: String!
  ingresses: [String!]!
  instances: [Instance!]!
  manifest: String!
  name: String!
  persistence: [Persistence!]!
  resources: Resources!
  secrets: [Secret!]!
  status: WorkloadStatus!
  team: Team!
  variables: [Variable!]!
  vulnerabilities: Vulnerability
}

"""App cost type."""
type AppCost {
  """The name of the application."""
  app: String!

  """A list of cost entries for the application."""
  cost: [CostEntry!]!

  """The sum of all cost entries for the application in euros."""
  sum: Float!
}

type AppList {
  nodes: [App!]!
  pageInfo: PageInfo!
}

"""Resource utilization overage cost for an app."""
type AppWithResourceUtilizationOverage {
  """The name of the app."""
  app: String!

  """The environment where the app is running."""
  env: String!

  """Estimated annual cost of the request overage."""
  estimatedAnnualOverageCost: Float!

  """The overage for the app."""
  overage: Float!

  """The overage cost for the app."""
  overageCost: Float!

  """The name of the team who owns the app."""
  team: Slug!

  """The utilization in percent."""
  utilization: Float!
}

"""Team status for apps."""
type AppsStatus {
  failing: Int!
  total: Int!
}

"""Audit log type."""
type AuditLog {
  """String representation of the action performed."""
  action: String!

  """
  The identity of the actor who performed the action. When this field is empty it means that some backend process performed the action. The value, when present, is either the name of a service account, or the email address of a user.
  """
  actor: String

  """The related correlation ID."""
  correlationID: String!

  """Creation time of the log entry."""
  createdAt: Time!

  """ID of the log entry."""
  id: ID!

  """Log entry message."""
  message: String!

  """The identifier of the target."""
  targetIdentifier: String!

  """The type of the audit log target."""
  targetType: String!
}

type AuditLogList {
  nodes: [AuditLog!]!
  pageInfo: PageInfo!
}

"""Authenticated user type. Can be a user or a service account."""
union AuthenticatedUser = ServiceAccount | User

union Authz = AzureAD | IDPorten | Maskinporten | TokenX

type AutoScaling {
  """CPU threshold in percent"""
  cpuThreshold: Int!
  disabled: Boolean!
  max: Int!
  min: Int!
}

type AzureAD {
  application: AzureApplication
  sidecar: Sidecar
}

type AzureApplication {
  allowAllUsers: Boolean!
  claims: Claims!
  replyURLs: [String!]!
  singlePageApplication: Boolean!
  tenant: String!
}

type BackupConfiguration {
  enabled: Boolean!
  pointInTimeRecovery: Boolean!
  retainedBackups: Int!
  startTime: String!
  transactionLogRetentionDays: Int!
}

type BigQueryDataset implements Persistence {
  access: [BigQueryDatasetAccess!]!
  cascadingDelete: Boolean!
  description: String!
  env: Env!
  id: ID!
  name: String!
  status: BigQueryDatasetStatus!
  team: Team!
  workload: Workload
}

type BigQueryDatasetAccess {
  email: String!
  role: String!
}

type BigQueryDatasetList {
  nodes: [BigQueryDataset!]!
  pageInfo: PageInfo!
}

type BigQueryDatasetStatus {
  conditions: [Condition!]!
  creationTime: Time
  lastModifiedTime: Time
}

type Bucket implements Persistence {
  cascadingDelete: Boolean!
  cors: [BucketCors!]
  env: Env!
  id: ID!
  name: String!
  projectId: String!
  publicAccessPrevention: String!
  retentionPeriodDays: Int!
  status: BucketStatus!
  team: Team!
  uniformBucketLevelAccess: Boolean!
  workload: Workload
}

type BucketCors {
  maxAgeSeconds: Int
  methods: [String!]!
  origins: [String!]!
  responseHeaders: [String!]!
}

type BucketStatus {
  conditions: [Condition!]!
  selfLink: String!
}

type BucketsList {
  nodes: [Bucket!]!
  pageInfo: PageInfo!
}

type Claims {
  extra: [String!]!
  groups: [Group!]!
}

type Condition {
  lastTransitionTime: Time!
  message: String!
  reason: String!
  status: String!
  type: String!
}

type Consume {
  name: String!
}

type Consumer {
  name: String!
  orgno: String!
}

"""Cost entry type."""
type CostEntry {
  """The cost in euros."""
  cost: Float!

  """The date for the entry."""
  date: Date!
}

"""Cost series type."""
type CostSeries {
  """The type of cost."""
  costType: String!

  """The cost data."""
  data: [CostEntry!]!

  """The sum of all daily costs in the series for this cost type in euros."""
  sum: Float!
}

"""Input for creating a new team."""
input CreateTeamInput {
  """Team purpose."""
  purpose: String!

  """Specify the Slack channel for the team."""
  slackChannel: String!

  """Team slug. After creation, this value can not be changed."""
  slug: Slug!
}

"""Current resource utilization type."""
type CurrentResourceUtilization {
  """The CPU utilization."""
  cpu: ResourceUtilization!

  """The memory utilization."""
  memory: ResourceUtilization!

  """The timestamp used for the calculated values."""
  timestamp: Time!
}

"""Daily cost type."""
type DailyCost {
  """The cost series."""
  series: [CostSeries!]!

  """The sum of all costs in the cost series in euros."""
  sum: Float!
}

"""Date type in YYYY-MM-DD format."""
scalar Date

type DeleteAppResult {
  """Whether the app was deleted or not."""
  deleted: Boolean!
  error: String
}

type DeleteJobResult {
  """Whether the job was deleted or not."""
  deleted: Boolean!
  error: String
}

type DeployInfo {
  commitSha: String!
  deployer: String!
  history(limit: Int, offset: Int): DeploymentResponse!
  timestamp: Time
  url: String!
}

type Deployment {
  created: Time!
  env: String!
  id: ID!
  repository: String!
  resources: [DeploymentResource!]!
  statuses: [DeploymentStatus!]!
  team: Team!
}

"""Deployment key type."""
type DeploymentKey {
  """The date the deployment key was created."""
  created: Time!

  """The date the deployment key expires."""
  expires: Time!

  """The unique identifier of the deployment key."""
  id: ID!

  """The actual key."""
  key: String!
}

type DeploymentList {
  nodes: [Deployment!]!
  pageInfo: PageInfo!
}

type DeploymentResource {
  group: String!
  id: ID!
  kind: String!
  name: String!
  namespace: String!
  version: String!
}

union DeploymentResponse = DeploymentList | Error

type DeploymentStatus {
  created: Time!
  id: ID!
  message: String
  status: String!
}

type DeprecatedIngressError implements StateError {
  ingress: String!
  level: ErrorLevel!
  revision: String!
}

type DeprecatedRegistryError implements StateError {
  level: ErrorLevel!
  name: String!
  registry: String!
  repository: String!
  revision: String!
  tag: String!
}

type Env {
  gcpProjectID: String
  id: ID!
  name: String!
  secrets: [Secret!]!
  slackAlertsChannel: String!
}

"""Env cost type."""
type EnvCost {
  """A list of app costs in the environment."""
  apps: [AppCost!]!

  """The name of the environment."""
  env: String!

  """The sum of all app costs for the environment in euros."""
  sum: Float!
}

"""Env cost filter input type."""
input EnvCostFilter {
  """Start date for the cost series, inclusive."""
  from: Date!

  """The name of the team to get costs for."""
  team: Slug!

  """End date for cost series, inclusive."""
  to: Date!
}

type Error {
  message: String!
}

enum ErrorLevel {
  ERROR
  TODO
  WARNING
}

type Expose {
  allowedIntegrations: [String!]!
  atMaxAge: Int!
  consumers: [Consumer!]!
  enabled: Boolean!
  name: String!
  product: String!
}

type External {
  host: String!
  ports: [Port!]!
}

type FailedRunError implements StateError {
  level: ErrorLevel!
  revision: String!
  runMessage: String!
  runName: String!
}

type Flag {
  name: String!
  value: String!
}

"""GCP project type."""
type GcpProject {
  """The environment for the project."""
  environment: String!

  """The GCP project ID."""
  projectId: String!

  """The display name of the project."""
  projectName: String!
}

"""Input for filtering GitHub repositories."""
input GitHubRepositoriesFilter {
  """Whether or not to include archived repositories. Defaults to false."""
  includeArchivedRepositories: Boolean
}

"""GitHub repository type."""
type GitHubRepository {
  """Whether or not the repository is archived."""
  archived: Boolean!

  """A list of authorizations granted to the repository by the team."""
  authorizations: [RepositoryAuthorization!]!

  """ID of the repository."""
  id: ID!

  """Name of the repository, with the org prefix."""
  name: String!

  """A list of permissions given to the team for this repository."""
  permissions: [GitHubRepositoryPermission!]!

  """The name of the role the team has been granted in the repository."""
  roleName: String!
}

"""Paginated GitHub repository type."""
type GitHubRepositoryList {
  """The list of GitHub repositories."""
  nodes: [GitHubRepository!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""GitHub repository permission type."""
type GitHubRepositoryPermission {
  """Whether or not the permission is granted for the repository."""
  granted: Boolean!

  """Name of the permission."""
  name: String!
}

type Group {
  id: String!
}

type IDPorten {
  accessTokenLifetime: Int
  clientURI: String
  frontchannelLogoutPath: String
  integrationType: String
  postLogoutRedirectURIs: [String]
  redirectPath: String
  scopes: [String]
  sessionLifetime: Int
  sidecar: IDPortenSidecar
}

type IDPortenSidecar {
  autoLogin: Boolean
  autoLoginIgnorePaths: [String]
  enabled: Boolean
  level: String
  locale: String
  resources: Resources
}

type Inbound {
  rules: [Rule!]!
}

type InboundAccessError implements StateError {
  level: ErrorLevel!
  revision: String!
  rule: Rule!
}

type Insights {
  enabled: Boolean!
  queryStringLength: Int!
  recordApplicationTags: Boolean!
  recordClientAddress: Boolean!
}

type Instance {
  created: Time!
  id: ID!
  image: String!
  message: String!
  name: String!
  restarts: Int!
  state: InstanceState!
}

enum InstanceState {
  FAILING
  RUNNING
  UNKNOWN
}

type InvalidNaisYamlError implements StateError {
  detail: String!
  level: ErrorLevel!
  revision: String!
}

"""Team status for jobs."""
type JobsStatus {
  failing: Int!
  total: Int!
}

type KafkaTopic implements Persistence {
  acl: [KafkaTopicAcl!]!
  config: KafkaTopicConfig
  env: Env!
  id: ID!
  name: String!
  pool: String!
  status: KafkaTopicStatus
  team: Team!
  workload: Workload
}

type KafkaTopicAcl {
  access: String!
  application: String!
  team: Slug!
}

type KafkaTopicConfig {
  cleanupPolicy: String
  maxMessageBytes: Int
  minimumInSyncReplicas: Int
  partitions: Int
  replication: Int
  retentionBytes: Int
  retentionHours: Int
  segmentHours: Int
}

type KafkaTopicList {
  nodes: [KafkaTopic!]!
  pageInfo: PageInfo!
}

type KafkaTopicStatus {
  credentialsExpiryTime: Time
  errors: [String!]
  fullyQualifiedName: String!
  latestAivenSyncFailure: Time
  message: String!
  synchronizationState: State!
  synchronizationTime: Time
}

type Limits {
  cpu: String!
  memory: String!
}

type LogLine {
  instance: String!
  message: String!
  time: Time!
}

input LogSubscriptionInput {
  app: String
  env: String!
  instances: [String!]
  job: String
  team: Slug!
}

type MaintenanceWindow {
  day: Int!
  hour: Int!
}

type Maskinporten {
  enabled: Boolean!
  scopes: MaskinportenScope!
}

type MaskinportenScope {
  consumes: [Consume!]!
  exposes: [Expose!]!
}

"""Monthly cost type."""
type MonthlyCost {
  """A list of monthly cost entries."""
  cost: [CostEntry!]!

  """Sum for all months in the series in euros."""
  sum: Float!
}

"""Monthly cost filter input type."""
input MonthlyCostFilter {
  """The name of the application to get costs for."""
  app: String!

  """The name of the environment to get costs for."""
  env: String!

  """The name of the team to get costs for."""
  team: Slug!
}

"""The root query for implementing GraphQL mutations."""
type Mutation {
  """
  Add opt-out of a reconciler for a team member. Only reconcilers that are member aware can be opted out from.
  """
  addReconcilerOptOut(
    """The name of the reconciler to opt the team member out of."""
    reconciler: String!

    """The team slug."""
    teamSlug: Slug!

    """The user ID of the team member."""
    userId: ID!
  ): TeamMember!

  """
  Add a user to a team
  
  If the user is already a member or an owner of the team, the mutation will fail.
  
  The updated team will be returned on success.
  """
  addTeamMember(
    """The new team member."""
    member: TeamMemberInput!

    """Slug of the team that should receive a new member."""
    slug: Slug!
  ): Team!

  """
  Add users to a team as regular team members
  
  If one or more users are already added to the team they will not be updated. If a user is already an owner of the
  team the user will not lose ownership. Regular team members will get read-only access to the team.
  
  The updated team will be returned on success.
  """
  addTeamMembers(
    """Slug of the team that should receive new members."""
    slug: Slug!

    """List of user IDs that should be added to the team as members."""
    userIds: [ID!]!
  ): Team!

  """
  Add users to a team as team owners
  
  If one or more users are already added to the team, they will be granted ownership of the team. If one or more users
  are already owners of the team, they will not be updated. Team owners will get read/write access to the team.
  
  The updated team will be returned on success.
  """
  addTeamOwners(
    """Slug of the team that should receive new owners."""
    slug: Slug!

    """List of user IDs that should be added to the team as owners."""
    userIds: [ID!]!
  ): Team!

  """Authorize a team to perform an action from a GitHub repository."""
  authorizeRepository(
    """The action to authorize."""
    authorization: RepositoryAuthorization!

    """Name of the repository, with the org prefix, for instance 'org/repo'."""
    repoName: String!

    """The slug of the team to authorize the action for."""
    teamSlug: Slug!
  ): GitHubRepository!

  """Update the deploy key of a team. Returns the updated deploy key."""
  changeDeployKey(
    """The name of the team to update the deploy key for."""
    team: Slug!
  ): DeploymentKey!

  """Configure a reconciler."""
  configureReconciler(
    """List of reconciler config inputs."""
    config: [ReconcilerConfigInput!]!

    """The name of the reconciler to configure."""
    name: String!
  ): Reconciler!

  """
  Confirm a team deletion
  
  This will start the actual team deletion process, which will be done in an asynchronous manner. All external
  entities controlled by NAIS will also be deleted.
  
  WARNING: There is no going back after starting this process.
  
  Note: Service accounts are not allowed to confirm a team deletion.
  """
  confirmTeamDeletion(
    """Deletion key, acquired using the requestTeamDeletion mutation."""
    key: String!
  ): Boolean!

  """Create a new secret for a team and env."""
  createSecret(
    """The secret data."""
    data: [VariableInput!]!

    """The environment the secret is deployed to."""
    env: String!

    """The name of the secret."""
    name: String!

    """The name of the team who owns the secret."""
    team: Slug!
  ): Secret!

  """
  Create a new team
  
  The user creating the team will be granted team ownership, unless the user is a service account, in which case the
  team will not get an initial owner. To add one or more owners to the team, refer to the `addTeamOwners` mutation.
  
  The new team will be returned on success.
  """
  createTeam(
    """Input for creation of the new team."""
    input: CreateTeamInput!
  ): Team!

  """
  Create a new Unleash instance.
  
  This mutation will create a new Unleash instance for the given team. The team
  will be set as owner of the Unleash instance and will be able to manage it.
  """
  createUnleashForTeam(team: Slug!): Unleash!

  """Deauthorize an action from a team."""
  deauthorizeRepository(
    """The action to deauthorize."""
    authorization: RepositoryAuthorization!

    """Name of the repository, with the org prefix, for instance 'org/repo'."""
    repoName: String!

    """The slug of the team to deauthorize the action for."""
    teamSlug: Slug!
  ): GitHubRepository!
  deleteApp(
    """The environment the application is deployed to."""
    env: String!

    """The name of the application."""
    name: String!

    """The name of the team who owns the application."""
    team: Slug!
  ): DeleteAppResult!
  deleteJob(
    """The environment the naisjob is deployed to."""
    env: String!

    """The name of the naisjob."""
    name: String!

    """The name of the team who owns the naisjob."""
    team: Slug!
  ): DeleteJobResult!

  """Delete an existing secret for a team and env."""
  deleteSecret(
    """The environment the secret is deployed to."""
    env: String!

    """The name of the secret."""
    name: String!

    """The name of the team who owns the secret."""
    team: Slug!
  ): Boolean!

  """
  Disable a reconciler
  
  The reconciler configuration will be left intact.
  """
  disableReconciler(
    """The name of the reconciler to disable."""
    name: String!
  ): Reconciler!

  """
  Enable a reconciler
  
  A reconciler must be fully configured before it can be enabled.
  """
  enableReconciler(
    """The name of the reconciler to enable."""
    name: String!
  ): Reconciler!

  """Remove opt-out of a reconciler for a team member."""
  removeReconcilerOptOut(
    """The name of the reconciler to clear the opt-out from."""
    reconciler: String!

    """The team slug."""
    teamSlug: Slug!

    """The user ID of the team member."""
    userId: ID!
  ): TeamMember!

  """
  Remove a user from a team
  
  The updated team will be returned on success.
  """
  removeUserFromTeam(
    """Team slug that the user should be removed from."""
    slug: Slug!

    """ID of the user that will be removed from the team."""
    userId: ID!
  ): Team!

  """
  Remove one or more users from a team
  
  The updated team will be returned on success.
  """
  removeUsersFromTeam(
    """Team slug that users should be removed from."""
    slug: Slug!

    """List of user IDs that should be removed from the team."""
    userIds: [ID!]!
  ): Team!

  """
  Request a key that can be used to trigger a team deletion process
  
  Deleting a team is a two step process. First an owner of the team (or an admin) must request a team deletion key, and
  then a second owner of the team (or an admin) must confirm the deletion using the confirmTeamDeletion mutation.
  
  Note: Service accounts are not allowed to request team delete keys.
  """
  requestTeamDeletion(
    """The slug of the team that the deletion key will be assigned to."""
    slug: Slug!
  ): TeamDeleteKey!

  """
  Reset all reconciler configuration options to their initial state and disable the reconciler if it is currently enabled.
  """
  resetReconciler(
    """The name of the reconciler to reset."""
    name: String!
  ): Reconciler!
  restartApp(
    """The environment the application is deployed to."""
    env: String!

    """The name of the application."""
    name: String!

    """The name of the team who owns the application."""
    team: Slug!
  ): RestartAppResult!

  """
  Set the member role of a user in a team
  
  The user must already exist in the team for this mutation to succeed.
  
  The team will be returned on success.
  """
  setTeamMemberRole(
    """The team role to set."""
    role: TeamRole!

    """The slug of the team."""
    slug: Slug!

    """The ID of the user."""
    userId: ID!
  ): Team!

  """
  Manually synchronize all teams
  
  This action will trigger a full synchronization of all teams against the configured third party systems. The action
  is asynchronous. The operation can take a while, depending on the amount of teams currently managed.
  """
  synchronizeAllTeams: TeamSync!

  """
  Manually synchronize a team
  
  This action will trigger a full synchronization of the team against the configured third party systems. The action
  is asynchronous.
  
  The team will be returned.
  """
  synchronizeTeam(
    """The slug of the team to synchronize."""
    slug: Slug!
  ): TeamSync!

  """
  Trigger a user synchronization
  
  This mutation will trigger a full user synchronization with the connected Google Workspace, and return a correlation
  ID that can later be matched to the log entries. The user synchronization itself is asynchronous.
  """
  synchronizeUsers: String!

  """Update an existing secret for a team and env."""
  updateSecret(
    """The secret data."""
    data: [VariableInput!]!

    """The environment the secret is deployed to."""
    env: String!

    """The name of the secret."""
    name: String!

    """The name of the team who owns the secret."""
    team: Slug!
  ): Secret!

  """
  Update an existing team
  
  This mutation can be used to update the team purpose. It is not possible to update the team slug.
  
  The updated team will be returned on success.
  """
  updateTeam(
    """Input for updating the team."""
    input: UpdateTeamInput!

    """Slug of the team to update."""
    slug: Slug!
  ): Team!
}

type NaisJob implements Workload {
  accessPolicy: AccessPolicy!
  authz: [Authz!]!
  completions: Int!
  deployInfo: DeployInfo!
  env: Env!
  id: ID!
  image: String!
  manifest: String!
  name: String!
  parallelism: Int!
  persistence: [Persistence!]!
  resources: Resources!
  retries: Int!
  runs: [Run!]!
  schedule: String!
  secrets: [Secret!]!
  status: WorkloadStatus!
  team: Team!
  variables: [Variable!]!
}

type NaisJobList {
  nodes: [NaisJob!]!
  pageInfo: PageInfo!
}

"""NAIS namespace type."""
type NaisNamespace {
  """The environment for the namespace."""
  environment: String!

  """The namespace."""
  namespace: Slug!
}

type NewInstancesFailingError implements StateError {
  failingInstances: [String!]!
  level: ErrorLevel!
  revision: String!
}

type NoRunningInstancesError implements StateError {
  level: ErrorLevel!
  revision: String!
}

type OpenSearch implements Persistence {
  access: [OpenSearchInstanceAccess!]!
  cost: String!
  env: Env!
  id: ID!

  """The opensearch instance name"""
  name: String!
  status: OpenSearchStatus!
  team: Team!
  workload: Workload
}

type OpenSearchInstanceAccess {
  role: String!
  workload: Workload!
}

type OpenSearchList {
  nodes: [OpenSearch!]!
  pageInfo: PageInfo!
}

type OpenSearchStatus {
  conditions: [Condition!]!
  state: String!
}

input OrderBy {
  """Order direction."""
  direction: SortOrder!

  """The field to order by."""
  field: OrderByField!
}

enum OrderByField {
  """Order by appName."""
  APP_NAME

  """Order by cost"""
  COST

  """Order by CPU utilization"""
  CPU

  """Order by deployed time"""
  DEPLOYED

  """Order by disk utilization"""
  DISK

  """Order by env"""
  ENV

  """Order by env."""
  ENV_NAME

  """Order by memory utilization"""
  MEMORY

  """Order by name"""
  NAME

  """Order by risk score"""
  RISK_SCORE

  """Order apps by vulnerability severity critical"""
  SEVERITY_CRITICAL

  """Order apps by vulnerability severity high"""
  SEVERITY_HIGH

  """Order apps by vulnerability severity low"""
  SEVERITY_LOW

  """Order apps by vulnerability severity medium"""
  SEVERITY_MEDIUM

  """Order apps by vulnerability severity unassigned"""
  SEVERITY_UNASSIGNED

  """Order by status"""
  STATUS

  """Order by PostgreSQL version"""
  VERSION
}

type Outbound {
  external: [External!]!
  rules: [Rule!]!
}

type OutboundAccessError implements StateError {
  level: ErrorLevel!
  revision: String!
  rule: Rule!
}

"""Pagination information."""
type PageInfo {
  """Whether or not there exists a next page in the data set."""
  hasNextPage: Boolean!

  """Whether or not there exists a previous page in the data set."""
  hasPreviousPage: Boolean!

  """The total amount if items accessible."""
  totalCount: Int!
}

interface Persistence {
  id: ID!
  name: String!
}

type Port {
  port: Int!
}

"""The query root for the NAIS GraphQL API."""
type Query {
  """Get an app by name, team and env."""
  app(
    """The environment the application is deployed to."""
    env: String!

    """The name of the application."""
    name: String!

    """The name of the team who owns the application."""
    team: Slug!
  ): App!

  """Get the current resource utilization values for a specific app."""
  currentResourceUtilizationForApp(
    """The name of the app."""
    app: String!

    """The environment where the app is running."""
    env: String!

    """The name of the team."""
    team: Slug!
  ): CurrentResourceUtilization!

  """
  Get the current resource utilization for a team across all apps and environments.
  """
  currentResourceUtilizationForTeam(
    """The name of the team."""
    team: Slug!
  ): CurrentResourceUtilization!

  """Get the daily cost for a team application in a specific environment."""
  dailyCostForApp(
    """The name of the application to get costs for."""
    app: String!

    """The environment that the application runs in."""
    env: String!

    """Start date for the cost series, inclusive."""
    from: Date!

    """The name of the team that owns the application."""
    team: Slug!

    """End date for cost series, inclusive."""
    to: Date!
  ): DailyCost!

  """Get the daily cost for a team across all apps and environments."""
  dailyCostForTeam(
    """Start date for the cost series, inclusive."""
    from: Date!

    """The name of the team that owns the application."""
    team: Slug!

    """End date for cost series, inclusive."""
    to: Date!
  ): DailyCost!

  """Get a list of deployments."""
  deployments(limit: Int, offset: Int): DeploymentList!

  """Get env cost for a team."""
  envCost(filter: EnvCostFilter!): [EnvCost!]!

  """The currently authenticated user."""
  me: AuthenticatedUser!

  """Get monthly costs."""
  monthlyCost(filter: MonthlyCostFilter!): MonthlyCost!

  """Get a naisjob by name, team and env."""
  naisjob(
    """The environment the naisjob is deployed in."""
    env: String!

    """The name of the naisjob."""
    name: String!

    """The name of the team who owns the naisjob."""
    team: Slug!
  ): NaisJob!

  """Get a collection of reconcilers."""
  reconcilers(limit: Int, offset: Int): ReconcilerList!

  """Get the date range for resource utilization for an app."""
  resourceUtilizationDateRangeForApp(
    """The name of the app."""
    app: String!

    """The environment where the app is running."""
    env: String!

    """The name of the team."""
    team: Slug!
  ): ResourceUtilizationDateRange!

  """
  Get the date range for resource utilization for a team across all environments.
  """
  resourceUtilizationDateRangeForTeam(
    """The name of the team."""
    team: Slug!
  ): ResourceUtilizationDateRange!

  """Get the resource utilization for an app."""
  resourceUtilizationForApp(
    """The name of the app."""
    app: String!

    """The environment where the app is running."""
    env: String!

    """
    Fetch resource utilization from this date. Defaults to 7 days before the to date.
    """
    from: Date

    """The name of the team."""
    team: Slug!

    """Fetch resource utilization until this date. Defaults to today."""
    to: Date
  ): ResourceUtilizationForApp!

  """Get the resource utilization for a team across all environments."""
  resourceUtilizationForTeam(
    """
    Fetch resource utilization from this date. Defaults to 7 days before the to date.
    """
    from: Date

    """The team to fetch data for."""
    team: Slug!

    """Fetch resource utilization until this date. Defaults to today."""
    to: Date
  ): [ResourceUtilizationForEnv!]!

  """Get resource utilization overage data for a team."""
  resourceUtilizationOverageForTeam(
    """The name of the team."""
    team: Slug!
  ): ResourceUtilizationOverageForTeam!

  """Get the resource utilization trend for a team."""
  resourceUtilizationTrendForTeam(
    """The name of the team."""
    team: Slug!
  ): ResourceUtilizationTrend!
  search(filter: SearchFilter, limit: Int, offset: Int, query: String!): SearchList!

  """Get a specific team."""
  team(
    """Slug of the team."""
    slug: Slug!
  ): Team!

  """Get a team delete key."""
  teamDeleteKey(
    """The key to get."""
    key: String!
  ): TeamDeleteKey!

  """Get a collection of teams. Default limit is 20"""
  teams(
    """Filter teams."""
    filter: TeamsFilter

    """Limit the number of teams to return. Default is 20."""
    limit: Int

    """Offset to start listing teams from. Default is 0."""
    offset: Int
  ): TeamList!

  """Get a specific user."""
  user(
    email: String

    """ID of the user."""
    id: ID
  ): User!

  """Get user sync status and logs."""
  userSync: [UserSyncRun!]!

  """Get a collection of users, sorted by name."""
  users(limit: Int, offset: Int): UserList!
}

"""Reconciler type."""
type Reconciler {
  """Audit logs for this reconciler."""
  auditLogs(limit: Int, offset: Int): AuditLogList!

  """Reconciler configuration keys and descriptions."""
  config: [ReconcilerConfig!]!

  """
  Whether or not the reconciler is fully configured and ready to be enabled.
  """
  configured: Boolean!

  """Description of what the reconciler is responsible for."""
  description: String!

  """The human-friendly name of the reconciler."""
  displayName: String!

  """Whether or not the reconciler is enabled."""
  enabled: Boolean!

  """Whether or not the reconciler uses team memberships when syncing."""
  memberAware: Boolean!

  """The name of the reconciler."""
  name: String!
}

"""Reconciler configuration type."""
type ReconcilerConfig {
  """Whether or not the configuration key has a value."""
  configured: Boolean!

  """Configuration description."""
  description: String!

  """The human-friendly name of the configuration key."""
  displayName: String!

  """Configuration key."""
  key: String!

  """
  Whether or not the configuration value is considered a secret. Secret values will not be exposed through the API.
  """
  secret: Boolean!

  """
  Configuration value. This will be set to null if the value is considered a secret.
  """
  value: String
}

"""Reconciler configuration input."""
input ReconcilerConfigInput {
  """Configuration key."""
  key: String!

  """Configuration value."""
  value: String!
}

"""Paginated reconcilers type."""
type ReconcilerList {
  """The list of reconcilers."""
  nodes: [Reconciler!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type Redis implements Persistence {
  access: [RedisInstanceAccess!]!
  cost: String!
  env: Env!
  id: ID!
  name: String!
  status: RedisStatus!
  team: Team!
  workload: Workload
}

type RedisInstanceAccess {
  role: String!
  workload: Workload!
}

type RedisList {
  nodes: [Redis!]!
  pageInfo: PageInfo!
}

type RedisStatus {
  conditions: [Condition!]!
  state: String!
}

"""Repository authorizations."""
enum RepositoryAuthorization {
  """Authorize for NAIS deployment."""
  DEPLOY
}

type Requests {
  cpu: String!
  memory: String!
}

"""Resource type."""
enum ResourceType {
  CPU
  MEMORY
}

"""Resource utilization type."""
type ResourceUtilization {
  """Estimated annual cost of the request overage."""
  estimatedAnnualOverageCost: Float!

  """The requested resource amount per pod."""
  request: Float!

  """The cost associated with the requested resource amount."""
  requestCost: Float!

  """The overage of the requested resource amount."""
  requestCostOverage: Float!

  """Timestamp of the value."""
  timestamp: Time!

  """The actual resource usage."""
  usage: Float!

  """The cost associated with the actual resource usage."""
  usageCost: Float!

  """The utilization in percent."""
  utilization: Float!
}

"""Date range type."""
type ResourceUtilizationDateRange {
  """The start of the range."""
  from: Date

  """The end of the range."""
  to: Date
}

"""Resource utilization for app type."""
type ResourceUtilizationForApp {
  """CPU resource utilization data for the environment."""
  cpu: [ResourceUtilization!]!

  """Memory resource utilization data for the environment."""
  memory: [ResourceUtilization!]!
}

"""Resource utilization for env type."""
type ResourceUtilizationForEnv {
  """CPU resource utilization data for the environment."""
  cpu: [ResourceUtilization!]!

  """Name of the environment."""
  env: String!

  """Memory resource utilization data for the environment."""
  memory: [ResourceUtilization!]!
}

"""Resource utilization overage cost for team type."""
type ResourceUtilizationOverageForTeam {
  """List of CPU overage data for all apps."""
  cpu: [AppWithResourceUtilizationOverage!]!

  """List of memory overage data for all apps."""
  memory: [AppWithResourceUtilizationOverage!]!

  """The sum of the overage cost for all apps."""
  overageCost: Float!

  """Timestamp used for the calculated values."""
  timestamp: Time!
}

"""Resource utilization trend type."""
type ResourceUtilizationTrend {
  """The average CPU utilization from the previous week."""
  averageCpuUtilization: Float!

  """The average memory utilization from the previous week."""
  averageMemoryUtilization: Float!

  """The CPU utilization trend in percentage."""
  cpuUtilizationTrend: Float!

  """The current CPU utilization."""
  currentCpuUtilization: Float!

  """The current memory utilization."""
  currentMemoryUtilization: Float!

  """The memory utilization trend in percentage."""
  memoryUtilizationTrend: Float!
}

type Resources {
  limits: Limits!
  requests: Requests!
}

type RestartAppResult {
  error: String
}

"""Role binding type."""
type Role {
  """Whether or not the role is global."""
  isGlobal: Boolean!

  """Name of the role."""
  name: String!

  """
  Optional service account if the role binding targets a service account.
  """
  targetServiceAccount: ServiceAccount

  """Optional team if the role binding targets a team."""
  targetTeam: Team
}

type Rule {
  application: String!
  cluster: String!
  isJob: Boolean!
  mutual: Boolean!
  mutualExplanation: String!
  namespace: String!
}

type Run {
  completionTime: Time
  duration: String!
  failed: Boolean!
  id: ID!
  image: String!
  message: String!
  name: String!
  podNames: [String!]!
  startTime: Time
}

input SearchFilter {
  type: SearchType
}

type SearchList {
  nodes: [SearchNode!]!
  pageInfo: PageInfo!
}

union SearchNode = App | NaisJob | SqlInstance | Team

enum SearchType {
  APP
  NAISJOB
  SQLINSTANCE
  TEAM
}

type Secret {
  apps: [App!]!
  data: [Variable!]!
  env: Env!
  id: ID!
  jobs: [NaisJob!]!
  lastModifiedAt: Time
  lastModifiedBy: User
  name: String!
  team: Team!
}

"""Service account type."""
type ServiceAccount {
  """Unique ID of the service account."""
  id: ID!

  """The name of the service account."""
  name: String!

  """Roles attached to the service account."""
  roles: [Role!]!
}

type Sidecar {
  autoLogin: Boolean!
  autoLoginIgnorePaths: [String!]!
  resources: Resources!
}

"""Slack alerts channel type."""
type SlackAlertsChannel {
  """The name of the Slack channel."""
  channelName: String!

  """The environment for the alerts sent to the channel."""
  environment: String!
}

"""Slack alerts channel input."""
input SlackAlertsChannelInput {
  """The name of the Slack channel."""
  channelName: String

  """The environment for the alerts sent to the channel."""
  environment: String!
}

"""
The slug must:

- contain only lowercase alphanumeric characters or hyphens
- contain at least 3 characters and at most 30 characters
- start with an alphabetic character
- end with an alphanumeric character
- not contain two hyphens in a row

Examples of valid slugs:

- `some-value`
- `someothervalue`
- `my-team-123`
"""
scalar Slug

enum SortOrder {
  """Ascending sort order."""
  ASC

  """Descending sort order."""
  DESC
}

type SqlDatabase implements Persistence {
  charset: String!
  collation: String!
  conditions: [Condition!]!
  deletionPolicy: String!
  healthy: Boolean!
  id: ID!
  name: String!
}

type SqlInstance implements Persistence {
  backupConfiguration: BackupConfiguration!
  cascadingDelete: Boolean!
  connectionName: String!
  database: SqlDatabase
  diskAutoresize: Boolean!
  diskAutoresizeLimit: Int!
  env: Env!
  flags: [Flag!]!
  highAvailability: Boolean!
  id: ID!
  isHealthy: Boolean!
  maintenanceVersion: String
  maintenanceWindow: MaintenanceWindow
  metrics: SqlInstanceMetrics!
  name: String!
  projectId: String!
  state: SqlInstanceState!
  status: SqlInstanceStatus!
  team: Team!
  tier: String!
  type: String!
  users: [SqlUser!]!
  workload: Workload
}

type SqlInstanceCpu {
  cores: Float!
  utilization: Float!
}

type SqlInstanceDisk {
  quotaBytes: Int!
  utilization: Float!
}

type SqlInstanceMemory {
  quotaBytes: Int!
  utilization: Float!
}

type SqlInstanceMetrics {
  cost: Float!
  cpu: SqlInstanceCpu!
  disk: SqlInstanceDisk!
  memory: SqlInstanceMemory!
}

enum SqlInstanceState {
  FAILED
  MAINTENANCE
  PENDING_CREATE
  PENDING_DELETE
  RUNNABLE
  SQL_INSTANCE_STATE_UNSPECIFIED
  SUSPENDED
}

type SqlInstanceStatus {
  conditions: [Condition!]!
  privateIpAddress: String
  publicIpAddress: String
}

type SqlInstancesList {
  metrics: SqlInstancesMetrics!
  nodes: [SqlInstance!]!
  pageInfo: PageInfo!
}

type SqlInstancesMetrics {
  cost: Float!
  cpu: SqlInstanceCpu!
  disk: SqlInstanceDisk!
  memory: SqlInstanceMemory!
}

type SqlInstancesStatus {
  failing: Int!
  otherConditions: Int!
  total: Int!
}

type SqlUser {
  authentication: String!
  name: String!
}

enum State {
  FAILING
  NAIS
  NOTNAIS
  UNKNOWN
}

interface StateError {
  level: ErrorLevel!
  revision: String!
}

type Subscription {
  log(input: LogSubscriptionInput): LogLine!
}

"""Sync error type."""
type SyncError {
  """Creation time of the error."""
  createdAt: Time!

  """Error message."""
  error: String!

  """The name of the reconciler."""
  reconciler: String!
}

type SynchronizationFailingError implements StateError {
  detail: String!
  level: ErrorLevel!
  revision: String!
}

"""Team type."""
type Team {
  """The NAIS applications owned by the team."""
  apps(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): AppList!

  """Audit logs for this team."""
  auditLogs(
    """Limit the number of audit log entries to return. Default is 20."""
    limit: Int

    """Offset to start listing audit log entries from. Default is 0."""
    offset: Int
  ): AuditLogList!

  """
  The ID of the Azure AD group for the team. This value is managed by the Azure AD reconciler.
  """
  azureGroupID: ID
  bigQuery(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): BigQueryDatasetList!

  """Get a BigQueryDataset by name and env."""
  bigQueryDataset(
    """The environment the dataset exists in."""
    env: String!

    """The name of the dataset."""
    name: String!
  ): BigQueryDataset!

  """Get a Bucket by name and env."""
  bucket(
    """The environment the bucket exists in."""
    env: String!

    """The name of the bucket."""
    name: String!
  ): Bucket!
  buckets(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): BucketsList!

  """Whether or not the team is currently being deleted."""
  deletionInProgress: Boolean!

  """The deploy key of the team."""
  deployKey: DeploymentKey!

  """The deployments of the team's applications."""
  deployments(
    """Limit the number of entries returned."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int
  ): DeploymentList!

  """The environments available for the team."""
  environments: [Env!]!

  """
  The slug of the GitHub team. This value is managed by the GitHub reconciler.
  """
  gitHubTeamSlug: String

  """The GitHub repositories that the team has access to."""
  githubRepositories(
    """Filter the repositories."""
    filter: GitHubRepositoriesFilter

    """Limit the number of repositories to return. Default is 20."""
    limit: Int

    """Offset to start listing repositories from. Default is 0."""
    offset: Int
  ): GitHubRepositoryList!

  """The Google artifact registry for the team."""
  googleArtifactRegistry: String

  """
  The email address of the Google group for the team. This value is managed by the Google Workspace reconciler.
  """
  googleGroupEmail: String
  id: ID!

  """Get a Kafka topic by name and env."""
  kafkaTopic(
    """The environment the topic exists in."""
    env: String!

    """The name of the topic."""
    name: String!
  ): KafkaTopic!
  kafkaTopics(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): KafkaTopicList!

  """Timestamp of the last successful synchronization of the team."""
  lastSuccessfulSync: Time

  """Single team member"""
  member(
    """The ID of the user."""
    userId: ID!
  ): TeamMember!

  """Team members."""
  members(
    """Limit the number of team members to return. Default is 20."""
    limit: Int

    """Offset to start listing team members from. Default is 0."""
    offset: Int
  ): TeamMemberList!

  """The NAIS jobs owned by the team."""
  naisjobs(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): NaisJobList!
  openSearch(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): OpenSearchList!

  """Get a OpenSearch instance by name and env."""
  openSearchInstance(
    """The environment the instance exists in."""
    env: String!

    """The name of the OpenSearch instance."""
    name: String!
  ): OpenSearch!

  """Purpose of the team."""
  purpose: String!
  redis(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): RedisList!

  """Get a Redis instance by name and env."""
  redisInstance(
    """The environment the instance exists in."""
    env: String!

    """The name of the Redis instance."""
    name: String!
  ): Redis!

  """Get the team's secret by name, and env."""
  secret(
    """The environment the secret is deployed to."""
    env: String!

    """The name of the secret."""
    name: String!
  ): Secret!

  """Get all secrets for the team."""
  secrets: [Secret!]!

  """Slack channel for the team."""
  slackChannel: String!

  """Unique slug of the team."""
  slug: Slug!

  """Get an SQL instance by name and env."""
  sqlInstance(
    """The environment the instance runs in."""
    env: String!

    """The name of the instance."""
    name: String!
  ): SqlInstance!
  sqlInstances(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): SqlInstancesList!

  """The status of the team."""
  status: TeamStatus!

  """
  Possible issues related to synchronization of the team to configured external systems. If there are no entries the team can be considered fully synchronized.
  """
  syncErrors: [SyncError!]!
  unleash: Unleash

  """Whether or not the viewer is a member of the team."""
  viewerIsMember: Boolean!

  """Whether or not the viewer is an owner of the team."""
  viewerIsOwner: Boolean!

  """The vulnerabilities for the team's applications."""
  vulnerabilities(
    filter: VulnerabilityFilter

    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): VulnerabilityList!
  vulnerabilitiesSummary: VulnerabilitySummary!

  """The vulnerabilities for the team's applications over time."""
  vulnerabilityMetrics(environment: String, from: Date!, to: Date!): VulnerabilityMetrics!
}

"""Team deletion key type."""
type TeamDeleteKey {
  """The creation timestamp of the key."""
  createdAt: Time!

  """The user who created the key."""
  createdBy: User!

  """Expiration timestamp of the key."""
  expires: Time!

  """The unique key used to confirm the deletion of a team."""
  key: String!

  """The team the delete key is for."""
  team: Team!
}

"""Paginated teams type."""
type TeamList {
  """The list of teams."""
  nodes: [Team!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Team member."""
type TeamMember {
  """Reconcilers for this member in this team."""
  reconcilers: [TeamMemberReconciler!]!

  """The role that the user has in the team."""
  role: TeamRole!

  """Team instance."""
  team: Team!

  """User instance."""
  user: User!
}

"""Team member input."""
input TeamMemberInput {
  """Reconcilers to opt the team member out of."""
  reconcilerOptOuts: [String!]

  """The role that the user will receive."""
  role: TeamRole!

  """The ID of user."""
  userId: ID!
}

type TeamMemberList {
  nodes: [TeamMember!]!
  pageInfo: PageInfo!
}

"""Team member reconcilers."""
type TeamMemberReconciler {
  """Whether or not the reconciler is enabled for the team member."""
  enabled: Boolean!

  """The reconciler."""
  reconciler: Reconciler!
}

"""Available team roles."""
enum TeamRole {
  """Regular member, read only access."""
  MEMBER

  """Team owner, full access to the team."""
  OWNER
}

"""Team status."""
type TeamStatus {
  apps: AppsStatus!
  jobs: JobsStatus!
  sqlInstances: SqlInstancesStatus!
}

"""Team sync type."""
type TeamSync {
  """The correlation ID for the sync."""
  correlationID: ID!
}

"""Input for filtering teams."""
input TeamsFilter {
  github: TeamsFilterGitHub
}

input TeamsFilterGitHub {
  """Filter repostiories by permission name"""
  permissionName: String!

  """Filter repostiories by repo name"""
  repoName: String!
}

"""
Time is a string in [RFC 3339](https://rfc-editor.org/rfc/rfc3339.html) format, with sub-second precision added if present.
"""
scalar Time

type TokenX {
  mountSecretsAsFilesOnly: Boolean!
}

type Unleash {
  allowedTeams: [String!]!
  apiIngress: String!
  metrics: UnleashMetrics!
  name: String!
  version: String!
  webIngress: String!
}

type UnleashMetrics {
  apiTokens: Int!
  cpuRequests: Float!
  cpuUtilization: Float!
  memoryRequests: Float!
  memoryUtilization: Float!
  toggles: Int!
}

"""Input for updating an existing team."""
input UpdateTeamInput {
  """Specify team purpose to update the existing value."""
  purpose: String

  """A list of Slack channels for NAIS alerts."""
  slackAlertsChannels: [SlackAlertsChannelInput!]

  """Specify the Slack channel to update the existing value."""
  slackChannel: String
}

"""User type."""
type User {
  """The email address of the user."""
  email: String!

  """The external ID of the user."""
  externalId: String!

  """Unique ID of the user."""
  id: ID!

  """This field will only be populated via the me query"""
  isAdmin: Boolean

  """The name of the user."""
  name: String!

  """Roles attached to the user."""
  roles: [Role!]!

  """List of team memberships."""
  teams(limit: Int, offset: Int): TeamMemberList!
}

type UserList {
  nodes: [User!]!
  pageInfo: PageInfo!
}

"""User sync run type."""
type UserSyncRun {
  """Log entries for the sync run."""
  auditLogs(limit: Int, offset: Int): AuditLogList!

  """The correlation ID of the sync run."""
  correlationID: ID!

  """Optional error."""
  error: String

  """Timestamp of when the run finished."""
  finishedAt: Time

  """Timestamp of when the run started."""
  startedAt: Time!

  """The status of the sync run."""
  status: UserSyncRunStatus!
}

"""User sync run status."""
enum UserSyncRunStatus {
  """Failed user sync run."""
  FAILURE

  """User sync run in progress."""
  IN_PROGRESS

  """Successful user sync run."""
  SUCCESS
}

type Variable {
  name: String!
  value: String!
}

input VariableInput {
  name: String!
  value: String!
}

type Vulnerability {
  appName: String!
  env: String!
  findingsLink: String!
  hasBom: Boolean!
  id: ID!
  summary: VulnerabilitySummary
}

input VulnerabilityFilter {
  """Filter by environment"""
  envs: [String!]

  """
  Require the presence of a Software Bill of Materials (SBOM) in the vulnerability report.
  """
  requireSbom: Boolean
}

type VulnerabilityList {
  nodes: [Vulnerability!]!
  pageInfo: PageInfo!
}

type VulnerabilityMetric {
  """The number of applications with vulnerabilities."""
  count: Int!

  """The number of critical vulnerabilities."""
  critical: Int!

  """The date of the metric."""
  date: Time!

  """The number of high vulnerabilities."""
  high: Int!

  """The number of low vulnerabilities."""
  low: Int!

  """The number of medium vulnerabilities."""
  medium: Int!

  """
  The weighted severity score calculated from the number of vulnerabilities.
  """
  riskScore: Int!

  """The number of unassigned vulnerabilities."""
  unassigned: Int!
}

type VulnerabilityMetrics {
  """The metrics for the team's applications."""
  data: [VulnerabilityMetric!]!

  """The maximum date for the metrics available in the database."""
  maxDate: Date

  """The minimum date for the metrics available in the database."""
  minDate: Date
}

type VulnerabilitySummary {
  bomCount: Int!
  critical: Int!
  high: Int!
  low: Int!
  medium: Int!
  riskScore: Int!
  total: Int!
  unassigned: Int!
}

interface Workload {
  accessPolicy: AccessPolicy!
  authz: [Authz!]!
  deployInfo: DeployInfo!
  env: Env!
  id: ID!
  image: String!
  name: String!
  resources: Resources!
  status: WorkloadStatus!
  variables: [Variable!]!
}

type WorkloadStatus {
  errors: [StateError!]!
  state: State!
}
