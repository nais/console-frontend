"""
Require an authenticated user with the admin role for all requests with this directive.
"""
directive @admin on FIELD_DEFINITION

"""Require an authenticated user for all requests with this directive."""
directive @auth on FIELD_DEFINITION

"""
The @defer directive may be specified on a fragment spread to imply de-prioritization, that causes the fragment to be omitted in the initial response, and delivered as a subsequent response afterward. A query with @defer directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred delivered in a subsequent response. @include and @skip take precedence over @defer.
"""
directive @defer(if: Boolean = true, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

type AccessPolicy {
  inbound: Inbound!
  outbound: Outbound!
}

type AnalysisComment {
  comment: String!
  onBehalfOf: String!
  timestamp: Time!
}

type AnalysisCommentList {
  nodes: [AnalysisComment]!
  pageInfo: PageInfo!
}

type AnalysisTrail {
  comments(limit: Int, offset: Int): AnalysisCommentList!
  id: ID!
  isSuppressed: Boolean!
  state: String!
}

type App implements Workload {
  accessPolicy: AccessPolicy!
  authz: [Authz!]!
  deployInfo: DeployInfo!
  env: Env!
  id: ID!
  image: String!
  imageDetails: ImageDetails!
  ingresses: [String!]!
  instances: [Instance!]!
  manifest: String!
  name: String!
  persistence: [Persistence!]!
  resources: Resources!
  secrets: [Secret!]!
  status: WorkloadStatus!
  team: Team!
  type: WorkloadType!
  variables: [Variable!]!
}

"""App cost type."""
type AppCost {
  """The name of the application."""
  app: String!

  """A list of cost entries for the application."""
  cost: [CostEntry!]!

  """The sum of all cost entries for the application in euros."""
  sum: Float!
}

type AppList {
  nodes: [App!]!
  pageInfo: PageInfo!
}

"""Team status for apps."""
type AppsStatus {
  failing: Int!
  total: Int!
}

"""Audit event type."""
interface AuditEvent {
  """String representation of the action performed."""
  action: AuditEventAction!

  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the event."""
  createdAt: Time!

  """ID of the event."""
  id: ID!

  """Message that summarizes the event."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: AuditEventResourceType!

  """The team that the event belongs to."""
  team: Team
}

enum AuditEventAction {
  ADDED
  REMOVED
  TEAM_CREATED
  TEAM_DELETION_CONFIRMED
  TEAM_DELETION_REQUESTED
  TEAM_DEPLOY_KEY_ROTATED
  TEAM_MEMBER_ADDED
  TEAM_MEMBER_REMOVED
  TEAM_MEMBER_SET_ROLE
  TEAM_SET_ALERTS_SLACK_CHANNEL
  TEAM_SET_DEFAULT_SLACK_CHANNEL
  TEAM_SET_PURPOSE
  TEAM_SYNCHRONIZED
}

type AuditEventList {
  nodes: [AuditEventNode!]!
  pageInfo: PageInfo!
}

type AuditEventMemberAdded implements AuditEvent {
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  data: AuditEventMemberAddedData!
  id: ID!
  message: String!
  resourceName: String!
  resourceType: AuditEventResourceType!
  team: Team!
}

type AuditEventMemberAddedData {
  memberEmail: String!
  role: TeamRole!
}

type AuditEventMemberRemoved implements AuditEvent {
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  data: AuditEventMemberRemovedData!
  id: ID!
  message: String!
  resourceName: String!
  resourceType: AuditEventResourceType!
  team: Team!
}

type AuditEventMemberRemovedData {
  memberEmail: String!
}

type AuditEventMemberSetRole implements AuditEvent {
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  data: AuditEventMemberSetRoleData!
  id: ID!
  message: String!
  resourceName: String!
  resourceType: AuditEventResourceType!
  team: Team!
}

type AuditEventMemberSetRoleData {
  memberEmail: String!
  role: TeamRole!
}

union AuditEventNode = AuditEventMemberAdded | AuditEventMemberRemoved | AuditEventMemberSetRole | AuditEventTeamAddRepository | AuditEventTeamRemoveRepository | AuditEventTeamSetAlertsSlackChannel | AuditEventTeamSetDefaultSlackChannel | AuditEventTeamSetPurpose | BaseAuditEvent | BaseTeamAuditEvent

enum AuditEventResourceType {
  TEAM
  TEAM_MEMBER
  TEAM_REPOSITORY
}

type AuditEventTeamAddRepository implements AuditEvent {
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  data: AuditEventTeamAddRepositoryData!
  id: ID!
  message: String!
  resourceName: String!
  resourceType: AuditEventResourceType!
  team: Team!
}

type AuditEventTeamAddRepositoryData {
  repositoryName: String!
}

type AuditEventTeamRemoveRepository implements AuditEvent {
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  data: AuditEventTeamRemoveRepositoryData!
  id: ID!
  message: String!
  resourceName: String!
  resourceType: AuditEventResourceType!
  team: Team!
}

type AuditEventTeamRemoveRepositoryData {
  repositoryName: String!
}

type AuditEventTeamSetAlertsSlackChannel implements AuditEvent {
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  data: AuditEventTeamSetAlertsSlackChannelData!
  id: ID!
  message: String!
  resourceName: String!
  resourceType: AuditEventResourceType!
  team: Team!
}

type AuditEventTeamSetAlertsSlackChannelData {
  channelName: String!
  environment: String!
}

type AuditEventTeamSetDefaultSlackChannel implements AuditEvent {
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  data: AuditEventTeamSetDefaultSlackChannelData!
  id: ID!
  message: String!
  resourceName: String!
  resourceType: AuditEventResourceType!
  team: Team!
}

type AuditEventTeamSetDefaultSlackChannelData {
  defaultSlackChannel: String!
}

type AuditEventTeamSetPurpose implements AuditEvent {
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  data: AuditEventTeamSetPurposeData!
  id: ID!
  message: String!
  resourceName: String!
  resourceType: AuditEventResourceType!
  team: Team!
}

type AuditEventTeamSetPurposeData {
  purpose: String!
}

input AuditEventsFilter {
  """Filter by the type of the resource that was affected by the action."""
  resourceType: AuditEventResourceType
}

"""Audit log type."""
type AuditLog {
  """String representation of the action performed."""
  action: String!

  """
  The identity of the actor who performed the action. When this field is empty it means that some backend process performed the action. The value, when present, is either the name of a service account, or the email address of a user.
  """
  actor: String

  """The related correlation ID."""
  correlationID: String!

  """Creation time of the log entry."""
  createdAt: Time!

  """ID of the log entry."""
  id: ID!

  """Log entry message."""
  message: String!

  """The identifier of the target."""
  targetIdentifier: String!

  """The type of the audit log target."""
  targetType: String!
}

type AuditLogList {
  nodes: [AuditLog!]!
  pageInfo: PageInfo!
}

"""Authenticated user type. Can be a user or a service account."""
union AuthenticatedUser = ServiceAccount | User

union Authz = AzureAD | IDPorten | Maskinporten | TokenX

type AzureAD {
  application: AzureApplication
  sidecar: Sidecar
}

type AzureApplication {
  allowAllUsers: Boolean!
  claims: Claims!
  replyURLs: [String!]!
  singlePageApplication: Boolean!
  tenant: String!
}

type BackupConfiguration {
  enabled: Boolean!
  pointInTimeRecovery: Boolean!
  retainedBackups: Int!
  startTime: String!
  transactionLogRetentionDays: Int!
}

type BaseAuditEvent implements AuditEvent {
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  id: ID!
  message: String!
  resourceName: String!
  resourceType: AuditEventResourceType!
  team: Team
}

type BaseTeamAuditEvent implements AuditEvent {
  action: AuditEventAction!
  actor: String!
  createdAt: Time!
  id: ID!
  message: String!
  resourceName: String!
  resourceType: AuditEventResourceType!
  team: Team!
}

type BigQueryDataset implements Persistence {
  access: [BigQueryDatasetAccess!]!
  cascadingDelete: Boolean!
  cost: Float!
  description: String!
  env: Env!
  id: ID!
  name: String!
  status: BigQueryDatasetStatus!
  team: Team!
  workload: Workload
}

type BigQueryDatasetAccess {
  email: String!
  role: String!
}

type BigQueryDatasetList {
  nodes: [BigQueryDataset!]!
  pageInfo: PageInfo!
}

type BigQueryDatasetStatus {
  conditions: [Condition!]!
  creationTime: Time!
  lastModifiedTime: Time
}

type Bucket implements Persistence {
  cascadingDelete: Boolean!
  cors: [BucketCors!]
  env: Env!
  id: ID!
  name: String!
  projectId: String!
  publicAccessPrevention: String!
  retentionPeriodDays: Int!
  status: BucketStatus!
  team: Team!
  uniformBucketLevelAccess: Boolean!
  workload: Workload
}

type BucketCors {
  maxAgeSeconds: Int
  methods: [String!]!
  origins: [String!]!
  responseHeaders: [String!]!
}

type BucketStatus {
  conditions: [Condition!]!
  selfLink: String!
}

type BucketsList {
  metrics: BucketsMetrics!
  nodes: [Bucket!]!
  pageInfo: PageInfo!
}

type BucketsMetrics {
  cost: Float!
}

type CPUScalingStrategy implements ScalingStrategy {
  threshold: Int!
}

type Claims {
  extra: [String!]!
  groups: [Group!]!
}

type Condition {
  lastTransitionTime: Time!
  message: String!
  reason: String!
  status: String!
  type: String!
}

type Consume {
  name: String!
}

type Consumer {
  name: String!
  orgno: String!
}

"""Cost entry type."""
type CostEntry {
  """The cost in euros."""
  cost: Float!

  """The date for the entry."""
  date: Date!
}

"""Cost series type."""
type CostSeries {
  """The type of cost."""
  costType: String!

  """The cost data."""
  data: [CostEntry!]!

  """The sum of all daily costs in the series for this cost type in euros."""
  sum: Float!
}

"""Input for creating a new team."""
input CreateTeamInput {
  """Team purpose."""
  purpose: String!

  """Specify the Slack channel for the team."""
  slackChannel: String!

  """Team slug. After creation, this value can not be changed."""
  slug: Slug!
}

"""Daily cost type."""
type DailyCost {
  """The cost series."""
  series: [CostSeries!]!

  """The sum of all costs in the cost series in euros."""
  sum: Float!
}

"""Date type in YYYY-MM-DD format."""
scalar Date

type DeleteAppResult {
  """Whether the app was deleted or not."""
  deleted: Boolean!
  error: String
}

type DeleteJobResult {
  """Whether the job was deleted or not."""
  deleted: Boolean!
  error: String
}

type DeployInfo {
  commitSha: String!
  deployer: String!
  history(limit: Int, offset: Int): DeploymentResponse!
  timestamp: Time
  url: String!
}

type Deployment {
  created: Time!
  env: String!
  id: ID!
  repository: String!
  resources: [DeploymentResource!]!
  statuses: [DeploymentStatus!]!
  team: Team!
}

"""Deployment key type."""
type DeploymentKey {
  """The date the deployment key was created."""
  created: Time!

  """The date the deployment key expires."""
  expires: Time!

  """The unique identifier of the deployment key."""
  id: ID!

  """The actual key."""
  key: String!
}

type DeploymentList {
  nodes: [Deployment!]!
  pageInfo: PageInfo!
}

type DeploymentResource {
  group: String!
  id: ID!
  kind: String!
  name: String!
  namespace: String!
  version: String!
}

union DeploymentResponse = DeploymentList | Error

type DeploymentStatus {
  created: Time!
  id: ID!
  message: String
  status: String!
}

type DeprecatedIngressError implements StateError {
  ingress: String!
  level: ErrorLevel!
  revision: String!
}

type DeprecatedRegistryError implements StateError {
  level: ErrorLevel!
  name: String!
  registry: String!
  repository: String!
  revision: String!
  tag: String!
}

type Env {
  gcpProjectID: String
  id: ID!
  name: String!
  secrets: [Secret!]!
  slackAlertsChannel: String!
}

"""Env cost type."""
type EnvCost {
  """A list of app costs in the environment."""
  apps: [AppCost!]!

  """The name of the environment."""
  env: String!

  """The sum of all app costs for the environment in euros."""
  sum: Float!
}

"""Env cost filter input type."""
input EnvCostFilter {
  """Start date for the cost series, inclusive."""
  from: Date!

  """The name of the team to get costs for."""
  team: Slug!

  """End date for cost series, inclusive."""
  to: Date!
}

type Error {
  message: String!
}

enum ErrorLevel {
  ERROR
  TODO
  WARNING
}

type Expose {
  allowedIntegrations: [String!]!
  atMaxAge: Int!
  consumers: [Consumer!]!
  enabled: Boolean!
  name: String!
  product: String!
}

type External {
  host: String!
  ports: [Port!]!
}

type FailedRunError implements StateError {
  level: ErrorLevel!
  revision: String!
  runMessage: String!
  runName: String!
}

type Finding {
  aliases: [VulnIdAlias!]!
  analysisTrail: AnalysisTrail!
  componentId: String!
  description: String!
  id: ID!
  isSuppressed: Boolean!
  packageUrl: String!
  parentId: String!
  severity: String!
  source: String!
  state: String!
  vulnId: String!
  vulnerabilityId: String!
}

type FindingList {
  nodes: [Finding!]!
  pageInfo: PageInfo!
}

type Flag {
  name: String!
  value: String!
}

"""GCP project type."""
type GcpProject {
  """The environment for the project."""
  environment: String!

  """The GCP project ID."""
  projectId: String!

  """The display name of the project."""
  projectName: String!
}

"""Input for filtering GitHub repositories."""
input GitHubRepositoriesFilter {
  """Whether or not to include archived repositories. Defaults to false."""
  includeArchivedRepositories: Boolean
}

"""GitHub repository type."""
type GitHubRepository {
  """Whether or not the repository is archived."""
  archived: Boolean!

  """ID of the repository."""
  id: ID!

  """Name of the repository, with the org prefix."""
  name: String!

  """A list of permissions given to the team for this repository."""
  permissions: [GitHubRepositoryPermission!]!

  """The name of the role the team has been granted in the repository."""
  roleName: String!
}

"""Paginated GitHub repository type."""
type GitHubRepositoryList {
  """The list of GitHub repositories."""
  nodes: [GitHubRepository!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""GitHub repository permission type."""
type GitHubRepositoryPermission {
  """Whether or not the permission is granted for the repository."""
  granted: Boolean!

  """Name of the permission."""
  name: String!
}

type Group {
  id: String!
}

type IDPorten {
  accessTokenLifetime: Int
  clientURI: String
  frontchannelLogoutPath: String
  integrationType: String
  postLogoutRedirectURIs: [String]
  redirectPath: String
  scopes: [String]
  sessionLifetime: Int
  sidecar: IDPortenSidecar
}

type IDPortenSidecar {
  autoLogin: Boolean
  autoLoginIgnorePaths: [String]
  enabled: Boolean
  level: String
  locale: String
  resources: Resources
}

type ImageDetails {
  findings(
    """Limit the number of entries returned."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order findings by"""
    orderBy: OrderBy
  ): FindingList!
  hasSbom: Boolean!
  id: ID!
  name: String!
  projectId: String!
  projectUrl: String!
  rekor: Rekor!
  summary: ImageVulnerabilitySummary
  version: String!
  workloadReferences: [Workload!]!
}

type ImageDetailsList {
  nodes: [ImageDetails!]!
  pageInfo: PageInfo!
}

type ImageVulnerabilitySummary {
  critical: Int!
  high: Int!
  id: ID!
  low: Int!
  medium: Int!
  riskScore: Int!
  total: Int!
  unassigned: Int!
}

type Inbound {
  rules: [Rule!]!
}

type InboundAccessError implements StateError {
  level: ErrorLevel!
  revision: String!
  rule: Rule!
}

type Insights {
  enabled: Boolean!
  queryStringLength: Int!
  recordApplicationTags: Boolean!
  recordClientAddress: Boolean!
}

type Instance {
  created: Time!
  id: ID!
  image: String!
  message: String!
  name: String!
  restarts: Int!
  state: InstanceState!
}

enum InstanceState {
  FAILING
  RUNNING
  UNKNOWN
}

type InvalidNaisYamlError implements StateError {
  detail: String!
  level: ErrorLevel!
  revision: String!
}

"""Team status for jobs."""
type JobsStatus {
  failing: Int!
  total: Int!
}

type KafkaLagScalingStrategy implements ScalingStrategy {
  consumerGroup: String!
  threshold: Int!
  topic: String!
}

type KafkaTopic implements Persistence {
  acl(
    """Filter by team and app"""
    filter: KafkaTopicACLFilter

    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): KafkaTopicAclList!
  config: KafkaTopicConfig
  env: Env!
  id: ID!
  name: String!
  pool: String!
  status: KafkaTopicStatus
  team: Team!
}

input KafkaTopicACLFilter {
  application: String
  team: Slug
}

type KafkaTopicAcl {
  access: String!
  applicationName: String!
  teamName: String!
  workload: Workload
}

type KafkaTopicAclList {
  nodes: [KafkaTopicAcl!]!
  pageInfo: PageInfo!
}

type KafkaTopicConfig {
  cleanupPolicy: String
  maxMessageBytes: Int
  minimumInSyncReplicas: Int
  partitions: Int
  replication: Int
  retentionBytes: Int
  retentionHours: Int
  segmentHours: Int
}

type KafkaTopicList {
  nodes: [KafkaTopic!]!
  pageInfo: PageInfo!
}

type KafkaTopicStatus {
  credentialsExpiryTime: Time
  errors: [String!]
  fullyQualifiedName: String!
  latestAivenSyncFailure: Time
  message: String!
  synchronizationState: State!
  synchronizationTime: Time
}

type Limits {
  cpu: String!
  memory: String!
}

type LogLine {
  instance: String!
  message: String!
  time: Time!
}

input LogSubscriptionInput {
  app: String
  env: String!
  instances: [String!]
  job: String
  team: Slug!
}

type MaintenanceWindow {
  day: Int!
  hour: Int!
}

type Maskinporten {
  enabled: Boolean!
  scopes: MaskinportenScope!
}

type MaskinportenScope {
  consumes: [Consume!]!
  exposes: [Expose!]!
}

"""Monthly cost type."""
type MonthlyCost {
  """A list of monthly cost entries."""
  cost: [CostEntry!]!

  """Sum for all months in the series in euros."""
  sum: Float!
}

"""Monthly cost filter input type."""
input MonthlyCostFilter {
  """The name of the application to get costs for."""
  app: String!

  """The name of the environment to get costs for."""
  env: String!

  """The name of the team to get costs for."""
  team: Slug!
}

"""The root query for implementing GraphQL mutations."""
type Mutation {
  """
  Add opt-out of a reconciler for a team member. Only reconcilers that are member aware can be opted out from.
  """
  addReconcilerOptOut(
    """The name of the reconciler to opt the team member out of."""
    reconciler: String!

    """The team slug."""
    teamSlug: Slug!

    """The user ID of the team member."""
    userId: ID!
  ): TeamMember!

  """Add a team repository."""
  addRepository(
    """Name of the repository, with the org prefix, for instance 'org/repo'."""
    repoName: String!

    """The slug of the team that adds the repository."""
    teamSlug: Slug!
  ): String!

  """
  Add a user to a team
  
  If the user is already a member or an owner of the team, the mutation will fail.
  
  The updated team will be returned on success.
  """
  addTeamMember(
    """The new team member."""
    member: TeamMemberInput!

    """Slug of the team that should receive a new member."""
    slug: Slug!
  ): Team!

  """Update the deploy key of a team. Returns the updated deploy key."""
  changeDeployKey(
    """The name of the team to update the deploy key for."""
    team: Slug!
  ): DeploymentKey!

  """Configure a reconciler."""
  configureReconciler(
    """List of reconciler config inputs."""
    config: [ReconcilerConfigInput!]!

    """The name of the reconciler to configure."""
    name: String!
  ): Reconciler!

  """
  Confirm a team deletion
  
  This will start the actual team deletion process, which will be done in an asynchronous manner. All external
  entities controlled by NAIS will also be deleted.
  
  WARNING: There is no going back after starting this process.
  
  Note: Service accounts are not allowed to confirm a team deletion.
  """
  confirmTeamDeletion(
    """Deletion key, acquired using the requestTeamDeletion mutation."""
    key: String!
  ): Boolean!

  """Create a new secret for a team and env."""
  createSecret(
    """The secret data."""
    data: [VariableInput!]!

    """The environment the secret is deployed to."""
    env: String!

    """The name of the secret."""
    name: String!

    """The name of the team who owns the secret."""
    team: Slug!
  ): Secret!

  """
  Create a new team
  
  The user creating the team will be granted team ownership, unless the user is a service account, in which case the
  team will not get an initial owner. To add one or more owners to the team, refer to the `addTeamOwners` mutation.
  
  The new team will be returned on success.
  """
  createTeam(
    """Input for creation of the new team."""
    input: CreateTeamInput!
  ): Team!

  """
  Create a new Unleash instance.
  
  This mutation will create a new Unleash instance for the given team. The team
  will be set as owner of the Unleash instance and will be able to manage it.
  """
  createUnleashForTeam(team: Slug!): Unleash!
  deleteApp(
    """The environment the application is deployed to."""
    env: String!

    """The name of the application."""
    name: String!

    """The name of the team who owns the application."""
    team: Slug!
  ): DeleteAppResult!
  deleteJob(
    """The environment the naisjob is deployed to."""
    env: String!

    """The name of the naisjob."""
    name: String!

    """The name of the team who owns the naisjob."""
    team: Slug!
  ): DeleteJobResult!

  """Delete an existing secret for a team and env."""
  deleteSecret(
    """The environment the secret is deployed to."""
    env: String!

    """The name of the secret."""
    name: String!

    """The name of the team who owns the secret."""
    team: Slug!
  ): Boolean!

  """
  Disable a reconciler
  
  The reconciler configuration will be left intact.
  """
  disableReconciler(
    """The name of the reconciler to disable."""
    name: String!
  ): Reconciler!

  """
  Enable a reconciler
  
  A reconciler must be fully configured before it can be enabled.
  """
  enableReconciler(
    """The name of the reconciler to enable."""
    name: String!
  ): Reconciler!

  """Remove opt-out of a reconciler for a team member."""
  removeReconcilerOptOut(
    """The name of the reconciler to clear the opt-out from."""
    reconciler: String!

    """The team slug."""
    teamSlug: Slug!

    """The user ID of the team member."""
    userId: ID!
  ): TeamMember!

  """Remove a team repository."""
  removeRepository(
    """Name of the repository, with the org prefix, for instance 'org/repo'."""
    repoName: String!

    """The slug of the team that removes the repository."""
    teamSlug: Slug!
  ): String!

  """
  Remove a user from a team
  
  The updated team will be returned on success.
  """
  removeUserFromTeam(
    """Team slug that the user should be removed from."""
    slug: Slug!

    """ID of the user that will be removed from the team."""
    userId: ID!
  ): Team!

  """
  Request a key that can be used to trigger a team deletion process
  
  Deleting a team is a two step process. First an owner of the team (or an admin) must request a team deletion key, and
  then a second owner of the team (or an admin) must confirm the deletion using the confirmTeamDeletion mutation.
  
  Note: Service accounts are not allowed to request team delete keys.
  """
  requestTeamDeletion(
    """The slug of the team that the deletion key will be assigned to."""
    slug: Slug!
  ): TeamDeleteKey!

  """
  Reset all reconciler configuration options to their initial state and disable the reconciler if it is currently enabled.
  """
  resetReconciler(
    """The name of the reconciler to reset."""
    name: String!
  ): Reconciler!
  restartApp(
    """The environment the application is deployed to."""
    env: String!

    """The name of the application."""
    name: String!

    """The name of the team who owns the application."""
    team: Slug!
  ): RestartAppResult!

  """
  Set the member role of a user in a team
  
  The user must already exist in the team for this mutation to succeed.
  
  The team will be returned on success.
  """
  setTeamMemberRole(
    """The team role to set."""
    role: TeamRole!

    """The slug of the team."""
    slug: Slug!

    """The ID of the user."""
    userId: ID!
  ): Team!
  suppressFinding(
    """The analysis state of the finding."""
    analysisState: String!

    """The a comment for suppressing the finding."""
    comment: String!

    """The component id of the finding to suppress."""
    componentId: String!

    """The project id of the image."""
    projectId: String!

    """Should the finding be suppressed."""
    suppress: Boolean!

    """Suppressed by user."""
    suppressedBy: String!

    """The team slug."""
    team: Slug!

    """The id of the finding to suppress."""
    vulnerabilityId: String!
  ): AnalysisTrail!

  """
  Manually synchronize all teams
  
  This action will trigger a full synchronization of all teams against the configured third party systems. The action
  is asynchronous. The operation can take a while, depending on the amount of teams currently managed.
  """
  synchronizeAllTeams: TeamSync!

  """
  Manually synchronize a team
  
  This action will trigger a full synchronization of the team against the configured third party systems. The action
  is asynchronous.
  
  The team will be returned.
  """
  synchronizeTeam(
    """The slug of the team to synchronize."""
    slug: Slug!
  ): TeamSync!

  """
  Trigger a user synchronization
  
  This mutation will trigger a full user synchronization with the connected Google Workspace, and return a correlation
  ID that can later be matched to the log entries. The user synchronization itself is asynchronous.
  """
  synchronizeUsers: String!

  """Update an existing secret for a team and env."""
  updateSecret(
    """The secret data."""
    data: [VariableInput!]!

    """The environment the secret is deployed to."""
    env: String!

    """The name of the secret."""
    name: String!

    """The name of the team who owns the secret."""
    team: Slug!
  ): Secret!

  """
  Update an existing team
  
  This mutation can be used to update the team purpose. It is not possible to update the team slug.
  
  The updated team will be returned on success.
  """
  updateTeam(
    """Input for updating the team."""
    input: UpdateTeamInput!

    """Slug of the team to update."""
    slug: Slug!
  ): Team!

  """
  Update an existing team's Slack alerts channel
  
  The updated team will be returned on success.
  """
  updateTeamSlackAlertsChannel(
    """Input for updating the team."""
    input: UpdateTeamSlackAlertsChannelInput!

    """Slug of the team to update."""
    slug: Slug!
  ): Team!

  """Update Unleash instance with allowed teams."""
  updateUnleashForTeam(allowedTeams: [String!], name: String!, team: Slug!): Unleash!
}

type NaisJob implements Workload {
  accessPolicy: AccessPolicy!
  authz: [Authz!]!
  completions: Int!
  deployInfo: DeployInfo!
  env: Env!
  id: ID!
  image: String!
  imageDetails: ImageDetails!
  manifest: String!
  name: String!
  parallelism: Int!
  persistence: [Persistence!]!
  resources: Resources!
  retries: Int!
  runs: [Run!]!
  schedule: String!
  secrets: [Secret!]!
  status: WorkloadStatus!
  team: Team!
  type: WorkloadType!
  variables: [Variable!]!
}

type NaisJobList {
  nodes: [NaisJob!]!
  pageInfo: PageInfo!
}

"""NAIS namespace type."""
type NaisNamespace {
  """The environment for the namespace."""
  environment: String!

  """The namespace."""
  namespace: Slug!
}

type NewInstancesFailingError implements StateError {
  failingInstances: [String!]!
  level: ErrorLevel!
  revision: String!
}

type NoRunningInstancesError implements StateError {
  level: ErrorLevel!
  revision: String!
}

type OpenSearch implements Persistence {
  access: [OpenSearchInstanceAccess!]!
  cost: Float!
  env: Env!
  id: ID!

  """The opensearch instance name"""
  name: String!
  status: OpenSearchStatus!
  team: Team!
  workload: Workload
}

type OpenSearchInstanceAccess {
  role: String!
  workload: Workload!
}

type OpenSearchList {
  metrics: OpenSearchMetrics!
  nodes: [OpenSearch!]!
  pageInfo: PageInfo!
}

type OpenSearchMetrics {
  cost: Float!
}

type OpenSearchStatus {
  conditions: [Condition!]!
  state: String!
}

input OrderBy {
  """Order direction."""
  direction: SortOrder!

  """The field to order by."""
  field: OrderByField!
}

enum OrderByField {
  """Order by access"""
  ACCESS

  """Order by appName."""
  APP_NAME

  """Order by cost"""
  COST

  """Order by CPU utilization"""
  CPU

  """Order by deployed time"""
  DEPLOYED

  """Order by disk utilization"""
  DISK

  """Order by env"""
  ENV

  """Order by env."""
  ENV_NAME

  """Order by isSuppressed."""
  IS_SUPPRESSED

  """Order by memory utilization"""
  MEMORY

  """Order by name"""
  NAME

  """Order by packageUrl"""
  PACKAGE_URL

  """Order by risk score"""
  RISK_SCORE

  """Order by severity."""
  SEVERITY

  """Order apps by vulnerability severity critical"""
  SEVERITY_CRITICAL

  """Order apps by vulnerability severity high"""
  SEVERITY_HIGH

  """Order apps by vulnerability severity low"""
  SEVERITY_LOW

  """Order apps by vulnerability severity medium"""
  SEVERITY_MEDIUM

  """Order apps by vulnerability severity unassigned"""
  SEVERITY_UNASSIGNED

  """Order by state."""
  STATE

  """Order by status"""
  STATUS

  """Order by PostgreSQL version"""
  VERSION
}

type Outbound {
  external: [External!]!
  rules: [Rule!]!
}

type OutboundAccessError implements StateError {
  level: ErrorLevel!
  revision: String!
  rule: Rule!
}

"""Pagination information."""
type PageInfo {
  """Whether or not there exists a next page in the data set."""
  hasNextPage: Boolean!

  """Whether or not there exists a previous page in the data set."""
  hasPreviousPage: Boolean!

  """The total amount if items accessible."""
  totalCount: Int!
}

interface Persistence {
  id: ID!
  name: String!
}

type Port {
  port: Int!
}

"""The query root for the NAIS GraphQL API."""
type Query {
  """Get an app by name, team and env."""
  app(
    """The environment the application is deployed to."""
    env: String!

    """The name of the application."""
    name: String!

    """The name of the team who owns the application."""
    team: Slug!
  ): App!

  """Get the daily cost for a team application in a specific environment."""
  dailyCostForApp(
    """The name of the application to get costs for."""
    app: String!

    """The environment that the application runs in."""
    env: String!

    """Start date for the cost series, inclusive."""
    from: Date!

    """The name of the team that owns the application."""
    team: Slug!

    """End date for cost series, inclusive."""
    to: Date!
  ): DailyCost!

  """Get the daily cost for a team across all apps and environments."""
  dailyCostForTeam(
    """Start date for the cost series, inclusive."""
    from: Date!

    """The name of the team that owns the application."""
    team: Slug!

    """End date for cost series, inclusive."""
    to: Date!
  ): DailyCost!

  """Get a list of deployments."""
  deployments(limit: Int, offset: Int): DeploymentList!

  """Get env cost for a team."""
  envCost(filter: EnvCostFilter!): [EnvCost!]!

  """The currently authenticated user."""
  me: AuthenticatedUser!

  """Get monthly costs."""
  monthlyCost(filter: MonthlyCostFilter!): MonthlyCost!

  """Get a naisjob by name, team and env."""
  naisjob(
    """The environment the naisjob is deployed in."""
    env: String!

    """The name of the naisjob."""
    name: String!

    """The name of the team who owns the naisjob."""
    team: Slug!
  ): NaisJob!

  """Get a collection of reconcilers."""
  reconcilers(limit: Int, offset: Int): ReconcilerList!
  search(filter: SearchFilter, limit: Int, offset: Int, query: String!): SearchList!

  """Get a specific team."""
  team(
    """Slug of the team."""
    slug: Slug!
  ): Team!

  """Get a team delete key."""
  teamDeleteKey(
    """The key to get."""
    key: String!
  ): TeamDeleteKey!
  teamUtilization(resourceType: UsageResourceType!): [TeamUtilizationData!]!

  """Get a collection of teams. Default limit is 20"""
  teams(
    """Filter teams."""
    filter: TeamsFilter

    """Limit the number of teams to return. Default is 20."""
    limit: Int

    """Offset to start listing teams from. Default is 0."""
    offset: Int
  ): TeamList!

  """Get a specific user."""
  user(
    """Email of the user."""
    email: String

    """ID of the user."""
    id: ID
  ): User!

  """Get a collection of users, sorted by name."""
  users(limit: Int, offset: Int): UserList!

  """Get user sync status and logs."""
  usersyncRuns(limit: Int, offset: Int): UsersyncRunList!
}

"""Reconciler type."""
type Reconciler {
  """Audit logs for this reconciler."""
  auditLogs(limit: Int, offset: Int): AuditLogList!

  """Reconciler configuration keys and descriptions."""
  config: [ReconcilerConfig!]!

  """
  Whether or not the reconciler is fully configured and ready to be enabled.
  """
  configured: Boolean!

  """Description of what the reconciler is responsible for."""
  description: String!

  """The human-friendly name of the reconciler."""
  displayName: String!

  """Whether or not the reconciler is enabled."""
  enabled: Boolean!

  """Potential errors that have occurred during the reconciler's operation."""
  errors(limit: Int, offset: Int): ReconcilerErrorList!

  """Whether or not the reconciler uses team memberships when syncing."""
  memberAware: Boolean!

  """The name of the reconciler."""
  name: String!
}

"""Reconciler configuration type."""
type ReconcilerConfig {
  """Whether or not the configuration key has a value."""
  configured: Boolean!

  """Configuration description."""
  description: String!

  """The human-friendly name of the configuration key."""
  displayName: String!

  """Configuration key."""
  key: String!

  """
  Whether or not the configuration value is considered a secret. Secret values will not be exposed through the API.
  """
  secret: Boolean!

  """
  Configuration value. This will be set to null if the value is considered a secret.
  """
  value: String
}

"""Reconciler configuration input."""
input ReconcilerConfigInput {
  """Configuration key."""
  key: String!

  """Configuration value."""
  value: String!
}

type ReconcilerError {
  correlationId: ID!
  createdAt: Time!
  id: ID!
  message: String!
  team: Team!
}

type ReconcilerErrorList {
  nodes: [ReconcilerError!]!
  pageInfo: PageInfo!
}

"""Paginated reconcilers type."""
type ReconcilerList {
  """The list of reconcilers."""
  nodes: [Reconciler!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type Redis implements Persistence {
  access: [RedisInstanceAccess!]!
  cost: Float!
  env: Env!
  id: ID!
  name: String!
  status: RedisStatus!
  team: Team!
  workload: Workload
}

type RedisInstanceAccess {
  role: String!
  workload: Workload!
}

type RedisList {
  metrics: RedisMetrics!
  nodes: [Redis!]!
  pageInfo: PageInfo!
}

type RedisMetrics {
  cost: Float!
}

type RedisStatus {
  conditions: [Condition!]!
  state: String!
}

type Rekor {
  buildConfigURI: String!
  buildTrigger: String!
  gitHubWorkflowName: String!
  gitHubWorkflowRef: String!
  gitHubWorkflowSHA: String!
  integratedTime: Int!
  logIndex: String!
  oIDCIssuer: String!
  runInvocationURI: String!
  runnerEnvironment: String!
  sourceRepositoryOwnerURI: String!
}

type RepositoryList {
  """The list of repositories."""
  nodes: [String!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type Requests {
  cpu: String!
  memory: String!
}

type Resources {
  """Instances using resources above this threshold will be killed"""
  limits: Limits!

  """How many resources are allocated to each instance """
  requests: Requests!
  scaling: Scaling!

  """Get the current usage for the requested resource type."""
  usage(resourceType: UsageResourceType!): Float!

  """Usage between start and end with step size for given resource type."""
  usageRange(
    """Fetch resource usage until this timestamp."""
    end: Time!

    """Resource type."""
    resourceType: UsageResourceType!

    """Fetch resource usage from this timestamp."""
    start: Time!

    """Step size in seconds for the data points."""
    step: Int!
  ): [UsageDataPoint!]!
}

type RestartAppResult {
  error: String
}

"""Role binding type."""
type Role {
  """Whether or not the role is global."""
  isGlobal: Boolean!

  """Name of the role."""
  name: String!

  """
  Optional service account if the role binding targets a service account.
  """
  targetServiceAccount: ServiceAccount

  """Optional team if the role binding targets a team."""
  targetTeam: Team
}

type Rule {
  application: String!
  cluster: String!
  isJob: Boolean!
  mutual: Boolean!
  mutualExplanation: String!
  namespace: String!
}

type Run {
  completionTime: Time
  duration: String!
  failed: Boolean!
  id: ID!
  image: String!
  message: String!
  name: String!
  podNames: [String!]!
  startTime: Time
}

type Scaling {
  max: Int!
  min: Int!
  strategies: [ScalingStrategy!]!
}

interface ScalingStrategy {
  threshold: Int!
}

input SearchFilter {
  type: SearchType
}

type SearchList {
  nodes: [SearchNode!]!
  pageInfo: PageInfo!
}

union SearchNode = App | BigQueryDataset | Bucket | KafkaTopic | NaisJob | OpenSearch | Redis | Secret | SqlInstance | Team

enum SearchType {
  APP
  BIGQUERY
  BUCKET
  KAFKATOPIC
  NAISJOB
  OPENSEARCH
  REDIS
  SECRET
  SQLINSTANCE
  TEAM
}

type Secret {
  apps: [App!]!
  data: [Variable!]!
  env: Env!
  id: ID!
  jobs: [NaisJob!]!
  lastModifiedAt: Time
  lastModifiedBy: User
  name: String!
  team: Team!
}

"""Service account type."""
type ServiceAccount {
  """Unique ID of the service account."""
  id: ID!

  """The name of the service account."""
  name: String!

  """Roles attached to the service account."""
  roles: [Role!]!
}

type Sidecar {
  autoLogin: Boolean!
  autoLoginIgnorePaths: [String!]!
  resources: Resources!
}

"""Slack alerts channel type."""
type SlackAlertsChannel {
  """The name of the Slack channel."""
  channelName: String!

  """The environment for the alerts sent to the channel."""
  environment: String!
}

"""
The slug must:

- contain only lowercase alphanumeric characters or hyphens
- contain at least 3 characters and at most 30 characters
- start with an alphabetic character
- end with an alphanumeric character
- not contain two hyphens in a row

Examples of valid slugs:

- `some-value`
- `someothervalue`
- `my-team-123`
"""
scalar Slug

enum SortOrder {
  """Ascending sort order."""
  ASC

  """Descending sort order."""
  DESC
}

type SqlDatabase implements Persistence {
  charset: String!
  collation: String!
  conditions: [Condition!]!
  deletionPolicy: String!
  healthy: Boolean!
  id: ID!
  name: String!
}

type SqlInstance implements Persistence {
  backupConfiguration: BackupConfiguration!
  cascadingDelete: Boolean!
  connectionName: String!
  database: SqlDatabase
  diskAutoresize: Boolean!
  diskAutoresizeLimit: Int!
  env: Env!
  flags: [Flag!]!
  highAvailability: Boolean!
  id: ID!
  isHealthy: Boolean!
  maintenanceVersion: String
  maintenanceWindow: MaintenanceWindow
  metrics: SqlInstanceMetrics!
  name: String!
  projectId: String!
  state: SqlInstanceState!
  status: SqlInstanceStatus!
  team: Team!
  tier: String!
  type: String!
  users: [SqlUser!]!
  workload: Workload
}

type SqlInstanceCpu {
  cores: Float!
  utilization: Float!
}

type SqlInstanceDisk {
  quotaBytes: Int!
  utilization: Float!
}

type SqlInstanceMemory {
  quotaBytes: Int!
  utilization: Float!
}

type SqlInstanceMetrics {
  cost: Float!
  cpu: SqlInstanceCpu!
  disk: SqlInstanceDisk!
  memory: SqlInstanceMemory!
}

enum SqlInstanceState {
  FAILED
  MAINTENANCE
  PENDING_CREATE
  PENDING_DELETE
  RUNNABLE
  SQL_INSTANCE_STATE_UNSPECIFIED
  SUSPENDED
}

type SqlInstanceStatus {
  conditions: [Condition!]!
  privateIpAddress: String
  publicIpAddress: String
}

type SqlInstancesList {
  metrics: SqlInstancesMetrics!
  nodes: [SqlInstance!]!
  pageInfo: PageInfo!
}

type SqlInstancesMetrics {
  cost: Float!
  cpu: SqlInstanceCpu!
  disk: SqlInstanceDisk!
  memory: SqlInstanceMemory!
}

type SqlInstancesStatus {
  failing: Int!
  otherConditions: Int!
  total: Int!
}

type SqlUser {
  authentication: String!
  name: String!
}

enum State {
  FAILING
  NAIS
  NOTNAIS
  UNKNOWN
}

interface StateError {
  level: ErrorLevel!
  revision: String!
}

type Subscription {
  log(input: LogSubscriptionInput): LogLine!
}

"""Sync error type."""
type SyncError {
  """Creation time of the error."""
  createdAt: Time!

  """Error message."""
  error: String!

  """The name of the reconciler."""
  reconciler: String!
}

type SynchronizationFailingError implements StateError {
  detail: String!
  level: ErrorLevel!
  revision: String!
}

"""Team type."""
type Team {
  """Current application utilization data"""
  appUtilization(resourceType: UsageResourceType!): [UtilizationData!]!

  """The NAIS applications owned by the team."""
  apps(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): AppList!

  """Audit events for this team."""
  auditEvents(
    """Filter audit events."""
    filter: AuditEventsFilter

    """Limit the number of audit events to return. Default is 20."""
    limit: Int

    """Offset to start listing audit events from. Default is 0."""
    offset: Int
  ): AuditEventList!

  """Audit logs for this team."""
  auditLogs(
    """Limit the number of audit log entries to return. Default is 20."""
    limit: Int

    """Offset to start listing audit log entries from. Default is 0."""
    offset: Int
  ): AuditLogList!

  """
  The ID of the Azure AD group for the team. This value is managed by the Azure AD reconciler.
  """
  azureGroupID: ID
  bigQuery(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): BigQueryDatasetList!

  """Get a BigQueryDataset by name and env."""
  bigQueryDataset(
    """The environment the dataset exists in."""
    env: String!

    """The name of the dataset."""
    name: String!
  ): BigQueryDataset!

  """Get a Bucket by name and env."""
  bucket(
    """The environment the bucket exists in."""
    env: String!

    """The name of the bucket."""
    name: String!
  ): Bucket!
  buckets(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): BucketsList!

  """The CDN bucket for the team."""
  cdnBucket: String

  """Whether or not the team is currently being deleted."""
  deletionInProgress: Boolean!

  """The deploy key of the team."""
  deployKey: DeploymentKey!

  """The deployments of the team's applications."""
  deployments(
    """Limit the number of entries returned."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int
  ): DeploymentList!

  """The environments available for the team."""
  environments: [Env!]!

  """
  The slug of the GitHub team. This value is managed by the GitHub reconciler.
  """
  gitHubTeamSlug: String

  """The GitHub repositories that the team has access to."""
  githubRepositories(
    """Filter the repositories."""
    filter: GitHubRepositoriesFilter

    """Limit the number of repositories to return. Default is 20."""
    limit: Int

    """Offset to start listing repositories from. Default is 0."""
    offset: Int
  ): GitHubRepositoryList!

  """The Google artifact registry for the team."""
  googleArtifactRegistry: String

  """
  The email address of the Google group for the team. This value is managed by the Google Workspace reconciler.
  """
  googleGroupEmail: String
  id: ID!

  """Get a Kafka topic by name and env."""
  kafkaTopic(
    """The environment the topic exists in."""
    env: String!

    """The name of the topic."""
    name: String!
  ): KafkaTopic!
  kafkaTopics(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): KafkaTopicList!

  """Timestamp of the last successful synchronization of the team."""
  lastSuccessfulSync: Time

  """Single team member"""
  member(
    """The ID of the user."""
    userId: ID!
  ): TeamMember!

  """Team members."""
  members(
    """Limit the number of team members to return. Default is 20."""
    limit: Int

    """Offset to start listing team members from. Default is 0."""
    offset: Int
  ): TeamMemberList!

  """The NAIS jobs owned by the team."""
  naisjobs(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): NaisJobList!
  openSearch(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): OpenSearchList!

  """Get a OpenSearch instance by name and env."""
  openSearchInstance(
    """The environment the instance exists in."""
    env: String!

    """The name of the OpenSearch instance."""
    name: String!
  ): OpenSearch!

  """Purpose of the team."""
  purpose: String!
  redis(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): RedisList!

  """Get a Redis instance by name and env."""
  redisInstance(
    """The environment the instance exists in."""
    env: String!

    """The name of the Redis instance."""
    name: String!
  ): Redis!
  repositories(
    """Limit the number of repositories to return. Default is 20."""
    limit: Int

    """Offset to start listing repositories from. Default is 0."""
    offset: Int
  ): RepositoryList!

  """Get the team's secret by name, and env."""
  secret(
    """The environment the secret is deployed to."""
    env: String!

    """The name of the secret."""
    name: String!
  ): Secret!

  """Get all secrets for the team."""
  secrets: [Secret!]!

  """Slack channel for the team."""
  slackChannel: String!

  """Unique slug of the team."""
  slug: Slug!

  """Get an SQL instance by name and env."""
  sqlInstance(
    """The environment the instance runs in."""
    env: String!

    """The name of the instance."""
    name: String!
  ): SqlInstance!
  sqlInstances(
    """Returns the last n entries from the list."""
    limit: Int

    """Returns the first n entries from the list."""
    offset: Int

    """Order entries by"""
    orderBy: OrderBy
  ): SqlInstancesList!

  """The status of the team."""
  status: TeamStatus!

  """
  Possible issues related to synchronization of the team to configured external systems. If there are no entries the team can be considered fully synchronized.
  """
  syncErrors: [SyncError!]!
  unleash: Unleash!

  """Whether or not the viewer is a member of the team."""
  viewerIsMember: Boolean!

  """Whether or not the viewer is an owner of the team."""
  viewerIsOwner: Boolean!
  vulnerabilitiesSummary: VulnerabilitySummaryForTeam!
}

"""Team deletion key type."""
type TeamDeleteKey {
  """The creation timestamp of the key."""
  createdAt: Time!

  """The user who created the key."""
  createdBy: User!

  """Expiration timestamp of the key."""
  expires: Time!

  """The unique key used to confirm the deletion of a team."""
  key: String!

  """The team the delete key is for."""
  team: Team!
}

"""Paginated teams type."""
type TeamList {
  """The list of teams."""
  nodes: [Team!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Team member."""
type TeamMember {
  """Reconcilers for this member in this team."""
  reconcilers: [TeamMemberReconciler!]!

  """The role that the user has in the team."""
  role: TeamRole!

  """Team instance."""
  team: Team!

  """User instance."""
  user: User!
}

"""Team member input."""
input TeamMemberInput {
  """Reconcilers to opt the team member out of."""
  reconcilerOptOuts: [String!]

  """The role that the user will receive."""
  role: TeamRole!

  """The ID of user."""
  userId: ID!
}

type TeamMemberList {
  nodes: [TeamMember!]!
  pageInfo: PageInfo!
}

"""Team member reconcilers."""
type TeamMemberReconciler {
  """Whether or not the reconciler is enabled for the team member."""
  enabled: Boolean!

  """The reconciler."""
  reconciler: Reconciler!
}

"""Available team roles."""
enum TeamRole {
  """Regular member, read only access."""
  MEMBER

  """Team owner, full access to the team."""
  OWNER
}

"""Team status."""
type TeamStatus {
  apps: AppsStatus!
  jobs: JobsStatus!
  sqlInstances: SqlInstancesStatus!
}

"""Team sync type."""
type TeamSync {
  """The correlation ID for the sync."""
  correlationID: ID!
}

type TeamUtilizationData {
  """The name of the team."""
  name: String!

  """The requested amount of resources"""
  requested: Float!

  """The current resource usage."""
  used: Float!
}

"""Input for filtering teams."""
input TeamsFilter {
  github: TeamsFilterGitHub
}

input TeamsFilterGitHub {
  """Filter repostiories by permission name"""
  permissionName: String!

  """Filter repostiories by repo name"""
  repoName: String!
}

"""
Time is a string in [RFC 3339](https://rfc-editor.org/rfc/rfc3339.html) format, with sub-second precision added if present. E.g. `2024-09-06T13:37:00Z`.
"""
scalar Time

type TokenX {
  mountSecretsAsFilesOnly: Boolean!
}

type Unleash {
  """If Unleash feature is enabled for this tenant"""
  enabled: Boolean!
  instance: UnleashInstance
}

type UnleashInstance {
  allowedTeams: [String!]!
  apiIngress: String!
  metrics: UnleashMetrics!
  name: String!
  ready: Boolean!
  version: String!
  webIngress: String!
}

type UnleashMetrics {
  apiTokens: Int!
  cpuRequests: Float!
  cpuUtilization: Float!
  memoryRequests: Float!
  memoryUtilization: Float!
  toggles: Int!
}

"""Input for updating an existing team."""
input UpdateTeamInput {
  """Specify team purpose to update the existing value."""
  purpose: String

  """Specify the Slack channel to update the existing value."""
  slackChannel: String
}

"""Slack alerts channel input."""
input UpdateTeamSlackAlertsChannelInput {
  """The name of the Slack channel."""
  channelName: String

  """The environment for the alerts sent to the channel."""
  environment: String!
}

"""Resource utilization type."""
type UsageDataPoint {
  """Timestamp of the value."""
  timestamp: Time!

  """Value of the used resource at the given timestamp."""
  value: Float!
}

"""Resource type."""
enum UsageResourceType {
  CPU
  MEMORY
}

"""User type."""
type User {
  """The email address of the user."""
  email: String!

  """The external ID of the user."""
  externalId: String!

  """Unique ID of the user."""
  id: ID!

  """This field will only be populated via the me query"""
  isAdmin: Boolean

  """The name of the user."""
  name: String!

  """Roles attached to the user."""
  roles: [Role!]!

  """List of team memberships."""
  teams(limit: Int, offset: Int): TeamMemberList!
}

type UserList {
  nodes: [User!]!
  pageInfo: PageInfo!
}

"""User sync run type."""
type UsersyncRun {
  """Log entries for the sync run."""
  auditLogs(limit: Int, offset: Int): AuditLogList!

  """Optional error."""
  error: String

  """Timestamp of when the run finished."""
  finishedAt: Time!

  """The ID of the sync run."""
  id: ID!

  """Timestamp of when the run started."""
  startedAt: Time!

  """The status of the sync run."""
  status: UsersyncRunStatus!
}

type UsersyncRunList {
  nodes: [UsersyncRun!]!
  pageInfo: PageInfo!
}

"""User sync run status."""
enum UsersyncRunStatus {
  """Failed user sync run."""
  FAILURE

  """Successful user sync run."""
  SUCCESS
}

"""Utilization data type."""
type UtilizationData {
  """The environment the resource is running in."""
  env: String!

  """The name of the resource."""
  name: String!

  """The requested amount of resources"""
  requested: Float!

  """The current resource usage."""
  used: Float!
}

type Variable {
  name: String!
  value: String!
}

input VariableInput {
  name: String!
  value: String!
}

type VulnIdAlias {
  name: String!
  source: String!
}

type Vulnerability {
  appName: String!
  env: String!
  findingsLink: String!
  hasBom: Boolean!
  id: ID!
  summary: VulnerabilitySummaryForTeam
}

type VulnerabilitySummaryForTeam {
  bomCount: Int!
  coverage: Float!
  critical: Int!
  high: Int!
  low: Int!
  medium: Int!
  riskScore: Int!
  unassigned: Int!
}

interface Workload {
  accessPolicy: AccessPolicy!
  authz: [Authz!]!
  deployInfo: DeployInfo!
  env: Env!
  id: ID!
  image: String!
  name: String!
  persistence: [Persistence!]!
  resources: Resources!
  status: WorkloadStatus!
  team: Team!
  type: WorkloadType!
  variables: [Variable!]!
}

type WorkloadStatus {
  errors: [StateError!]!
  state: State!
}

enum WorkloadType {
  APP
  NAISJOB
}
