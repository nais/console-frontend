"""
Directs the executor to defer this fragment when the `if` argument is true or undefined.
"""
directive @defer(
  """Deferred when true or undefined."""
  if: Boolean = true

  """Unique name"""
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

enum ActivityLogActivityType {
  """An application was deleted."""
  APPLICATION_DELETED

  """An application was restarted."""
  APPLICATION_RESTARTED

  """An application was scaled."""
  APPLICATION_SCALED

  """All activity log entries related to direct cluster changes."""
  CLUSTER_AUDIT

  """Activity log entry for deployment activity."""
  DEPLOYMENT

  """Activity log entries related to job deletion."""
  JOB_DELETED

  """Activity log entries related to job triggering."""
  JOB_TRIGGERED

  """OpenSearch was created."""
  OPENSEARCH_CREATED

  """OpenSearch was deleted."""
  OPENSEARCH_DELETED

  """Started service maintenance on OpenSearch instance."""
  OPENSEARCH_MAINTENANCE_STARTED

  """OpenSearch was updated."""
  OPENSEARCH_UPDATED

  """A user was granted access to a Postgres cluster"""
  POSTGRES_GRANT_ACCESS

  """Reconciler configured activity log entry."""
  RECONCILER_CONFIGURED

  """Reconciler disabled activity log entry."""
  RECONCILER_DISABLED

  """Reconciler enabled activity log entry."""
  RECONCILER_ENABLED

  """Repository was added to a team."""
  REPOSITORY_ADDED

  """Repository was removed from a team."""
  REPOSITORY_REMOVED

  """Secret was created."""
  SECRET_CREATED

  """Secret was deleted."""
  SECRET_DELETED

  """Secret values were viewed."""
  SECRET_VALUES_VIEWED

  """Secret value was added."""
  SECRET_VALUE_ADDED

  """Secret value was removed."""
  SECRET_VALUE_REMOVED

  """Secret value was updated."""
  SECRET_VALUE_UPDATED

  """Service account was created."""
  SERVICE_ACCOUNT_CREATED

  """Service account was deleted."""
  SERVICE_ACCOUNT_DELETED

  """Role was assigned to a service account."""
  SERVICE_ACCOUNT_ROLE_ASSIGNED

  """Role was revoked from a service account."""
  SERVICE_ACCOUNT_ROLE_REVOKED

  """Service account token was created."""
  SERVICE_ACCOUNT_TOKEN_CREATED

  """Service account token was deleted."""
  SERVICE_ACCOUNT_TOKEN_DELETED

  """Service account token was updated."""
  SERVICE_ACCOUNT_TOKEN_UPDATED

  """Service account was updated."""
  SERVICE_ACCOUNT_UPDATED

  """Team delete key was confirmed."""
  TEAM_CONFIRM_DELETE_KEY

  """Team was created."""
  TEAM_CREATED

  """Team delete key was created."""
  TEAM_CREATE_DELETE_KEY

  """Activity log entry for team deploy key updates."""
  TEAM_DEPLOY_KEY_UPDATED

  """Team environment was updated."""
  TEAM_ENVIRONMENT_UPDATED

  """Team member was added."""
  TEAM_MEMBER_ADDED

  """Team member was removed."""
  TEAM_MEMBER_REMOVED

  """Team member role was set."""
  TEAM_MEMBER_SET_ROLE

  """Team was updated."""
  TEAM_UPDATED

  """Unleash instance was created."""
  UNLEASH_INSTANCE_CREATED

  """Unleash instance was deleted."""
  UNLEASH_INSTANCE_DELETED

  """Unleash instance was updated."""
  UNLEASH_INSTANCE_UPDATED

  """Valkey was created."""
  VALKEY_CREATED

  """Valkey was deleted."""
  VALKEY_DELETED

  """Started service maintenance on Valkey instance."""
  VALKEY_MAINTENANCE_STARTED

  """Valkey was updated."""
  VALKEY_UPDATED

  """Activity log entry for when a vulnerability is updated."""
  VULNERABILITY_UPDATED
}

"""Interface for activity log entries."""
interface ActivityLogEntry {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

"""Activity log connection."""
type ActivityLogEntryConnection {
  """List of edges."""
  edges: [ActivityLogEntryEdge!]!

  """List of nodes."""
  nodes: [ActivityLogEntry!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Activity log edge."""
type ActivityLogEntryEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The log entry."""
  node: ActivityLogEntry!
}

"""The type of the resource that was affected by the activity."""
enum ActivityLogEntryResourceType {
  """
  All activity log entries related to applications will use this resource type.
  """
  APP

  """All activity log entries related to direct cluster changes."""
  CLUSTER_AUDIT

  """
  All activity log entries related to deploy keys will use this resource type.
  """
  DEPLOY_KEY

  """All activity log entries related to jobs will use this resource type."""
  JOB

  """
  All activity log entries related to OpenSearches will use this resource type.
  """
  OPENSEARCH

  """
  All activity log entries related to Postgres clusters will use this resource type.
  """
  POSTGRES

  """
  All activity log entries related to reconcilers will use this resource type.
  """
  RECONCILER

  """
  All activity log entries related to repositories will use this resource type.
  """
  REPOSITORY

  """
  All activity log entries related to secrets will use this resource type.
  """
  SECRET
  SERVICE_ACCOUNT

  """All activity log entries related to teams will use this resource type."""
  TEAM

  """Unknown type."""
  UNKNOWN

  """
  All activity log entries related to unleash will use this resource type.
  """
  UNLEASH

  """
  All activity log entries related to Valkeys will use this resource type.
  """
  VALKEY

  """
  All activity log entries related to vulnerabilities will use this resource type.
  """
  VULNERABILITY
}

input ActivityLogFilter {
  activityTypes: [ActivityLogActivityType!]
}

interface ActivityLogger {
  """Activity log associated with the type."""
  activityLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter items."""
    filter: ActivityLogFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ActivityLogEntryConnection!
}

input AddRepositoryToTeamInput {
  """Name of the repository, with the org prefix, for instance 'org/repo'."""
  repositoryName: String!

  """Slug of the team to add the repository to."""
  teamSlug: Slug!
}

type AddRepositoryToTeamPayload {
  """Repository that was added to the team."""
  repository: Repository
}

input AddSecretValueInput {
  """The environment the secret exists in."""
  environment: String!

  """The name of the secret."""
  name: String!

  """The team that owns the secret."""
  team: Slug!

  """The secret value to set."""
  value: SecretValueInput!
}

type AddSecretValuePayload {
  """The updated secret."""
  secret: Secret
}

input AddTeamMemberInput {
  """The role that the user will have in the team."""
  role: TeamMemberRole!

  """Slug of the team that should receive a new member."""
  teamSlug: Slug!

  """The email address of the user to add to the team."""
  userEmail: String!
}

type AddTeamMemberPayload {
  """The added team member."""
  member: TeamMember
}

"""Alert interface."""
interface Alert {
  """
  The time in seconds the alert condition must be met before it activates.
  """
  duration: Float!

  """The unique identifier of the alert."""
  id: ID!

  """The name of the alert."""
  name: String!

  """The query or expression evaluated for the alert."""
  query: String!

  """The current state of the alert (e.g. FIRING, PENDING, INACTIVE)."""
  state: AlertState!

  """The team responsible for the alert."""
  team: Team!

  """The team environment associated with the alert."""
  teamEnvironment: TeamEnvironment!
}

"""AlertConnection connection."""
type AlertConnection {
  """List of edges."""
  edges: [AlertEdge!]!

  """List of nodes."""
  nodes: [Alert!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Alert edge."""
type AlertEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The Alert."""
  node: Alert!
}

"""Ordering options when fetching alerts."""
input AlertOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: AlertOrderField!
}

"""Fields to order alerts in an environment by."""
enum AlertOrderField {
  """ENVIRONMENT"""
  ENVIRONMENT

  """Order by name."""
  NAME

  """Order by state."""
  STATE
}

enum AlertState {
  """Only return alerts that are firing."""
  FIRING

  """Only return alerts that are inactive."""
  INACTIVE

  """Only return alerts that are pending."""
  PENDING
}

input AllowTeamAccessToUnleashInput {
  allowedTeamSlug: Slug!
  teamSlug: Slug!
}

type AllowTeamAccessToUnleashPayload {
  unleash: UnleashInstance
}

"""
An application lets you run one or more instances of a container image on the [Nais platform](https://nais.io/).

Learn more about how to create and configure your applications in the [Nais documentation](https://docs.nais.io/workloads/application/).
"""
type Application implements ActivityLogger & Node & Workload {
  """Activity log associated with the application."""
  activityLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter items."""
    filter: ActivityLogFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ActivityLogEntryConnection!

  """List of authentication and authorization for the application."""
  authIntegrations: [ApplicationAuthIntegrations!]!

  """
  BigQuery datasets referenced by the application. This does not currently support pagination, but will return all available datasets.
  """
  bigQueryDatasets(
    """Ordering options for items returned from the connection."""
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """
  Google Cloud Storage referenced by the application. This does not currently support pagination, but will return all available buckets.
  """
  buckets(
    """Ordering options for items returned from the connection."""
    orderBy: BucketOrder
  ): BucketConnection!

  """The cost for the application."""
  cost: WorkloadCost!

  """If set, when the application was marked for deletion."""
  deletionStartedAt: Time

  """List of deployments for the application."""
  deployments(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): DeploymentConnection!

  """The environment the application is deployed in."""
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")

  """The globally unique ID of the application."""
  id: ID!

  """The container image of the application."""
  image: ContainerImage!

  """Get the vulnerability summary history for application."""
  imageVulnerabilityHistory(
    """Get vulnerability summary from given date until today."""
    from: Date!
  ): ImageVulnerabilityHistory!

  """List of ingresses for the application."""
  ingresses: [Ingress!]!

  """The application instances."""
  instances(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ApplicationInstanceConnection!

  """Issues that affects the workload."""
  issues(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filtering options for items returned from the connection."""
    filter: ResourceIssueFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: IssueOrder
  ): IssueConnection!

  """
  Kafka topics the application has access to. This does not currently support pagination, but will return all available Kafka topics.
  """
  kafkaTopicAcls(
    """Ordering options for items returned from the connection."""
    orderBy: KafkaTopicAclOrder
  ): KafkaTopicAclConnection!

  """List of log destinations for the application."""
  logDestinations: [LogDestination!]!

  """The application manifest."""
  manifest: ApplicationManifest!

  """The name of the application."""
  name: String!

  """Network policies for the application."""
  networkPolicy: NetworkPolicy!

  """OpenSearch instance referenced by the workload."""
  openSearch: OpenSearch

  """
  Postgres instances referenced by the application. This does not currently support pagination, but will return all available Postgres instances.
  """
  postgresInstances(
    """Ordering options for items returned from the connection."""
    orderBy: PostgresInstanceOrder
  ): PostgresInstanceConnection!

  """Resources for the application."""
  resources: ApplicationResources!

  """Secrets used by the application."""
  secrets(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): SecretConnection!

  """
  SQL instances referenced by the application. This does not currently support pagination, but will return all available SQL instances.
  """
  sqlInstances(
    """Ordering options for items returned from the connection."""
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!

  """The application state."""
  state: ApplicationState!

  """The team that owns the application."""
  team: Team!

  """The team environment for the application."""
  teamEnvironment: TeamEnvironment!
  utilization: WorkloadUtilization!

  """
  Valkey instances referenced by the application. This does not currently support pagination, but will return all available Valkey instances.
  """
  valkeys(
    """Ordering options for items returned from the connection."""
    orderBy: ValkeyOrder
  ): ValkeyConnection!

  """Get the mean time to fix history for an application."""
  vulnerabilityFixHistory(from: Date!): VulnerabilityFixHistory!
}

"""Authentication integrations for the application."""
union ApplicationAuthIntegrations = EntraIDAuthIntegration | IDPortenAuthIntegration | MaskinportenAuthIntegration | TokenXAuthIntegration

"""Application connection."""
type ApplicationConnection {
  """List of edges."""
  edges: [ApplicationEdge!]!

  """List of nodes."""
  nodes: [Application!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type ApplicationDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

"""Application edge."""
type ApplicationEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The application."""
  node: Application!
}

type ApplicationInstance implements Node {
  created: Time!
  id: ID!
  image: ContainerImage!
  instanceUtilization(resourceType: UtilizationResourceType!): ApplicationInstanceUtilization!
  name: String!
  restarts: Int!
  status: ApplicationInstanceStatus!
}

type ApplicationInstanceConnection {
  """List of edges."""
  edges: [ApplicationInstanceEdge!]!

  """List of nodes."""
  nodes: [ApplicationInstance!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type ApplicationInstanceEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The instance."""
  node: ApplicationInstance!
}

enum ApplicationInstanceState {
  FAILING
  RUNNING
  STARTING
  UNKNOWN
}

type ApplicationInstanceStatus {
  message: String!
  state: ApplicationInstanceState!
}

type ApplicationInstanceUtilization {
  """Get the current usage for the requested resource type."""
  current: Float!
}

"""The manifest that describes the application."""
type ApplicationManifest implements WorkloadManifest {
  """The manifest content, serialized as a YAML document."""
  content: String!
}

"""Ordering options when fetching applications."""
input ApplicationOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: ApplicationOrderField!
}

"""Fields to order applications by."""
enum ApplicationOrderField {
  """Order applications by the deployment time."""
  DEPLOYMENT_TIME

  """Order applications by the name of the environment."""
  ENVIRONMENT

  """Order applications by issue severity"""
  ISSUES

  """Order applications by name."""
  NAME

  """Order applications by state."""
  STATE
}

type ApplicationResources implements WorkloadResources {
  """Instances using resources above this threshold will be killed."""
  limits: WorkloadResourceQuantity!

  """How many resources are allocated to each instance."""
  requests: WorkloadResourceQuantity!

  """Scaling strategies for the application."""
  scaling: ApplicationScaling!
}

type ApplicationRestartedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type ApplicationScaledActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the update."""
  data: ApplicationScaledActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type ApplicationScaledActivityLogEntryData {
  direction: ScalingDirection!
  newSize: Int!
}

"""The scaling configuration of an application."""
type ApplicationScaling {
  """The maximum number of application instances."""
  maxInstances: Int!

  """The minimum number of application instances."""
  minInstances: Int!

  """Scaling strategies for the application."""
  strategies: [ScalingStrategy!]!
}

enum ApplicationState {
  """The application is not running."""
  NOT_RUNNING

  """The application is running."""
  RUNNING

  """The application state is unknown."""
  UNKNOWN
}

input AssignRoleToServiceAccountInput {
  """The name of the role to assign."""
  roleName: String!

  """The ID of the service account to assign the role to."""
  serviceAccountID: ID!
}

type AssignRoleToServiceAccountPayload {
  """The service account that had a role assigned."""
  serviceAccount: ServiceAccount
}

type AuditLog {
  """Link to the audit log for this SQL instance."""
  logUrl: String!
}

"""
Interface for authentication and authorization integrations.

Read more about this topic in the [Nais documentation](https://docs.nais.io/auth/).
"""
interface AuthIntegration {
  """The name of the integration."""
  name: String!
}

"""Authenticated user type."""
union AuthenticatedUser = ServiceAccount | User

type BigQueryDataset implements Node & Persistence {
  access(after: Cursor, before: Cursor, first: Int, last: Int, orderBy: BigQueryDatasetAccessOrder): BigQueryDatasetAccessConnection!
  cascadingDelete: Boolean!
  cost: BigQueryDatasetCost!
  description: String
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
  id: ID!
  name: String!
  status: BigQueryDatasetStatus!
  team: Team!
  teamEnvironment: TeamEnvironment!
  workload: Workload
}

type BigQueryDatasetAccess {
  email: String!
  role: String!
}

type BigQueryDatasetAccessConnection {
  edges: [BigQueryDatasetAccessEdge!]!
  nodes: [BigQueryDatasetAccess!]!
  pageInfo: PageInfo!
}

type BigQueryDatasetAccessEdge {
  cursor: Cursor!
  node: BigQueryDatasetAccess!
}

input BigQueryDatasetAccessOrder {
  direction: OrderDirection!
  field: BigQueryDatasetAccessOrderField!
}

enum BigQueryDatasetAccessOrderField {
  EMAIL
  ROLE
}

type BigQueryDatasetConnection {
  edges: [BigQueryDatasetEdge!]!
  nodes: [BigQueryDataset!]!
  pageInfo: PageInfo!
}

type BigQueryDatasetCost {
  sum: Float!
}

type BigQueryDatasetEdge {
  cursor: Cursor!
  node: BigQueryDataset!
}

input BigQueryDatasetOrder {
  direction: OrderDirection!
  field: BigQueryDatasetOrderField!
}

enum BigQueryDatasetOrderField {
  ENVIRONMENT
  NAME
}

type BigQueryDatasetStatus {
  creationTime: Time!
  lastModifiedTime: Time
}

type Bucket implements Node & Persistence {
  cascadingDelete: Boolean!
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
  id: ID!
  name: String!
  publicAccessPrevention: String!
  team: Team!
  teamEnvironment: TeamEnvironment!
  uniformBucketLevelAccess: Boolean!
  workload: Workload
}

type BucketConnection {
  edges: [BucketEdge!]!
  nodes: [Bucket!]!
  pageInfo: PageInfo!
}

type BucketEdge {
  cursor: Cursor!
  node: Bucket!
}

input BucketOrder {
  direction: OrderDirection!
  field: BucketOrderField!
}

enum BucketOrderField {
  ENVIRONMENT
  NAME
}

"""
A scaling strategy based on CPU usage

Read more: https://docs.nais.io/workloads/application/reference/automatic-scaling/#cpu-based-scaling
"""
type CPUScalingStrategy {
  """The threshold that must be met for the scaling to trigger."""
  threshold: Int!
}

type CVE implements Node {
  """CVSS score of the CVE."""
  cvssScore: Float

  """Description of the CVE."""
  description: String!

  """Link to the CVE details."""
  detailsLink: String!

  """The globally unique ID of the CVE."""
  id: ID!

  """The unique identifier of the CVE. E.g. CVE-****-****."""
  identifier: String!

  """Severity of the CVE."""
  severity: ImageVulnerabilitySeverity!

  """Title of the CVE"""
  title: String!

  """Affected workloads"""
  workloads(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): WorkloadWithVulnerabilityConnection!
}

type CVEConnection {
  """List of edges."""
  edges: [CVEEdge!]!

  """List of nodes."""
  nodes: [CVE!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type CVEEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The CVE."""
  node: CVE!
}

"""Ordering options when fetching CVEs."""
input CVEOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: CVEOrderField!
}

enum CVEOrderField {
  AFFECTED_WORKLOADS_COUNT
  CVSS_SCORE
  IDENTIFIER
  SEVERITY
}

input ChangeDeploymentKeyInput {
  """The name of the team to update the deploy key for."""
  teamSlug: Slug!
}

type ChangeDeploymentKeyPayload {
  """The updated deploy key."""
  deploymentKey: DeploymentKey
}

type ClusterAuditActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: ClusterAuditActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type ClusterAuditActivityLogEntryData {
  """The action that was performed."""
  action: String!

  """The kind of resource that was affected by the action."""
  resourceKind: String!
}

input ConfigureReconcilerInput {
  """List of reconciler config inputs."""
  config: [ReconcilerConfigInput!]!

  """The name of the reconciler to configure."""
  name: String!
}

input ConfirmTeamDeletionInput {
  """Deletion key, acquired using the requestTeamDeletion mutation."""
  key: String!

  """Slug of the team to confirm deletion for."""
  slug: Slug!
}

type ConfirmTeamDeletionPayload {
  """Whether or not the asynchronous deletion process was started."""
  deletionStarted: Boolean
}

"""Container image."""
type ContainerImage implements ActivityLogger & Node {
  """Activity log associated with the container image."""
  activityLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter items."""
    filter: ActivityLogFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ActivityLogEntryConnection!

  """
  Whether the image has a software bill of materials (SBOM) attached to it.
  """
  hasSBOM: Boolean!

  """The globally unique ID of the container image node."""
  id: ID!

  """Name of the container image."""
  name: String!

  """Tag of the container image."""
  tag: String!

  """Get the vulnerabilities of the image."""
  vulnerabilities(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter the vulnerabilities."""
    filter: ImageVulnerabilityFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: ImageVulnerabilityOrder
  ): ImageVulnerabilityConnection!

  """Get the summary of the vulnerabilities of the image."""
  vulnerabilitySummary: ImageVulnerabilitySummary

  """Workloads using this container image."""
  workloadReferences(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ContainerImageWorkloadReferenceConnection!
}

type ContainerImageWorkloadReference {
  """The workload using the container image."""
  workload: Workload!
}

type ContainerImageWorkloadReferenceConnection {
  """List of edges."""
  edges: [ContainerImageWorkloadReferenceEdge!]!

  """List of nodes."""
  nodes: [ContainerImageWorkloadReference!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type ContainerImageWorkloadReferenceEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The workload reference."""
  node: ContainerImageWorkloadReference!
}

type CostMonthlySummary {
  """The cost series."""
  series: [ServiceCostSeries!]!
}

input CreateOpenSearchInput {
  """The environment name that the OpenSearch instance belongs to."""
  environmentName: String!

  """Available memory for the OpenSearch instance."""
  memory: OpenSearchMemory!

  """Name of the OpenSearch instance."""
  name: String!

  """Available storage in GB."""
  storageGB: Int!

  """The team that owns the OpenSearch instance."""
  teamSlug: Slug!

  """Tier of the OpenSearch instance."""
  tier: OpenSearchTier!

  """Major version of the OpenSearch instance."""
  version: OpenSearchMajorVersion!
}

type CreateOpenSearchPayload {
  """OpenSearch instance that was created."""
  openSearch: OpenSearch!
}

input CreateSecretInput {
  """The environment the secret exists in."""
  environment: String!

  """The name of the secret."""
  name: String!

  """The team that owns the secret."""
  team: Slug!
}

type CreateSecretPayload {
  """The created secret."""
  secret: Secret
}

input CreateServiceAccountInput {
  """A description of the service account."""
  description: String!

  """The name of the service account."""
  name: String!

  """The team slug that the service account belongs to."""
  teamSlug: Slug
}

type CreateServiceAccountPayload {
  """The created service account."""
  serviceAccount: ServiceAccount
}

input CreateServiceAccountTokenInput {
  """The description of the service account token."""
  description: String!

  """
  Optional expiry date of the token.
  
  If not specified, the token will never expire.
  """
  expiresAt: Date

  """The name of the service account token."""
  name: String!

  """The ID of the service account to create the token for."""
  serviceAccountID: ID!
}

type CreateServiceAccountTokenPayload {
  """
  The secret of the service account token.
  
  This value is only returned once, and can not be retrieved at a later stage. If the secret is lost, a new token must be created.
  
  Once obtained, the secret can be used to authenticate as the service account using the HTTP `Authorization` request header:
  
  ```
  Authorization: Bearer <secret>
  ```
  """
  secret: String

  """The service account that the token belongs to."""
  serviceAccount: ServiceAccount

  """The created service account token."""
  serviceAccountToken: ServiceAccountToken
}

input CreateTeamInput {
  """
  The purpose / description of the team.
  
  What is the team for? What is the team working on? This value is meant for human consumption, and should be enough
  to give a newcomer an idea of what the team is about.
  """
  purpose: String!

  """
  The main Slack channel for the team.
  
  Where does the team communicate? This value is used to link to the team's main Slack channel.
  """
  slackChannel: String!

  """
  Unique team slug.
  
  After creation, this value can not be changed. Also, after a potential deletion of the team, the slug can not be
  reused, so please choose wisely.
  """
  slug: Slug!
}

type CreateTeamPayload {
  """The newly created team."""
  team: Team
}

input CreateUnleashForTeamInput {
  """
  Subscribe the instance to a release channel for automatic version updates.
  If not specified, the default version will be used.
  Use the unleashReleaseChannels query to see available channels.
  """
  releaseChannel: String

  """The team that will own this Unleash instance."""
  teamSlug: Slug!
}

type CreateUnleashForTeamPayload {
  unleash: UnleashInstance
}

input CreateValkeyInput {
  """The environment name that the entry belongs to."""
  environmentName: String!

  """Maximum memory policy for the Valkey instance."""
  maxMemoryPolicy: ValkeyMaxMemoryPolicy

  """Available memory for the Valkey instance."""
  memory: ValkeyMemory!

  """Name of the Valkey instance."""
  name: String!

  """
  Configure keyspace notifications for the Valkey instance. See https://valkey.io/topics/notifications/ for details.
  """
  notifyKeyspaceEvents: String

  """The team that owns the Valkey instance."""
  teamSlug: Slug!

  """Tier of the Valkey instance."""
  tier: ValkeyTier!
}

type CreateValkeyPayload {
  """Valkey instance that was created."""
  valkey: Valkey!
}

"""Get current unit prices."""
type CurrentUnitPrices {
  """Current price for one CPU hour."""
  cpu: Price!

  """Current price for one GB hour of memory."""
  memory: Price!
}

"""
A cursor for use in pagination

Cursors are opaque strings that are returned by the server for paginated results, and used when performing backwards / forwards pagination.
"""
scalar Cursor

"""Date type in YYYY-MM-DD format."""
scalar Date

input DeleteApplicationInput {
  """Name of the environment where the application runs."""
  environmentName: String!

  """Name of the application."""
  name: String!

  """Slug of the team that owns the application."""
  teamSlug: Slug!
}

type DeleteApplicationPayload {
  """Whether or not the application was deleted."""
  success: Boolean

  """The team that owned the deleted application."""
  team: Team
}

input DeleteJobInput {
  """Name of the environment where the job runs."""
  environmentName: String!

  """Name of the job."""
  name: String!

  """Slug of the team that owns the job."""
  teamSlug: Slug!
}

type DeleteJobPayload {
  """Whether or not the job was deleted."""
  success: Boolean

  """The team that owned the deleted job."""
  team: Team
}

input DeleteOpenSearchInput {
  """The environment name that the OpenSearch instance belongs to."""
  environmentName: String!

  """Name of the OpenSearch instance."""
  name: String!

  """The team that owns the OpenSearch instance."""
  teamSlug: Slug!
}

type DeleteOpenSearchPayload {
  """Whether or not the OpenSearch instance was deleted."""
  openSearchDeleted: Boolean
}

input DeleteSecretInput {
  """The environment the secret exists in."""
  environment: String!

  """The name of the secret."""
  name: String!

  """The team that owns the secret."""
  team: Slug!
}

type DeleteSecretPayload {
  """The deleted secret."""
  secretDeleted: Boolean
}

input DeleteServiceAccountInput {
  """The ID of the service account to delete."""
  serviceAccountID: ID!
}

type DeleteServiceAccountPayload {
  """Whether or not the service account was deleted."""
  serviceAccountDeleted: Boolean
}

input DeleteServiceAccountTokenInput {
  """The ID of the service account token to delete."""
  serviceAccountTokenID: ID!
}

type DeleteServiceAccountTokenPayload {
  """The service account that the token belonged to."""
  serviceAccount: ServiceAccount

  """Whether or not the service account token was deleted."""
  serviceAccountTokenDeleted: Boolean
}

input DeleteUnleashInstanceInput {
  """The team that owns the Unleash instance to delete."""
  teamSlug: Slug!
}

type DeleteUnleashInstancePayload {
  """Whether the Unleash instance was successfully deleted."""
  unleashDeleted: Boolean
}

input DeleteValkeyInput {
  """The environment name that the entry belongs to."""
  environmentName: String!

  """Name of the Valkey instance."""
  name: String!

  """The team that owns the Valkey instance."""
  teamSlug: Slug!
}

type DeleteValkeyPayload {
  """Whether or not the job was deleted."""
  valkeyDeleted: Boolean
}

"""Description of a deployment."""
type Deployment implements Node {
  """The git commit SHA that was deployed."""
  commitSha: String

  """Creation timestamp of the deployment."""
  createdAt: Time!

  """Username of the actor who initiated the deployment."""
  deployerUsername: String

  """Name of the environment that the deployment belongs to."""
  environmentName: String!

  """ID of the deployment."""
  id: ID!

  """The repository that triggered the deployment."""
  repository: String

  """Resources that were deployed."""
  resources(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): DeploymentResourceConnection!

  """Statuses of the deployment."""
  statuses(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): DeploymentStatusConnection!

  """Team slug that the deployment belongs to."""
  teamSlug: Slug!

  """The URL of the workflow that triggered the deployment."""
  triggerUrl: String
}

type DeploymentActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the update."""
  data: DeploymentActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type DeploymentActivityLogEntryData {
  triggerURL: String
}

type DeploymentConnection {
  """List of edges."""
  edges: [DeploymentEdge!]!

  """List of nodes."""
  nodes: [Deployment!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type DeploymentEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The deployment."""
  node: Deployment!
}

input DeploymentFilter {
  """Filter deployments by environments."""
  environments: [String!]

  """Get deployments from a given date until today."""
  from: Time
}

"""Deployment key type."""
type DeploymentKey implements Node {
  """The date the deployment key was created."""
  created: Time!

  """The date the deployment key expires."""
  expires: Time!

  """The unique identifier of the deployment key."""
  id: ID!

  """The actual key."""
  key: String!
}

input DeploymentOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: DeploymentOrderField!
}

"""Possible fields to order deployments by."""
enum DeploymentOrderField {
  """The time the deployment was created at."""
  CREATED_AT
}

"""Resource connected to a deployment."""
type DeploymentResource implements Node {
  """Globally unique ID of the deployment resource."""
  id: ID!

  """Deployment resource kind."""
  kind: String!

  """The name of the resource."""
  name: String!
}

type DeploymentResourceConnection {
  """List of edges."""
  edges: [DeploymentResourceEdge!]!

  """List of nodes."""
  nodes: [DeploymentResource!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type DeploymentResourceEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The deployment resource."""
  node: DeploymentResource!
}

"""Resource connected to a deployment."""
type DeploymentStatus implements Node {
  """Creation timestamp of the deployment status."""
  createdAt: Time!

  """Globally unique ID of the deployment resource."""
  id: ID!

  """Message describing the deployment status."""
  message: String!

  """State of the deployment."""
  state: DeploymentStatusState!
}

type DeploymentStatusConnection {
  """List of edges."""
  edges: [DeploymentStatusEdge!]!

  """List of nodes."""
  nodes: [DeploymentStatus!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type DeploymentStatusEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The deployment status."""
  node: DeploymentStatus!
}

"""Possible states of a deployment status."""
enum DeploymentStatusState {
  ERROR
  FAILURE
  INACTIVE
  IN_PROGRESS
  PENDING
  QUEUED
  SUCCESS
}

type DeprecatedIngressIssue implements Issue & Node {
  application: Application!
  id: ID!
  ingresses: [String!]!
  message: String!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
}

type DeprecatedRegistryIssue implements Issue & Node {
  id: ID!
  message: String!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
  workload: Workload!
}

input DisableReconcilerInput {
  """The name of the reconciler to disable."""
  name: String!
}

input EnableReconcilerInput {
  """The name of the reconciler to enable."""
  name: String!
}

"""
Entra ID (f.k.a. Azure AD) authentication.

Read more: https://docs.nais.io/auth/entra-id/
"""
type EntraIDAuthIntegration implements AuthIntegration {
  """The name of the integration."""
  name: String!
}

"""
An environment represents a runtime environment for workloads.

Learn more in the [official Nais documentation](https://docs.nais.io/workloads/explanations/environment/).
"""
type Environment implements Node {
  """The globally unique ID of the team."""
  id: ID!

  """
  Query Prometheus metrics directly using PromQL for this environment.
  This allows for flexible metric queries within the specific environment.
  Supports both instant queries and range queries.
  """
  metrics(input: MetricsQueryInput!): MetricsQueryResult!

  """Unique name of the environment."""
  name: String!

  """Nais workloads in the environment."""
  workloads(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: EnvironmentWorkloadOrder
  ): WorkloadConnection!
}

"""Environment connection."""
type EnvironmentConnection {
  """List of edges."""
  edges: [EnvironmentEdge!]!

  """List of nodes."""
  nodes: [Environment!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Environment edge."""
type EnvironmentEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The Environment."""
  node: Environment!
}

"""Ordering options when fetching environments."""
input EnvironmentOrder {
  """The direction to order in."""
  direction: OrderDirection!

  """The field to order by."""
  field: EnvironmentOrderField!
}

"""Fields to order environments by."""
enum EnvironmentOrderField {
  """Order by name."""
  NAME
}

"""Ordering options when fetching workloads in an environment."""
input EnvironmentWorkloadOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: EnvironmentWorkloadOrderField!
}

"""Fields to order workloads in an environment by."""
enum EnvironmentWorkloadOrderField {
  """Order by the deployment time."""
  DEPLOYMENT_TIME

  """Order by name."""
  NAME

  """Order by team slug."""
  TEAM_SLUG
}

type ExternalNetworkPolicyHost implements ExternalNetworkPolicyTarget {
  ports: [Int!]!
  target: String!
}

type ExternalNetworkPolicyIpv4 implements ExternalNetworkPolicyTarget {
  ports: [Int!]!
  target: String!
}

interface ExternalNetworkPolicyTarget {
  ports: [Int!]!
  target: String!
}

type FailedSynchronizationIssue implements Issue & Node {
  id: ID!
  message: String!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
  workload: Workload!
}

type FeatureKafka implements Node {
  """Wether Kafka is enabled or not."""
  enabled: Boolean!

  """Unique identifier for the feature."""
  id: ID!
}

type FeatureOpenSearch implements Node {
  """Wether OpenSearch is enabled or not."""
  enabled: Boolean!

  """Unique identifier for the feature."""
  id: ID!
}

type FeatureUnleash implements Node {
  """Wether Unleash is enabled or not."""
  enabled: Boolean!

  """Unique identifier for the feature."""
  id: ID!
}

type FeatureValkey implements Node {
  """Wether Valkey is enabled or not."""
  enabled: Boolean!

  """Unique identifier for the feature."""
  id: ID!
}

type Features implements Node {
  """Unique identifier for the feature container."""
  id: ID!

  """Information about Kafka feature."""
  kafka: FeatureKafka!

  """Information about OpenSearch feature."""
  openSearch: FeatureOpenSearch!

  """Information about Unleash feature."""
  unleash: FeatureUnleash!

  """Information about Valkey feature."""
  valkey: FeatureValkey!
}

input GrantPostgresAccessInput {
  clusterName: String!

  """Duration of the access grant (maximum 4 hours)."""
  duration: String!
  environmentName: String!
  grantee: String!
  teamSlug: Slug!
}

type GrantPostgresAccessPayload {
  error: String
}

"""
ID-porten authentication.

Read more: https://docs.nais.io/auth/idporten/
"""
type IDPortenAuthIntegration implements AuthIntegration {
  """The name of the integration."""
  name: String!
}

type ImageVulnerability implements Node {
  """CVSS score of the vulnerability."""
  cvssScore: Float

  """Description of the vulnerability."""
  description: String!

  """The globally unique ID of the image vulnerability node."""
  id: ID!

  """The unique identifier of the vulnerability. E.g. CVE-****-****."""
  identifier: String!

  """Package name of the vulnerability."""
  package: String!

  """Severity of the vulnerability."""
  severity: ImageVulnerabilitySeverity!

  """Timestamp of when the vulnerability got its current severity."""
  severitySince: Time
  suppression: ImageVulnerabilitySuppression

  """Link to the vulnerability details."""
  vulnerabilityDetailsLink: String!
}

type ImageVulnerabilityConnection {
  """List of edges."""
  edges: [ImageVulnerabilityEdge!]!

  """List of nodes."""
  nodes: [ImageVulnerability!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type ImageVulnerabilityEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The image vulnerability."""
  node: ImageVulnerability!
}

"""Input for filtering image vulnerabilities."""
input ImageVulnerabilityFilter {
  """Only return vulnerabilities with the given severity."""
  severity: ImageVulnerabilitySeverity
  severitySince: Time
}

type ImageVulnerabilityHistory {
  """Vulnerability summary samples."""
  samples: [ImageVulnerabilitySample!]!
}

"""Ordering options when fetching teams."""
input ImageVulnerabilityOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: ImageVulnerabilityOrderField!
}

enum ImageVulnerabilityOrderField {
  IDENTIFIER
  PACKAGE
  SEVERITY
  SEVERITY_SINCE
  STATE
  SUPPRESSED
}

type ImageVulnerabilitySample {
  """Timestamp of the vulnerability summary."""
  date: Time!

  """The historic image vulnerability summary"""
  summary: ImageVulnerabilitySummary!
}

enum ImageVulnerabilitySeverity {
  CRITICAL
  HIGH
  LOW
  MEDIUM
  UNASSIGNED
}

type ImageVulnerabilitySummary {
  """Number of vulnerabilities with severity CRITICAL."""
  critical: Int!

  """Number of vulnerabilities with severity HIGH."""
  high: Int!

  """Timestamp of the last update of the vulnerability summary."""
  lastUpdated: Time

  """Number of vulnerabilities with severity LOW."""
  low: Int!

  """Number of vulnerabilities with severity MEDIUM."""
  medium: Int!

  """Risk score of the image."""
  riskScore: Int!

  """Total number of vulnerabilities."""
  total: Int!

  """Number of vulnerabilities with severity UNASSIGNED."""
  unassigned: Int!
}

type ImageVulnerabilitySuppression {
  """The reason for the suppression of the vulnerability."""
  reason: String!

  """Suppression state of the vulnerability."""
  state: ImageVulnerabilitySuppressionState!
}

enum ImageVulnerabilitySuppressionState {
  """Vulnerability is marked as false positive."""
  FALSE_POSITIVE

  """Vulnerability is in triage."""
  IN_TRIAGE

  """Vulnerability is marked as not affected."""
  NOT_AFFECTED

  """Vulnerability is resolved."""
  RESOLVED
}

type InboundNetworkPolicy {
  rules: [NetworkPolicyRule!]!
}

type Ingress {
  """Metrics for the ingress."""
  metrics: IngressMetrics!

  """Type of ingress."""
  type: IngressType!

  """URL for the ingress."""
  url: String!
}

"""Ingress metric type."""
type IngressMetricSample {
  """Timestamp of the value."""
  timestamp: Time!

  """Value of the IngressMetricsType at the given timestamp."""
  value: Float!
}

type IngressMetrics {
  """Number of errors in the ingress per second."""
  errorsPerSecond: Float!

  """Number of requests to the ingress per second."""
  requestsPerSecond: Float!

  """Ingress metrics between start and end with step size."""
  series(input: IngressMetricsInput!): [IngressMetricSample!]!
}

input IngressMetricsInput {
  """Fetch metrics until this timestamp."""
  end: Time!

  """Fetch metrics from this timestamp."""
  start: Time!

  """Type of metric to fetch."""
  type: IngressMetricsType!
}

"""Type of ingress metrics to fetch."""
enum IngressMetricsType {
  """Number of errors in the ingress per second."""
  ERRORS_PER_SECOND

  """Number of requests to the ingress per second."""
  REQUESTS_PER_SECOND
}

enum IngressType {
  AUTHENTICATED
  EXTERNAL
  INTERNAL
  UNKNOWN
}

type InvalidSpecIssue implements Issue & Node {
  id: ID!
  message: String!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
  workload: Workload!
}

interface Issue {
  id: ID!
  message: String!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
}

type IssueConnection {
  """List of edges."""
  edges: [IssueEdge!]!

  """List of nodes."""
  nodes: [Issue!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type IssueEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The Issue."""
  node: Issue!
}

input IssueFilter {
  """Filter by environment."""
  environments: [String!]

  """Filter by issue type."""
  issueType: IssueType

  """Filter by resource name."""
  resourceName: String

  """Filter by resource type."""
  resourceType: ResourceType

  """Filter by severity."""
  severity: Severity
}

input IssueOrder {
  """Order direction."""
  direction: OrderDirection!

  """Order by this field."""
  field: IssueOrderField!
}

enum IssueOrderField {
  """Order by environment."""
  ENVIRONMENT

  """Order by issue type."""
  ISSUE_TYPE

  """Order by resource name."""
  RESOURCE_NAME

  """Order by resource type."""
  RESOURCE_TYPE

  """Order by severity."""
  SEVERITY
}

enum IssueType {
  DEPRECATED_INGRESS
  DEPRECATED_REGISTRY
  FAILED_SYNCHRONIZATION
  INVALID_SPEC
  LAST_RUN_FAILED
  MISSING_SBOM
  NO_RUNNING_INSTANCES
  OPENSEARCH
  SQLINSTANCE_STATE
  SQLINSTANCE_VERSION
  VALKEY
  VULNERABLE_IMAGE
}

type Job implements ActivityLogger & Node & Workload {
  """Activity log associated with the job."""
  activityLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter items."""
    filter: ActivityLogFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ActivityLogEntryConnection!

  """List of authentication and authorization for the job."""
  authIntegrations: [JobAuthIntegrations!]!

  """
  BigQuery datasets referenced by the job. This does not currently support pagination, but will return all available datasets.
  """
  bigQueryDatasets(
    """Ordering options for items returned from the connection."""
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """
  Google Cloud Storage referenced by the job. This does not currently support pagination, but will return all available buckets.
  """
  buckets(
    """Ordering options for items returned from the connection."""
    orderBy: BucketOrder
  ): BucketConnection!

  """The cost for the job."""
  cost: WorkloadCost!

  """If set, when the job was marked for deletion."""
  deletionStartedAt: Time

  """List of deployments for the job."""
  deployments(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): DeploymentConnection!

  """The environment the job is deployed in."""
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")

  """The globally unique ID of the job."""
  id: ID!

  """The container image of the job."""
  image: ContainerImage!

  """Get the vulnerability summary history for job."""
  imageVulnerabilityHistory(
    """Get vulnerability summary from given date until today."""
    from: Date!
  ): ImageVulnerabilityHistory!

  """Issues that affects the workload."""
  issues(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filtering options for items returned from the connection."""
    filter: ResourceIssueFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: IssueOrder
  ): IssueConnection!

  """
  Kafka topics the job has access to. This does not currently support pagination, but will return all available Kafka topics.
  """
  kafkaTopicAcls(
    """Ordering options for items returned from the connection."""
    orderBy: KafkaTopicAclOrder
  ): KafkaTopicAclConnection!

  """List of log destinations for the job."""
  logDestinations: [LogDestination!]!

  """The job manifest."""
  manifest: JobManifest!

  """The name of the job."""
  name: String!

  """Network policies for the job."""
  networkPolicy: NetworkPolicy!

  """OpenSearch instance referenced by the workload."""
  openSearch: OpenSearch

  """
  Postgres instances referenced by the job. This does not currently support pagination, but will return all available Postgres instances.
  """
  postgresInstances(
    """Ordering options for items returned from the connection."""
    orderBy: PostgresInstanceOrder
  ): PostgresInstanceConnection!

  """Resources for the job."""
  resources: JobResources!

  """The job runs."""
  runs(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): JobRunConnection!

  """Optional schedule for the job. Jobs with no schedule are run once."""
  schedule: JobSchedule

  """Secrets used by the job."""
  secrets(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): SecretConnection!

  """
  SQL instances referenced by the job. This does not currently support pagination, but will return all available SQL instances.
  """
  sqlInstances(
    """Ordering options for items returned from the connection."""
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!

  """The state of the Job"""
  state: JobState!

  """The team that owns the job."""
  team: Team!

  """The team environment for the job."""
  teamEnvironment: TeamEnvironment!

  """
  Valkey instances referenced by the job. This does not currently support pagination, but will return all available Valkey instances.
  """
  valkeys(
    """Ordering options for items returned from the connection."""
    orderBy: ValkeyOrder
  ): ValkeyConnection!

  """Get the mean time to fix history for a job."""
  vulnerabilityFixHistory(from: Date!): VulnerabilityFixHistory!
}

union JobAuthIntegrations = EntraIDAuthIntegration | MaskinportenAuthIntegration

type JobConnection {
  """List of edges."""
  edges: [JobEdge!]!

  """List of nodes."""
  nodes: [Job!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type JobDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type JobEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The job."""
  node: Job!
}

type JobManifest implements WorkloadManifest {
  """The manifest content, serialized as a YAML document."""
  content: String!
}

input JobOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: JobOrderField!
}

enum JobOrderField {
  """Order applications by the deployment time."""
  DEPLOYMENT_TIME

  """Order jobs by the name of the environment."""
  ENVIRONMENT

  """Order jobs by issue severity"""
  ISSUES

  """Order jobs by name."""
  NAME

  """Order by state."""
  STATE
}

type JobResources implements WorkloadResources {
  limits: WorkloadResourceQuantity!
  requests: WorkloadResourceQuantity!
}

type JobRun implements Node {
  """The completion time of the job."""
  completionTime: Time

  """Duration of the job in seconds."""
  duration: Int!

  """The globally unique ID of the job run."""
  id: ID!

  """The container image of the job run."""
  image: ContainerImage!

  """Job run instances."""
  instances(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): JobRunInstanceConnection!

  """The name of the job run."""
  name: String!

  """The start time of the job."""
  startTime: Time

  """The status of the job run."""
  status: JobRunStatus!
  trigger: JobRunTrigger!
}

type JobRunConnection {
  """List of edges."""
  edges: [JobRunEdge!]!

  """List of nodes."""
  nodes: [JobRun!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type JobRunEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The job run."""
  node: JobRun!
}

type JobRunInstance implements Node {
  """The globally unique ID of the job run instance."""
  id: ID!

  """The name of the job run instance."""
  name: String!
}

type JobRunInstanceConnection {
  """List of edges."""
  edges: [JobRunInstanceEdge!]!

  """List of nodes."""
  nodes: [JobRunInstance!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type JobRunInstanceEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The instance."""
  node: JobRunInstance!
}

enum JobRunState {
  """Job run is failed."""
  FAILED

  """Job run is pending."""
  PENDING

  """Job run is running."""
  RUNNING

  """Job run is succeeded."""
  SUCCEEDED

  """Job run is unknown."""
  UNKNOWN
}

type JobRunStatus {
  """Human readable job run status."""
  message: String!

  """The state of the job run."""
  state: JobRunState!
}

type JobRunTrigger {
  """The actor/user who triggered the job run manually, if applicable."""
  actor: String

  """The type of trigger that started the job."""
  type: JobRunTriggerType!
}

enum JobRunTriggerType {
  AUTOMATIC
  MANUAL
}

type JobSchedule {
  """The cron expression for the job."""
  expression: String!

  """The time zone for the job. Defaults to UTC."""
  timeZone: String!
}

enum JobState {
  COMPLETED
  FAILED
  RUNNING
  UNKNOWN
}

type JobTriggeredActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type KafkaLagScalingStrategy {
  """The consumer group of the topic."""
  consumerGroup: String!

  """The threshold that must be met for the scaling to trigger."""
  threshold: Int!

  """The name of the Kafka topic."""
  topicName: String!
}

type KafkaTopic implements Node & Persistence {
  acl(after: Cursor, before: Cursor, filter: KafkaTopicAclFilter, first: Int, last: Int, orderBy: KafkaTopicAclOrder): KafkaTopicAclConnection!
  configuration: KafkaTopicConfiguration
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
  id: ID!
  name: String!
  pool: String!
  team: Team!
  teamEnvironment: TeamEnvironment!
}

type KafkaTopicAcl {
  access: String!
  team: Team
  teamName: String!
  topic: KafkaTopic!
  workload: Workload
  workloadName: String!
}

type KafkaTopicAclConnection {
  edges: [KafkaTopicAclEdge!]!
  nodes: [KafkaTopicAcl!]!
  pageInfo: PageInfo!
}

type KafkaTopicAclEdge {
  cursor: Cursor!
  node: KafkaTopicAcl!
}

input KafkaTopicAclFilter {
  team: Slug
  validWorkloads: Boolean
  workload: String
}

input KafkaTopicAclOrder {
  direction: OrderDirection!
  field: KafkaTopicAclOrderField!
}

enum KafkaTopicAclOrderField {
  ACCESS
  CONSUMER
  TEAM_SLUG
  TOPIC_NAME
}

type KafkaTopicConfiguration {
  cleanupPolicy: String
  maxMessageBytes: Int
  minimumInSyncReplicas: Int
  partitions: Int
  replication: Int
  retentionBytes: Int
  retentionHours: Int
  segmentHours: Int
}

type KafkaTopicConnection {
  edges: [KafkaTopicEdge!]!
  nodes: [KafkaTopic!]!
  pageInfo: PageInfo!
}

type KafkaTopicEdge {
  cursor: Cursor!
  node: KafkaTopic!
}

input KafkaTopicOrder {
  direction: OrderDirection!
  field: KafkaTopicOrderField!
}

enum KafkaTopicOrderField {
  ENVIRONMENT
  NAME
}

type LastRunFailedIssue implements Issue & Node {
  id: ID!
  job: Job!
  message: String!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
}

interface LogDestination {
  """The globally unique ID of the log destination."""
  id: ID!
}

type LogDestinationGeneric implements LogDestination & Node {
  """The globally unique ID of the log destination."""
  id: ID!

  """Name defined in the manifest"""
  name: String!
}

type LogDestinationLoki implements LogDestination & Node {
  """Grafana URL to view the logs."""
  grafanaURL: String!

  """The globally unique ID of the log destination."""
  id: ID!
}

type LogDestinationSecureLogs implements LogDestination & Node {
  """The globally unique ID of the log destination."""
  id: ID!
}

type LogLine {
  """Labels attached to the log line."""
  labels: [LogLineLabel!]!

  """The log line message."""
  message: String!

  """Timestamp of the log line."""
  time: Time!
}

type LogLineLabel {
  """The key of the label."""
  key: String!

  """The value of the label."""
  value: String!
}

input LogSubscriptionFilter {
  """Specify the environment to stream log lines from."""
  environmentName: String!

  """
  Specify an initial batch of log lines to be sent when the subscription starts.
  """
  initialBatch: LogSubscriptionInitialBatch = {limit: 100}

  """Filter log lines by specifying a query."""
  query: String!
}

input LogSubscriptionInitialBatch {
  """Initial batch of past log lines before streaming starts."""
  limit: Int = 100

  """
  Specifies the start timestamp of the initial batch. Defaults to one hour ago.
  """
  start: Time
}

type MaintenanceWindow {
  """Day of the week when the maintenance is scheduled."""
  dayOfWeek: Weekday!

  """Time of day when the maintenance is scheduled."""
  timeOfDay: TimeOfDay!
}

"""
Maskinporten authentication.

Read more: https://docs.nais.io/auth/maskinporten/
"""
type MaskinportenAuthIntegration implements AuthIntegration {
  """The name of the integration."""
  name: String!
}

"""A key-value pair representing a Prometheus label."""
type MetricLabel {
  """The label name."""
  name: String!

  """The label value."""
  value: String!
}

"""A time series with its labels and data points."""
type MetricSeries {
  """The metric labels as key-value pairs."""
  labels: [MetricLabel!]!

  """
  The data points for this time series.
  Instant queries will have a single value.
  Range queries will have multiple values over time.
  """
  values: [MetricValue!]!
}

"""A single data point in a time series."""
type MetricValue {
  """The timestamp of the data point."""
  timestamp: Time!

  """The value at the given timestamp."""
  value: Float!
}

"""Input for querying Prometheus metrics."""
input MetricsQueryInput {
  """
  The PromQL query to execute.
  Example: "rate(http_requests_total[5m])"
  """
  query: String!

  """
  Optional range query parameters.
  If provided, executes a range query instead of an instant query.
  
  Limits to prevent excessive memory usage:
  - Minimum step: 10 seconds
  - Maximum time range: 30 days
  - Maximum data points: 11,000
  """
  range: MetricsRangeInput

  """
  Optional timestamp for instant queries.
  Specifies the exact point in time to evaluate the query.
  If not provided, defaults to current time minus 5 minutes.
  This parameter is ignored when range is provided.
  """
  time: Time
}

"""Result from a Prometheus metrics query."""
type MetricsQueryResult {
  """
  Time series data from the query.
  For instant queries, each series contains a single value.
  For range queries, each series contains multiple values over time.
  """
  series: [MetricSeries!]!

  """Warnings returned by Prometheus, if any."""
  warnings: [String!]!
}

"""
Input for Prometheus range queries.

To prevent excessive memory usage, queries are subject to limits:
- Step must be at least 10 seconds
- Time range (end - start) cannot exceed 30 days
- Total data points cannot exceed 11,000
"""
input MetricsRangeInput {
  """
  End timestamp for the range query.
  Must be after start time.
  """
  end: Time!

  """Start timestamp for the range query."""
  start: Time!

  """
  Query resolution step width in seconds.
  Must be at least 10 seconds.
  Example: 60 for 1-minute intervals
  """
  step: Int!
}

type MissingSbomIssue implements Issue & Node {
  id: ID!
  message: String!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
  workload: Workload!
}

"""The mutation root for the Nais GraphQL API."""
type Mutation {
  """Add a team repository."""
  addRepositoryToTeam(input: AddRepositoryToTeamInput!): AddRepositoryToTeamPayload!

  """Add a secret value to a secret."""
  addSecretValue(input: AddSecretValueInput!): AddSecretValuePayload!

  """
  Add a team member
  
  If the user is already a member or an owner of the team, the mutation will result in an error.
  """
  addTeamMember(input: AddTeamMemberInput!): AddTeamMemberPayload!

  """Add team to the list of teams that can access the Unleash instance."""
  allowTeamAccessToUnleash(input: AllowTeamAccessToUnleashInput!): AllowTeamAccessToUnleashPayload!

  """Assign a role to a service account."""
  assignRoleToServiceAccount(input: AssignRoleToServiceAccountInput!): AssignRoleToServiceAccountPayload!

  """Update the deploy key of a team. Returns the updated deploy key."""
  changeDeploymentKey(input: ChangeDeploymentKeyInput!): ChangeDeploymentKeyPayload!

  """Configure a reconciler."""
  configureReconciler(input: ConfigureReconcilerInput!): Reconciler!

  """
  Confirm a team deletion
  
  This will start the actual team deletion process, which will be done in an asynchronous manner. All external
  entities controlled by Nais will also be deleted.
  
  WARNING: There is no going back after starting this process.
  
  Note: Service accounts are not allowed to confirm a team deletion.
  """
  confirmTeamDeletion(input: ConfirmTeamDeletionInput!): ConfirmTeamDeletionPayload!

  """Create a new OpenSearch instance."""
  createOpenSearch(input: CreateOpenSearchInput!): CreateOpenSearchPayload!

  """Create a new secret."""
  createSecret(input: CreateSecretInput!): CreateSecretPayload!

  """Create a service account."""
  createServiceAccount(input: CreateServiceAccountInput!): CreateServiceAccountPayload!

  """
  Create a service account token.
  
  The secret is automatically generated, and is returned as a part of the payload for this mutation. The secret can
  not be retrieved at a later stage.
  
  A service account can have multiple active tokens at the same time.
  """
  createServiceAccountToken(input: CreateServiceAccountTokenInput!): CreateServiceAccountTokenPayload!

  """
  Create a new Nais team
  
  The user creating the team will be granted team ownership, unless the user is a service account, in which case the
  team will not get an initial owner. To add one or more owners to the team, refer to the `addTeamOwners` mutation.
  
  Creation of a team will also create external resources for the team, which will be managed by the Nais API
  reconcilers. This will be done asynchronously.
  
  Refer to the [official Nais documentation](https://docs.nais.io/explanations/team/) for more information regarding
  Nais teams.
  """
  createTeam(input: CreateTeamInput!): CreateTeamPayload!

  """
  Create a new Unleash instance.
  
  This mutation will create a new Unleash instance for the given team. The team
  will be set as owner of the Unleash instance and will be able to manage it.
  
  By default, instances are created with the default version.
  Optionally specify a releaseChannel to subscribe to automatic version updates.
  """
  createUnleashForTeam(input: CreateUnleashForTeamInput!): CreateUnleashForTeamPayload!

  """Create a new Valkey instance."""
  createValkey(input: CreateValkeyInput!): CreateValkeyPayload!

  """Delete an application."""
  deleteApplication(
    """Input for deleting an application."""
    input: DeleteApplicationInput!
  ): DeleteApplicationPayload!

  """Delete a job."""
  deleteJob(input: DeleteJobInput!): DeleteJobPayload!

  """Delete an existing OpenSearch instance."""
  deleteOpenSearch(input: DeleteOpenSearchInput!): DeleteOpenSearchPayload!

  """Delete a secret, and the values it contains."""
  deleteSecret(input: DeleteSecretInput!): DeleteSecretPayload!

  """Delete a service account."""
  deleteServiceAccount(input: DeleteServiceAccountInput!): DeleteServiceAccountPayload!

  """Delete a service account token."""
  deleteServiceAccountToken(input: DeleteServiceAccountTokenInput!): DeleteServiceAccountTokenPayload!

  """
  Delete an Unleash instance.
  
  The Unleash instance can only be deleted if no other teams have access to it.
  Revoke access for all other teams before deleting the instance.
  """
  deleteUnleashInstance(input: DeleteUnleashInstanceInput!): DeleteUnleashInstancePayload!

  """Delete an existing Valkey instance."""
  deleteValkey(input: DeleteValkeyInput!): DeleteValkeyPayload!

  """
  Disable a reconciler
  
  The reconciler configuration will be left intact.
  """
  disableReconciler(input: DisableReconcilerInput!): Reconciler!

  """
  Enable a reconciler
  
  A reconciler must be fully configured before it can be enabled.
  """
  enableReconciler(input: EnableReconcilerInput!): Reconciler!

  """Grant temporary access to a Postgres cluster."""
  grantPostgresAccess(input: GrantPostgresAccessInput!): GrantPostgresAccessPayload!

  """Remove a team repository."""
  removeRepositoryFromTeam(input: RemoveRepositoryFromTeamInput!): RemoveRepositoryFromTeamPayload!

  """Remove a secret value from a secret."""
  removeSecretValue(input: RemoveSecretValueInput!): RemoveSecretValuePayload!

  """
  Remove a team member
  
  If the user is not already a member or an owner of the team, the mutation will result in an error.
  """
  removeTeamMember(input: RemoveTeamMemberInput!): RemoveTeamMemberPayload!

  """
  Request a key that can be used to trigger a team deletion process
  
  Deleting a team is a two step process. First an owner of the team (or an admin) must request a team deletion key,
  and then a second owner of the team (or an admin) must confirm the deletion using the confirmTeamDeletion mutation.
  
  The returned delete key is valid for an hour, and can only be used once.
  
  Note: Service accounts are not allowed to request team delete keys.
  """
  requestTeamDeletion(input: RequestTeamDeletionInput!): RequestTeamDeletionPayload!

  """Restart an application."""
  restartApplication(
    """Input for restarting an application."""
    input: RestartApplicationInput!
  ): RestartApplicationPayload!

  """Revoke a role from a service account."""
  revokeRoleFromServiceAccount(input: RevokeRoleFromServiceAccountInput!): RevokeRoleFromServiceAccountPayload!

  """
  Remove team from the list of teams that can access the Unleash instance.
  """
  revokeTeamAccessToUnleash(input: RevokeTeamAccessToUnleashInput!): RevokeTeamAccessToUnleashPayload!

  """
  Assign a role to a team member
  
  The user must already be a member of the team for this mutation to succeed.
  """
  setTeamMemberRole(input: SetTeamMemberRoleInput!): SetTeamMemberRolePayload!

  """Start maintenance updates for an OpenSearch instance."""
  startOpenSearchMaintenance(input: StartOpenSearchMaintenanceInput!): StartOpenSearchMaintenancePayload

  """Start maintenance updates for a Valkey instance."""
  startValkeyMaintenance(input: StartValkeyMaintenanceInput!): StartValkeyMaintenancePayload

  """Trigger a job"""
  triggerJob(input: TriggerJobInput!): TriggerJobPayload!

  """
  Updates a vulnerability
  This mutation is currently unstable and may change in the future.
  """
  updateImageVulnerability(input: UpdateImageVulnerabilityInput!): UpdateImageVulnerabilityPayload!

  """Update an existing OpenSearch instance."""
  updateOpenSearch(input: UpdateOpenSearchInput!): UpdateOpenSearchPayload!

  """Update a secret value within a secret."""
  updateSecretValue(input: UpdateSecretValueInput!): UpdateSecretValuePayload!

  """Update a service account."""
  updateServiceAccount(input: UpdateServiceAccountInput!): UpdateServiceAccountPayload!

  """
  Update a service account token.
  
  Note that the secret itself can not be updated, only the metadata.
  """
  updateServiceAccountToken(input: UpdateServiceAccountTokenInput!): UpdateServiceAccountTokenPayload!

  """
  Update an existing Nais team
  
  This mutation can be used to update the team purpose and the main Slack channel. It is not possible to update the
  team slug.
  """
  updateTeam(input: UpdateTeamInput!): UpdateTeamPayload!

  """Update an environment for a team"""
  updateTeamEnvironment(input: UpdateTeamEnvironmentInput!): UpdateTeamEnvironmentPayload!

  """
  Update an Unleash instance's release channel.
  
  Use this mutation to change to a different release channel.
  """
  updateUnleashInstance(input: UpdateUnleashInstanceInput!): UpdateUnleashInstancePayload!

  """Update an existing Valkey instance."""
  updateValkey(input: UpdateValkeyInput!): UpdateValkeyPayload!

  """
  View the values of a secret. Requires team membership and a reason for access.
  This creates a temporary elevation and logs the access for auditing purposes.
  """
  viewSecretValues(input: ViewSecretValuesInput!): ViewSecretValuesPayload!
}

type NetworkPolicy {
  inbound: InboundNetworkPolicy!
  outbound: OutboundNetworkPolicy!
}

type NetworkPolicyRule {
  mutual: Boolean!
  targetTeam: Team
  targetTeamSlug: Slug!
  targetWorkload: Workload
  targetWorkloadName: String!
}

type NoRunningInstancesIssue implements Issue & Node {
  id: ID!
  message: String!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
  workload: Workload!
}

"""
This interface is implemented by types that supports the [Global Object Identification specification](https://graphql.org/learn/global-object-identification/).
"""
interface Node {
  """Globally unique ID of the object."""
  id: ID!
}

type OpenSearch implements ActivityLogger & Node & Persistence {
  access(after: Cursor, before: Cursor, first: Int, last: Int, orderBy: OpenSearchAccessOrder): OpenSearchAccessConnection!

  """Activity log associated with the reconciler."""
  activityLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter items."""
    filter: ActivityLogFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ActivityLogEntryConnection!
  cost: OpenSearchCost!
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
  id: ID!

  """Issues that affects the instance."""
  issues(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filtering options for items returned from the connection."""
    filter: ResourceIssueFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: IssueOrder
  ): IssueConnection!

  """Fetch maintenances updates for the OpenSearch instance."""
  maintenance: OpenSearchMaintenance!

  """Available memory for the OpenSearch instance."""
  memory: OpenSearchMemory!
  name: String!
  state: OpenSearchState!

  """Available storage in GB."""
  storageGB: Int!
  team: Team!
  teamEnvironment: TeamEnvironment!
  terminationProtection: Boolean!

  """Availability tier for the OpenSearch instance."""
  tier: OpenSearchTier!

  """Fetch version for the OpenSearch instance."""
  version: OpenSearchVersion!
  workload: Workload @deprecated(reason: "OpenSearch does not have a owner, so this field will always be null.")
}

type OpenSearchAccess {
  access: String!
  workload: Workload!
}

type OpenSearchAccessConnection {
  edges: [OpenSearchAccessEdge!]!
  nodes: [OpenSearchAccess!]!
  pageInfo: PageInfo!
}

type OpenSearchAccessEdge {
  cursor: Cursor!
  node: OpenSearchAccess!
}

input OpenSearchAccessOrder {
  direction: OrderDirection!
  field: OpenSearchAccessOrderField!
}

enum OpenSearchAccessOrderField {
  ACCESS
  WORKLOAD
}

type OpenSearchConnection {
  edges: [OpenSearchEdge!]!
  nodes: [OpenSearch!]!
  pageInfo: PageInfo!
}

type OpenSearchCost {
  sum: Float!
}

type OpenSearchCreatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type OpenSearchDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type OpenSearchEdge {
  cursor: Cursor!
  node: OpenSearch!
}

type OpenSearchIssue implements Issue & Node {
  event: String!
  id: ID!
  message: String!
  openSearch: OpenSearch!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
}

type OpenSearchMaintenance {
  updates(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): OpenSearchMaintenanceUpdateConnection!

  """The day and time of the week when the maintenance will be scheduled."""
  window: MaintenanceWindow
}

type OpenSearchMaintenanceUpdate implements ServiceMaintenanceUpdate {
  """
  Deadline for installing the maintenance. If set, maintenance is mandatory and will be forcibly applied.
  """
  deadline: Time

  """Description of the maintenance."""
  description: String!

  """
  The time when the update will be automatically applied. If set, maintenance is mandatory and will be forcibly applied.
  """
  startAt: Time

  """Title of the maintenance."""
  title: String!
}

type OpenSearchMaintenanceUpdateConnection {
  """List of edges."""
  edges: [OpenSearchMaintenanceUpdateEdge!]!

  """List of nodes."""
  nodes: [OpenSearchMaintenanceUpdate!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type OpenSearchMaintenanceUpdateEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The OpenSearchMaintenanceUpdate."""
  node: OpenSearchMaintenanceUpdate!
}

enum OpenSearchMajorVersion {
  """OpenSearch Version 1.3.x"""
  V1

  """OpenSearch Version 2.17.x"""
  V2

  """OpenSearch Version 2.19.x"""
  V2_19

  """OpenSearch Version 3.3.x"""
  V3_3
}

enum OpenSearchMemory {
  GB_2
  GB_4
  GB_8
  GB_16
  GB_32
  GB_64
}

input OpenSearchOrder {
  direction: OrderDirection!
  field: OpenSearchOrderField!
}

enum OpenSearchOrderField {
  ENVIRONMENT

  """Order OpenSearches by issue severity"""
  ISSUES
  NAME
  STATE
}

enum OpenSearchState {
  POWEROFF
  REBALANCING
  REBUILDING
  RUNNING
  UNKNOWN
}

enum OpenSearchTier {
  HIGH_AVAILABILITY
  SINGLE_NODE
}

type OpenSearchUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: OpenSearchUpdatedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type OpenSearchUpdatedActivityLogEntryData {
  updatedFields: [OpenSearchUpdatedActivityLogEntryDataUpdatedField!]!
}

type OpenSearchUpdatedActivityLogEntryDataUpdatedField {
  """The name of the field."""
  field: String!

  """The new value of the field."""
  newValue: String

  """The old value of the field."""
  oldValue: String
}

type OpenSearchVersion {
  """
  The full version string of the OpenSearch instance. This will be available after the instance is created.
  """
  actual: String

  """The desired major version of the OpenSearch instance."""
  desiredMajor: OpenSearchMajorVersion!
}

"""Possible directions in which to order a list of items."""
enum OrderDirection {
  """Ascending sort order."""
  ASC

  """Descending sort order."""
  DESC
}

type OutboundNetworkPolicy {
  external: [ExternalNetworkPolicyTarget!]!
  rules: [NetworkPolicyRule!]!
}

"""
This type is used for paginating the connection

Learn more about how we have implemented pagination in the [GraphQL Best Practices documentation](https://graphql.org/learn/pagination/).
"""
type PageInfo {
  """
  The cursor for the last item in the edges. This cursor is used when paginating forwards.
  """
  endCursor: Cursor

  """Whether or not there exists a next page in the connection."""
  hasNextPage: Boolean!

  """Whether or not there exists a previous page in the connection."""
  hasPreviousPage: Boolean!

  """The offset of the last item in the connection."""
  pageEnd: Int!

  """The offset of the first item in the connection."""
  pageStart: Int!

  """
  The cursor for the first item in the edges. This cursor is used when paginating backwards.
  """
  startCursor: Cursor

  """The total amount of items in the connection."""
  totalCount: Int!
}

interface Persistence {
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
  id: ID!
  name: String!
  team: Team!
  teamEnvironment: TeamEnvironment!
}

type PostgresGrantAccessActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the update."""
  data: PostgresGrantAccessActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type PostgresGrantAccessActivityLogEntryData {
  grantee: String!
  until: Time!
}

type PostgresInstance implements Node & Persistence {
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
  id: ID!

  """Major version of PostgreSQL."""
  majorVersion: String!
  name: String!

  """Resource allocation for the Postgres cluster."""
  resources: PostgresInstanceResources!
  team: Team!
  teamEnvironment: TeamEnvironment!
}

type PostgresInstanceConnection {
  edges: [PostgresInstanceEdge!]!
  nodes: [PostgresInstance!]!
  pageInfo: PageInfo!
}

type PostgresInstanceEdge {
  cursor: Cursor!
  node: PostgresInstance!
}

input PostgresInstanceOrder {
  direction: OrderDirection!
  field: PostgresInstanceOrderField!
}

enum PostgresInstanceOrderField {
  ENVIRONMENT
  NAME
}

type PostgresInstanceResources {
  cpu: String!
  diskSize: String!
  memory: String!
}

type Price {
  value: Float!
}

type PrometheusAlarm {
  """The action to take when the alert fires."""
  action: String!

  """The consequence of the alert firing."""
  consequence: String!

  """The time when the alert started firing."""
  since: Time!

  """The state of the alert."""
  state: AlertState!

  """A summary of the alert."""
  summary: String!

  """The current value of the metric that triggered the alert."""
  value: Float!
}

"""PrometheusAlert type"""
type PrometheusAlert implements Alert & Node {
  """The alarms of the alert available if state is firing."""
  alarms: [PrometheusAlarm!]!

  """The duration for the alert."""
  duration: Float!

  """The unique identifier for the alert."""
  id: ID!

  """The name of the alert."""
  name: String!

  """The query for the alert."""
  query: String!

  """The prometheus rule group for the alert."""
  ruleGroup: String!

  """The state of the alert."""
  state: AlertState!

  """The team that owns the alert."""
  team: Team!

  """The team environment for the alert."""
  teamEnvironment: TeamEnvironment!
}

"""The query root for the Nais GraphQL API."""
type Query {
  """Get the monthly cost summary for a tenant."""
  costMonthlySummary(
    """Start month of the period, inclusive."""
    from: Date!

    """End month of the period, inclusive."""
    to: Date!
  ): CostMonthlySummary!

  """Get current prices for resources."""
  currentUnitPrices: CurrentUnitPrices!

  """Get a specific CVE by its identifier."""
  cve(identifier: String!): CVE!

  """List active CVEs for workloads in all environments."""
  cves(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: CVEOrder
  ): CVEConnection!

  """Get a list of deployments."""
  deployments(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter options for the deployments returned from the connection."""
    filter: DeploymentFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: DeploymentOrder
  ): DeploymentConnection!

  """Get a single environment."""
  environment(
    """The name of the environment to get."""
    name: String!
  ): Environment!

  """Get a list of environments."""
  environments(
    """Ordering options for environments."""
    orderBy: EnvironmentOrder
  ): EnvironmentConnection!

  """Feature flags."""
  features: Features!

  """Get the vulnerability summary history for all teams."""
  imageVulnerabilityHistory(
    """Get vulnerability summary from given date until today."""
    from: Date!
  ): ImageVulnerabilityHistory!

  """The currently authenticated user."""
  me: AuthenticatedUser!

  """Fetch an object using its globally unique ID."""
  node(
    """The ID of the object to fetch."""
    id: ID!
  ): Node

  """Get a collection of reconcilers."""
  reconcilers(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ReconcilerConnection!
  roles(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): RoleConnection!

  """Search for entities."""
  search(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter the search results."""
    filter: SearchFilter!

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): SearchNodeConnection!

  """Returns a service account by its ID."""
  serviceAccount(
    """ID of the service account."""
    id: ID!
  ): ServiceAccount!

  """Get a list of service accounts."""
  serviceAccounts(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ServiceAccountConnection!

  """Get a team by its slug."""
  team(slug: Slug!): Team!

  """Get a list of teams."""
  teams(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter options for the teams returned from the connection."""
    filter: TeamFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: TeamOrder
  ): TeamConnection!
  teamsUtilization(resourceType: UtilizationResourceType!): [TeamUtilizationData!]!

  """
  Get a list of available release channels for Unleash instances.
  Release channels provide automatic version updates based on the channel's update policy.
  """
  unleashReleaseChannels: [UnleashReleaseChannel!]!

  """Get a user by an identifier."""
  user(email: String): User!

  """Log entries from the user sync process."""
  userSyncLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): UserSyncLogEntryConnection!

  """Get a list of users."""
  users(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: UserOrder
  ): UserConnection!

  """Get the mean time to fix history for all teams."""
  vulnerabilityFixHistory(from: Date!): VulnerabilityFixHistory!

  """Get the vulnerability summary for the tenant."""
  vulnerabilitySummary: TenantVulnerabilitySummary!
}

"""Reconciler type."""
type Reconciler implements ActivityLogger & Node {
  """Activity log associated with the reconciler."""
  activityLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter items."""
    filter: ActivityLogFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ActivityLogEntryConnection!

  """Reconciler configuration keys and descriptions."""
  config: [ReconcilerConfig!]!

  """
  Whether or not the reconciler is fully configured and ready to be enabled.
  """
  configured: Boolean!

  """Description of what the reconciler is responsible for."""
  description: String!

  """The human-friendly name of the reconciler."""
  displayName: String!

  """Whether or not the reconciler is enabled."""
  enabled: Boolean!

  """Potential errors that have occurred during the reconciler's operation."""
  errors(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ReconcilerErrorConnection!

  """Unique identifier for the reconciler."""
  id: ID!

  """The name of the reconciler."""
  name: String!
}

"""Reconciler configuration type."""
type ReconcilerConfig {
  """Whether or not the configuration key has a value."""
  configured: Boolean!

  """Configuration description."""
  description: String!

  """The human-friendly name of the configuration key."""
  displayName: String!

  """Configuration key."""
  key: String!

  """
  Whether or not the configuration value is considered a secret. Secret values will not be exposed through the API.
  """
  secret: Boolean!

  """
  Configuration value. This will be set to null if the value is considered a secret.
  """
  value: String
}

"""Reconciler configuration input."""
input ReconcilerConfigInput {
  """Configuration key."""
  key: String!

  """Configuration value."""
  value: String!
}

type ReconcilerConfiguredActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the update."""
  data: ReconcilerConfiguredActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type ReconcilerConfiguredActivityLogEntryData {
  """Keys that were updated."""
  updatedKeys: [String!]!
}

type ReconcilerConnection {
  """List of edges."""
  edges: [ReconcilerEdge!]!

  """List of nodes."""
  nodes: [Reconciler!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type ReconcilerDisabledActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type ReconcilerEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The reconciler."""
  node: Reconciler!
}

type ReconcilerEnabledActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type ReconcilerError implements Node {
  """The correlation ID for the reconciler error."""
  correlationID: String!

  """Creation timestamp of the reconciler error."""
  createdAt: Time!

  """Unique identifier for the reconciler error."""
  id: ID!

  """The error message itself."""
  message: String!

  """The team that the error belongs to."""
  team: Team!
}

type ReconcilerErrorConnection {
  """List of edges."""
  edges: [ReconcilerErrorEdge!]!

  """List of nodes."""
  nodes: [ReconcilerError!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type ReconcilerErrorEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The reconcilerError."""
  node: ReconcilerError!
}

input RemoveRepositoryFromTeamInput {
  """Name of the repository, with the org prefix, for instance 'org/repo'."""
  repositoryName: String!

  """Slug of the team to remove the repository from."""
  teamSlug: Slug!
}

type RemoveRepositoryFromTeamPayload {
  """Whether or not the repository was removed from the team."""
  success: Boolean
}

input RemoveSecretValueInput {
  """The environment the secret exists in."""
  environment: String!

  """The name of the secret."""
  secretName: String!

  """The team that owns the secret."""
  team: Slug!

  """The secret value to remove."""
  valueName: String!
}

type RemoveSecretValuePayload {
  """The updated secret."""
  secret: Secret
}

input RemoveTeamMemberInput {
  """Slug of the team that the member should be removed from."""
  teamSlug: Slug!

  """The email address of the user to remove from the team."""
  userEmail: String!
}

type RemoveTeamMemberPayload {
  """The team that the member was removed from."""
  team: Team

  """The user that was removed from the team."""
  user: User
}

type Repository implements Node {
  """ID of the repository."""
  id: ID!

  """Name of the repository, with the organization prefix."""
  name: String!

  """Team this repository is connected to."""
  team: Team!
}

type RepositoryAddedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type RepositoryConnection {
  """List of edges."""
  edges: [RepositoryEdge!]!

  """List of nodes."""
  nodes: [Repository!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type RepositoryEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The GitHub repository."""
  node: Repository!
}

"""Ordering options when fetching repositories."""
input RepositoryOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: RepositoryOrderField!
}

enum RepositoryOrderField {
  """Order repositories by name."""
  NAME
}

type RepositoryRemovedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

input RequestTeamDeletionInput {
  """Slug of the team to request a team deletion key for."""
  slug: Slug!
}

type RequestTeamDeletionPayload {
  """
  The delete key for the team. This can be used to confirm the deletion of the team.
  """
  key: TeamDeleteKey
}

input ResourceIssueFilter {
  """Filter by issue type."""
  issueType: IssueType

  """Filter by severity."""
  severity: Severity
}

enum ResourceType {
  APPLICATION
  JOB
  OPENSEARCH
  SQLINSTANCE
  VALKEY
}

input RestartApplicationInput {
  """Name of the environment where the application runs."""
  environmentName: String!

  """Name of the application."""
  name: String!

  """Slug of the team that owns the application."""
  teamSlug: Slug!
}

type RestartApplicationPayload {
  """The application that was restarted."""
  application: Application
}

input RevokeRoleFromServiceAccountInput {
  """The name of the role to revoke."""
  roleName: String!

  """The ID of the service account to revoke the role from."""
  serviceAccountID: ID!
}

type RevokeRoleFromServiceAccountPayload {
  """The service account that had a role revoked."""
  serviceAccount: ServiceAccount
}

input RevokeTeamAccessToUnleashInput {
  revokedTeamSlug: Slug!
  teamSlug: Slug!
}

type RevokeTeamAccessToUnleashPayload {
  unleash: UnleashInstance
}

type Role implements Node {
  """Description of the role."""
  description: String!

  """The globally unique ID of the role."""
  id: ID!

  """Name of the role."""
  name: String!
}

type RoleAssignedToServiceAccountActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: RoleAssignedToServiceAccountActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

type RoleAssignedToServiceAccountActivityLogEntryData {
  """The added role."""
  roleName: String!
}

"""Assigned role to user log entry."""
type RoleAssignedUserSyncLogEntry implements Node & UserSyncLogEntry {
  """Creation time of the entry."""
  createdAt: Time!

  """ID of the entry."""
  id: ID!

  """Message that summarizes the log entry."""
  message: String!

  """The name of the assigned role."""
  roleName: String!

  """The email address of the user that was assigned a role."""
  userEmail: String!

  """The ID of the user that was assigned a role."""
  userID: ID!

  """The name of the user that was assigned a role."""
  userName: String!
}

type RoleConnection {
  """A list of role edges."""
  edges: [RoleEdge!]!

  """A list of roles."""
  nodes: [Role!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type RoleEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The role."""
  node: Role!
}

type RoleRevokedFromServiceAccountActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: RoleRevokedFromServiceAccountActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

type RoleRevokedFromServiceAccountActivityLogEntryData {
  """The removed role."""
  roleName: String!
}

"""Revoked role from user log entry."""
type RoleRevokedUserSyncLogEntry implements Node & UserSyncLogEntry {
  """Creation time of the entry."""
  createdAt: Time!

  """ID of the entry."""
  id: ID!

  """Message that summarizes the log entry."""
  message: String!

  """The name of the revoked role."""
  roleName: String!

  """The email address of the user that got a role revoked."""
  userEmail: String!

  """The ID of the user that got a role revoked."""
  userID: ID!

  """The name of the user that got a role revoked."""
  userName: String!
}

enum ScalingDirection {
  """The scaling direction is down."""
  DOWN

  """The scaling direction is up."""
  UP
}

"""Types of scaling strategies."""
union ScalingStrategy = CPUScalingStrategy | KafkaLagScalingStrategy

"""Search filter for filtering search results."""
input SearchFilter {
  """The query string."""
  query: String!

  """
  The type of entities to search for. If not specified, all types will be searched.
  """
  type: SearchType
}

"""Types that can be searched for."""
union SearchNode = Application | BigQueryDataset | Bucket | Job | KafkaTopic | OpenSearch | PostgresInstance | SqlInstance | Team | Valkey

"""Search node connection."""
type SearchNodeConnection {
  """List of edges."""
  edges: [SearchNodeEdge!]!

  """List of nodes."""
  nodes: [SearchNode!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""Search node edge."""
type SearchNodeEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The SearchNode."""
  node: SearchNode!
}

"""A list of possible search types."""
enum SearchType {
  """Search for applications."""
  APPLICATION
  BIGQUERY_DATASET
  BUCKET
  JOB
  KAFKA_TOPIC
  OPENSEARCH
  POSTGRES
  SQL_INSTANCE

  """Search for teams."""
  TEAM
  VALKEY
}

"""A secret is a collection of secret values."""
type Secret implements ActivityLogger & Node {
  """Activity log associated with the secret."""
  activityLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter items."""
    filter: ActivityLogFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ActivityLogEntryConnection!

  """Applications that use the secret."""
  applications(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ApplicationConnection!

  """The environment the secret exists in."""
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")

  """The globally unique ID of the secret."""
  id: ID!

  """Jobs that use the secret."""
  jobs(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): JobConnection!

  """
  The names of the keys in the secret. This does not require elevation to access.
  """
  keys: [String!]!

  """Last time the secret was modified."""
  lastModifiedAt: Time

  """User who last modified the secret."""
  lastModifiedBy: User

  """The name of the secret."""
  name: String!

  """The team that owns the secret."""
  team: Team!

  """The environment the secret exists in."""
  teamEnvironment: TeamEnvironment!

  """Workloads that use the secret."""
  workloads(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): WorkloadConnection!
}

type SecretConnection {
  """List of edges."""
  edges: [SecretEdge!]!

  """List of nodes."""
  nodes: [Secret!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type SecretCreatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type SecretDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type SecretEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The Secret."""
  node: Secret!
}

"""Input for filtering the secrets of a team."""
input SecretFilter {
  """Filter by usage of the secret."""
  inUse: Boolean

  """Filter by the name of the secret."""
  name: String
}

input SecretOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: SecretOrderField!
}

enum SecretOrderField {
  """Order secrets by the name of the environment."""
  ENVIRONMENT

  """Order secrets by the last time it was modified."""
  LAST_MODIFIED_AT

  """Order secrets by name."""
  NAME
}

type SecretValue {
  """The name of the secret value."""
  name: String!

  """The secret value itself."""
  value: String!
}

type SecretValueAddedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: SecretValueAddedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type SecretValueAddedActivityLogEntryData {
  """The name of the added value."""
  valueName: String!
}

input SecretValueInput {
  """The name of the secret value."""
  name: String!

  """The secret value to set."""
  value: String!
}

type SecretValueRemovedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: SecretValueRemovedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type SecretValueRemovedActivityLogEntryData {
  """The name of the removed value."""
  valueName: String!
}

type SecretValueUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: SecretValueUpdatedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type SecretValueUpdatedActivityLogEntryData {
  """The name of the updated value."""
  valueName: String!
}

"""Activity log entry for viewing secret values."""
type SecretValuesViewedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: SecretValuesViewedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

"""Data associated with a secret values viewed activity log entry."""
type SecretValuesViewedActivityLogEntryData {
  """The reason provided for viewing the secret values."""
  reason: String!
}

"""
The service account type represents machine-users of the Nais API.

These types of users can be used to automate certain parts of the API, for instance team creation and managing team members.

Service accounts are created using the `createServiceAccount` mutation, and authenticate using tokens generated by the `createServiceAccountToken` mutation.
"""
type ServiceAccount implements Node {
  """Creation time of the service account."""
  createdAt: Time!

  """The description of the service account."""
  description: String!

  """The globally unique ID of the service account."""
  id: ID!

  """When the service account was last used for authentication."""
  lastUsedAt: Time

  """The name of the service account."""
  name: String!

  """The roles that are assigned to the service account."""
  roles(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): RoleConnection!

  """The team that the service account belongs to."""
  team: Team

  """The service account tokens."""
  tokens(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ServiceAccountTokenConnection!

  """When the service account was last updated."""
  updatedAt: Time!
}

type ServiceAccountConnection {
  """A list of edges."""
  edges: [ServiceAccountEdge!]!

  """A list of service accounts."""
  nodes: [ServiceAccount!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type ServiceAccountCreatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

type ServiceAccountDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

type ServiceAccountEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The service account."""
  node: ServiceAccount!
}

type ServiceAccountToken implements Node {
  """When the service account token was created."""
  createdAt: Time!

  """The description of the service account token."""
  description: String!

  """
  Expiry date of the token. If this value is empty the token never expires.
  """
  expiresAt: Date

  """The globally unique ID of the service account token."""
  id: ID!

  """When the service account token was last used for authentication."""
  lastUsedAt: Time

  """The name of the service account token."""
  name: String!

  """When the service account token was last updated."""
  updatedAt: Time!
}

type ServiceAccountTokenConnection {
  """A list of edges."""
  edges: [ServiceAccountTokenEdge!]!

  """A list of service accounts tokens."""
  nodes: [ServiceAccountToken!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type ServiceAccountTokenCreatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: ServiceAccountTokenCreatedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

type ServiceAccountTokenCreatedActivityLogEntryData {
  """The name of the service account token."""
  tokenName: String!
}

type ServiceAccountTokenDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: ServiceAccountTokenDeletedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

type ServiceAccountTokenDeletedActivityLogEntryData {
  """The name of the service account token."""
  tokenName: String!
}

type ServiceAccountTokenEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The service account token."""
  node: ServiceAccountToken!
}

type ServiceAccountTokenUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: ServiceAccountTokenUpdatedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

type ServiceAccountTokenUpdatedActivityLogEntryData {
  """Fields that were updated."""
  updatedFields: [ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField!]!
}

type ServiceAccountTokenUpdatedActivityLogEntryDataUpdatedField {
  """The name of the field."""
  field: String!

  """The new value of the field."""
  newValue: String

  """The old value of the field."""
  oldValue: String
}

type ServiceAccountUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: ServiceAccountUpdatedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

type ServiceAccountUpdatedActivityLogEntryData {
  """Fields that were updated."""
  updatedFields: [ServiceAccountUpdatedActivityLogEntryDataUpdatedField!]!
}

type ServiceAccountUpdatedActivityLogEntryDataUpdatedField {
  """The name of the field."""
  field: String!

  """The new value of the field."""
  newValue: String

  """The old value of the field."""
  oldValue: String
}

type ServiceCostSample {
  """The cost in euros."""
  cost: Float!

  """The name of the service."""
  service: String!
}

type ServiceCostSeries {
  """
  The date for the cost. When calculating the cost for a monthly period, the date will be the last day of the month that has cost data.
  """
  date: Date!

  """The cost for the services used by the workload."""
  services: [ServiceCostSample!]!

  """The sum of the cost across all services."""
  sum: Float!
}

type ServiceMaintenanceActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

interface ServiceMaintenanceUpdate {
  """Description of the maintenance."""
  description: String

  """Title of the maintenance."""
  title: String!
}

input SetTeamMemberRoleInput {
  """The role to assign."""
  role: TeamMemberRole!

  """The slug of the team."""
  teamSlug: Slug!

  """The email address of the user."""
  userEmail: String!
}

type SetTeamMemberRolePayload {
  """The updated team member."""
  member: TeamMember
}

enum Severity {
  CRITICAL
  TODO
  WARNING
}

"""
The slug must:

- contain only lowercase alphanumeric characters or hyphens
- contain at least 3 characters and at most 30 characters
- start with an alphabetic character
- end with an alphanumeric character
- not contain two hyphens in a row

Examples of valid slugs:

- `some-value`
- `someothervalue`
- `my-team-123`
"""
scalar Slug

type SqlDatabase implements Node & Persistence {
  charset: String
  collation: String
  deletionPolicy: String
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
  healthy: Boolean!
  id: ID!
  name: String!
  team: Team!
  teamEnvironment: TeamEnvironment!
}

type SqlInstance implements Node & Persistence {
  """
  Indicates whether audit logging is enabled for this SQL instance and provides a link to the logs if set.
  """
  auditLog: AuditLog
  backupConfiguration: SqlInstanceBackupConfiguration
  cascadingDelete: Boolean!
  connectionName: String
  cost: SqlInstanceCost!
  database: SqlDatabase
  diskAutoresize: Boolean
  diskAutoresizeLimit: Int
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
  flags(after: Cursor, before: Cursor, first: Int, last: Int): SqlInstanceFlagConnection!
  healthy: Boolean!
  highAvailability: Boolean!
  id: ID!

  """Issues that affects the instance."""
  issues(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filtering options for items returned from the connection."""
    filter: ResourceIssueFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: IssueOrder
  ): IssueConnection!
  maintenanceVersion: String
  maintenanceWindow: SqlInstanceMaintenanceWindow
  metrics: SqlInstanceMetrics!
  name: String!
  projectID: String!
  state: SqlInstanceState!
  status: SqlInstanceStatus!
  team: Team!
  teamEnvironment: TeamEnvironment!
  tier: String!
  users(after: Cursor, before: Cursor, first: Int, last: Int, orderBy: SqlInstanceUserOrder): SqlInstanceUserConnection!
  version: String
  workload: Workload
}

type SqlInstanceBackupConfiguration {
  enabled: Boolean
  pointInTimeRecovery: Boolean
  retainedBackups: Int
  startTime: String
  transactionLogRetentionDays: Int
}

type SqlInstanceConnection {
  edges: [SqlInstanceEdge!]!
  nodes: [SqlInstance!]!
  pageInfo: PageInfo!
}

type SqlInstanceCost {
  sum: Float!
}

type SqlInstanceCpu {
  cores: Float!
  utilization: Float!
}

type SqlInstanceDisk {
  quotaBytes: Int!
  utilization: Float!
}

type SqlInstanceEdge {
  cursor: Cursor!
  node: SqlInstance!
}

type SqlInstanceFlag {
  name: String!
  value: String!
}

type SqlInstanceFlagConnection {
  edges: [SqlInstanceFlagEdge!]!
  nodes: [SqlInstanceFlag!]!
  pageInfo: PageInfo!
}

type SqlInstanceFlagEdge {
  cursor: Cursor!
  node: SqlInstanceFlag!
}

type SqlInstanceMaintenanceWindow {
  day: Int!
  hour: Int!
}

type SqlInstanceMemory {
  quotaBytes: Int!
  utilization: Float!
}

type SqlInstanceMetrics {
  cpu: SqlInstanceCpu!
  disk: SqlInstanceDisk!
  memory: SqlInstanceMemory!
}

input SqlInstanceOrder {
  direction: OrderDirection!
  field: SqlInstanceOrderField!
}

enum SqlInstanceOrderField {
  COST
  CPU_UTILIZATION
  DISK_UTILIZATION
  ENVIRONMENT

  """Order SqlInstances by issue severity"""
  ISSUES
  MEMORY_UTILIZATION
  NAME
  STATE
  VERSION
}

enum SqlInstanceState {
  FAILED
  MAINTENANCE
  PENDING_CREATE
  PENDING_DELETE
  RUNNABLE
  STOPPED
  SUSPENDED
  UNSPECIFIED
}

type SqlInstanceStateIssue implements Issue & Node {
  id: ID!
  message: String!
  severity: Severity!
  sqlInstance: SqlInstance!
  state: SqlInstanceState!
  teamEnvironment: TeamEnvironment!
}

type SqlInstanceStatus {
  privateIpAddress: String
  publicIpAddress: String
}

type SqlInstanceUser {
  authentication: String!
  name: String!
}

type SqlInstanceUserConnection {
  edges: [SqlInstanceUserEdge!]!
  nodes: [SqlInstanceUser!]!
  pageInfo: PageInfo!
}

type SqlInstanceUserEdge {
  cursor: Cursor!
  node: SqlInstanceUser!
}

input SqlInstanceUserOrder {
  direction: OrderDirection!
  field: SqlInstanceUserOrderField!
}

enum SqlInstanceUserOrderField {
  AUTHENTICATION
  NAME
}

type SqlInstanceVersionIssue implements Issue & Node {
  id: ID!
  message: String!
  severity: Severity!
  sqlInstance: SqlInstance!
  teamEnvironment: TeamEnvironment!
}

input StartOpenSearchMaintenanceInput {
  environmentName: String!
  serviceName: String!
  teamSlug: Slug!
}

type StartOpenSearchMaintenancePayload {
  error: String
}

input StartValkeyMaintenanceInput {
  environmentName: String!
  serviceName: String!
  teamSlug: Slug!
}

type StartValkeyMaintenancePayload {
  error: String
}

"""The subscription root for the Nais GraphQL API."""
type Subscription {
  """
  Subscribe to log lines
  
  This subscription is used to stream log lines.
  """
  log(filter: LogSubscriptionFilter!): LogLine!

  """
  Subscribe to workload logs
  
  This subscription is used to stream logs from a specific workload. When filtering logs you must either specify an
  application or a job owned by a team that is running in a specific environment. You can also filter logs on instance
  name(s).
  """
  workloadLog(filter: WorkloadLogSubscriptionFilter!): WorkloadLogLine!
}

"""
The team type represents a team on the [Nais platform](https://nais.io/).

Learn more about what Nais teams are and what they can be used for in the [official Nais documentation](https://docs.nais.io/explanations/team/).

External resources (e.g. entraIDGroupID, gitHubTeamSlug) are managed by [Nais API reconcilers](https://github.com/nais/api-reconcilers).
"""
type Team implements ActivityLogger & Node {
  """Activity log associated with the team."""
  activityLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter items."""
    filter: ActivityLogFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ActivityLogEntryConnection!

  """EXPERIMENTAL: DO NOT USE"""
  alerts(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter the returned objects"""
    filter: TeamAlertsFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: AlertOrder
  ): AlertConnection!

  """Nais applications owned by the team."""
  applications(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filtering options for items returned from the connection."""
    filter: TeamApplicationsFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: ApplicationOrder
  ): ApplicationConnection!

  """BigQuery datasets owned by the team."""
  bigQueryDatasets(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """Google Cloud Storage buckets owned by the team."""
  buckets(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: BucketOrder
  ): BucketConnection!

  """The cost for the team."""
  cost: TeamCost!

  """Get a delete key for the team."""
  deleteKey(key: String!): TeamDeleteKey!

  """Whether or not the team is currently being deleted."""
  deletionInProgress: Boolean!

  """Deployment key for the team."""
  deploymentKey: DeploymentKey

  """List deployments for a team."""
  deployments(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): DeploymentConnection!

  """Get a specific environment for the team."""
  environment(name: String!): TeamEnvironment!

  """Environments for the team."""
  environments: [TeamEnvironment!]!

  """External resources for the team."""
  externalResources: TeamExternalResources!

  """The globally unique ID of the team."""
  id: ID!

  """Get the vulnerability summary history for team."""
  imageVulnerabilityHistory(
    """Get vulnerability summary from given date until today."""
    from: Date!
  ): ImageVulnerabilityHistory!

  """Overall inventory of resources for the team."""
  inventoryCounts: TeamInventoryCounts!

  """Issues that affects the team."""
  issues(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor
    filter: IssueFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
    orderBy: IssueOrder
  ): IssueConnection!

  """Nais jobs owned by the team."""
  jobs(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filtering options for items returned from the connection."""
    filter: TeamJobsFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: JobOrder
  ): JobConnection!

  """Kafka topics owned by the team."""
  kafkaTopics(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: KafkaTopicOrder
  ): KafkaTopicConnection!

  """Timestamp of the last successful synchronization of the team."""
  lastSuccessfulSync: Time

  """Get a specific member of the team."""
  member(email: String!): TeamMember!

  """Team members."""
  members(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: TeamMemberOrder
  ): TeamMemberConnection!

  """OpenSearch instances owned by the team."""
  openSearches(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: OpenSearchOrder
  ): OpenSearchConnection!

  """Postgres instances owned by the team."""
  postgresInstances(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: PostgresInstanceOrder
  ): PostgresInstanceConnection!

  """Purpose of the team."""
  purpose: String!
  repositories(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor
    filter: TeamRepositoryFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: RepositoryOrder
  ): RepositoryConnection!

  """Secrets owned by the team."""
  secrets(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filtering options for items returned from the connection."""
    filter: SecretFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: SecretOrder
  ): SecretConnection!
  serviceUtilization: TeamServiceUtilization!

  """Main Slack channel for the team."""
  slackChannel: String!

  """Unique slug of the team."""
  slug: Slug!

  """SQL instances owned by the team."""
  sqlInstances(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!
  unleash: UnleashInstance

  """Valkey instances owned by the team."""
  valkeys(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: ValkeyOrder
  ): ValkeyConnection!

  """Whether or not the viewer is a member of the team."""
  viewerIsMember: Boolean!

  """Whether or not the viewer is an owner of the team."""
  viewerIsOwner: Boolean!

  """Get the mean time to fix history for a team."""
  vulnerabilityFixHistory(from: Date!): VulnerabilityFixHistory!

  """Fetch vulnerability summaries for workloads in the team."""
  vulnerabilitySummaries(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter the workloads by named environments."""
    filter: TeamVulnerabilitySummaryFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: VulnerabilitySummaryOrder
  ): WorkloadVulnerabilitySummaryConnection!
  vulnerabilitySummary(filter: TeamVulnerabilitySummaryFilter): TeamVulnerabilitySummary!
  workloadUtilization(resourceType: UtilizationResourceType!): [WorkloadUtilizationData]!

  """Nais workloads owned by the team."""
  workloads(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter the returned objects"""
    filter: TeamWorkloadsFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: WorkloadOrder
  ): WorkloadConnection!
}

"""Input for filtering alerts."""
input TeamAlertsFilter {
  """Filter by the name of the environment."""
  environments: [String!]

  """Filter by the name of the application."""
  name: String

  """Only return alerts from the given named states."""
  states: [AlertState!]
}

"""Input for filtering the applications of a team."""
input TeamApplicationsFilter {
  """Filter by the name of the environment."""
  environments: [String!]

  """Filter by the name of the application."""
  name: String
}

type TeamCDN {
  """The CDN bucket for the team."""
  bucket: String!
}

type TeamConfirmDeleteKeyActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamConnection {
  """List of edges."""
  edges: [TeamEdge!]!

  """List of nodes."""
  nodes: [Team!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type TeamCost {
  daily(
    """Filter the results."""
    filter: TeamCostDailyFilter

    """Start date of the period, inclusive."""
    from: Date!

    """End date of the period, inclusive."""
    to: Date!
  ): TeamCostPeriod!
  monthlySummary: TeamCostMonthlySummary!
}

input TeamCostDailyFilter {
  """Services to include in the summary."""
  services: [String!]
}

type TeamCostMonthlySample {
  """The total cost for the month."""
  cost: Float!

  """The last date with cost data in the month."""
  date: Date!
}

type TeamCostMonthlySummary {
  """The cost series."""
  series: [TeamCostMonthlySample!]!

  """The total cost for the last 12 months."""
  sum: Float!
}

type TeamCostPeriod {
  """The cost series."""
  series: [ServiceCostSeries!]!

  """The total cost for the period."""
  sum: Float!
}

type TeamCreateDeleteKeyActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamCreatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamDeleteKey {
  """The creation timestamp of the key."""
  createdAt: Time!

  """The user who created the key."""
  createdBy: User!

  """Expiration timestamp of the key."""
  expires: Time!

  """The unique key used to confirm the deletion of a team."""
  key: String!

  """The team the delete key is for."""
  team: Team!
}

type TeamDeployKeyUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The team."""
  node: Team!
}

type TeamEntraIDGroup {
  """The ID of the Entra ID (f.k.a. Azure AD) group for the team."""
  groupID: String!
}

type TeamEnvironment implements Node {
  """EXPERIMENTAL: DO NOT USE"""
  alerts(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter the returned objects"""
    filter: TeamAlertsFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: AlertOrder
  ): AlertConnection!

  """Nais application in the team environment."""
  application(
    """The name of the application."""
    name: String!
  ): Application!

  """BigQuery datasets in the team environment."""
  bigQueryDataset(name: String!): BigQueryDataset!

  """Storage bucket in the team environment."""
  bucket(name: String!): Bucket!

  """The cost for the team environment."""
  cost: TeamEnvironmentCost!

  """Get the environment."""
  environment: Environment!

  """The GCP project ID for the team environment."""
  gcpProjectID: String

  """The globally unique ID of the team environment."""
  id: ID!

  """Nais job in the team environment."""
  job(name: String!): Job!

  """Kafka topic in the team environment."""
  kafkaTopic(name: String!): KafkaTopic!

  """Name of the team environment."""
  name: String! @deprecated(reason: "Use the `environment` field to get the environment name.")

  """OpenSearch instance in the team environment."""
  openSearch(name: String!): OpenSearch!

  """Postgres instance in the team environment."""
  postgresInstance(name: String!): PostgresInstance!

  """Get a secret by name."""
  secret(name: String!): Secret!

  """The Slack alerts channel for the team environment."""
  slackAlertsChannel: String!

  """SQL instance in the team environment."""
  sqlInstance(name: String!): SqlInstance!

  """The connected team."""
  team: Team!

  """Valkey instance in the team environment."""
  valkey(name: String!): Valkey!

  """Workload in the team environment."""
  workload(
    """The name of the workload to get."""
    name: String!
  ): Workload!
}

type TeamEnvironmentCost {
  daily(
    """Start date of the period, inclusive."""
    from: Date!

    """End date of the period, inclusive."""
    to: Date!
  ): TeamEnvironmentCostPeriod!
}

type TeamEnvironmentCostPeriod {
  """The cost series."""
  series: [WorkloadCostSeries!]!

  """The total cost for the period."""
  sum: Float!
}

type TeamEnvironmentUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the action."""
  data: TeamEnvironmentUpdatedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamEnvironmentUpdatedActivityLogEntryData {
  """Fields that were updated."""
  updatedFields: [TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField!]!
}

type TeamEnvironmentUpdatedActivityLogEntryDataUpdatedField {
  """The name of the field."""
  field: String!

  """The new value of the field."""
  newValue: String

  """The old value of the field."""
  oldValue: String
}

type TeamExternalResources {
  """CDN bucket."""
  cdn: TeamCDN

  """The Entra ID (f.k.a. Azure AD) group for the team."""
  entraIDGroup: TeamEntraIDGroup

  """The teams GitHub team."""
  gitHubTeam: TeamGitHubTeam

  """Google Artifact Registry."""
  googleArtifactRegistry: TeamGoogleArtifactRegistry

  """The Google group for the team."""
  googleGroup: TeamGoogleGroup
}

"""Input for filtering teams."""
input TeamFilter {
  """Filter teams by the existence of workloads."""
  hasWorkloads: Boolean
}

type TeamGitHubTeam {
  """The slug of the GitHub team."""
  slug: String!
}

type TeamGoogleArtifactRegistry {
  """The Google Artifact Registry for the team."""
  repository: String!
}

type TeamGoogleGroup {
  """The email address of the Google Workspace group for the team."""
  email: String!
}

"""Application inventory count for a team."""
type TeamInventoryCountApplications {
  """Total number of applications."""
  total: Int!
}

type TeamInventoryCountBigQueryDatasets {
  """Total number of BigQuery datasets."""
  total: Int!
}

type TeamInventoryCountBuckets {
  """Total number of Google Cloud Storage buckets."""
  total: Int!
}

type TeamInventoryCountJobs {
  """Total number of jobs."""
  total: Int!
}

type TeamInventoryCountKafkaTopics {
  """Total number of Kafka topics."""
  total: Int!
}

type TeamInventoryCountOpenSearches {
  """Total number of OpenSearch instances."""
  total: Int!
}

type TeamInventoryCountSqlInstances {
  """Total number of SQL instances."""
  total: Int!
}

type TeamInventoryCountValkeys {
  """Total number of Valkey instances."""
  total: Int!
}

type TeamInventoryCounts {
  """Application inventory count for a team."""
  applications: TeamInventoryCountApplications!
  bigQueryDatasets: TeamInventoryCountBigQueryDatasets!
  buckets: TeamInventoryCountBuckets!
  jobs: TeamInventoryCountJobs!
  kafkaTopics: TeamInventoryCountKafkaTopics!
  openSearches: TeamInventoryCountOpenSearches!
  sqlInstances: TeamInventoryCountSqlInstances!
  valkeys: TeamInventoryCountValkeys!
}

input TeamJobsFilter {
  """Filter by the name of the environment."""
  environments: [String!]

  """Filter by the name of the job."""
  name: String!
}

type TeamMember {
  """The role that the user has in the team."""
  role: TeamMemberRole!

  """Team instance."""
  team: Team!

  """User instance."""
  user: User!
}

type TeamMemberAddedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the action."""
  data: TeamMemberAddedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamMemberAddedActivityLogEntryData {
  """The role that the user was added with."""
  role: TeamMemberRole!

  """The email address of the user that was added."""
  userEmail: String!

  """The ID of the user that was added."""
  userID: ID!
}

type TeamMemberConnection {
  """List of edges."""
  edges: [TeamMemberEdge!]!

  """List of nodes."""
  nodes: [TeamMember!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type TeamMemberEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The team member."""
  node: TeamMember!
}

"""Ordering options for team members."""
input TeamMemberOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: TeamMemberOrderField!
}

"""Possible fields to order team members by."""
enum TeamMemberOrderField {
  """The email address of the user."""
  EMAIL

  """The name of user."""
  NAME

  """The role the user has in the team."""
  ROLE
}

type TeamMemberRemovedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the action."""
  data: TeamMemberRemovedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamMemberRemovedActivityLogEntryData {
  """The email address of the user that was removed."""
  userEmail: String!

  """The ID of the user that was removed."""
  userID: ID!
}

"""Team member roles."""
enum TeamMemberRole {
  """Member, full access including elevation."""
  MEMBER

  """Team owner, full access to the team including member management."""
  OWNER
}

type TeamMemberSetRoleActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the action."""
  data: TeamMemberSetRoleActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamMemberSetRoleActivityLogEntryData {
  """The role that the user was assigned."""
  role: TeamMemberRole!

  """The email address of the user that was added."""
  userEmail: String!

  """The ID of the user that was added."""
  userID: ID!
}

"""Ordering options when fetching teams."""
input TeamOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: TeamOrderField!
}

"""Possible fields to order teams by."""
enum TeamOrderField {
  """The team's accumulated cost over the last 12 months"""
  ACCUMULATED_COST

  """
  The accumulated number of critical vulnerabilities of the teams workloads.
  """
  CRITICAL_VULNERABILITIES

  """The accumulated number of high vulnerabilities of the teams workloads."""
  HIGH_VULNERABILITIES

  """The accumulated number of low vulnerabilities of the teams workloads."""
  LOW_VULNERABILITIES

  """
  The accumulated number of medium vulnerabilities of the teams workloads.
  """
  MEDIUM_VULNERABILITIES

  """The accumulated risk score of the teams workloads."""
  RISK_SCORE

  """The team's software bill of materials (SBOM) coverage."""
  SBOM_COVERAGE

  """The unique slug of the team."""
  SLUG

  """
  The accumulated number of unassigned vulnerabilities of the teams workloads.
  """
  UNASSIGNED_VULNERABILITIES
}

input TeamRepositoryFilter {
  """Filter by repository name containing the phrase."""
  name: String
}

type TeamServiceUtilization {
  sqlInstances: TeamServiceUtilizationSqlInstances!
}

type TeamServiceUtilizationSqlInstances {
  cpu: TeamServiceUtilizationSqlInstancesCPU!
  disk: TeamServiceUtilizationSqlInstancesDisk!
  memory: TeamServiceUtilizationSqlInstancesMemory!
}

type TeamServiceUtilizationSqlInstancesCPU {
  requested: Float!
  used: Float!
  utilization: Float!
}

type TeamServiceUtilizationSqlInstancesDisk {
  requested: Int!
  used: Int!
  utilization: Float!
}

type TeamServiceUtilizationSqlInstancesMemory {
  requested: Int!
  used: Int!
  utilization: Float!
}

type TeamUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the update."""
  data: TeamUpdatedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type TeamUpdatedActivityLogEntryData {
  """Fields that were updated."""
  updatedFields: [TeamUpdatedActivityLogEntryDataUpdatedField!]!
}

type TeamUpdatedActivityLogEntryDataUpdatedField {
  """The name of the field."""
  field: String!

  """The new value of the field."""
  newValue: String

  """The old value of the field."""
  oldValue: String
}

type TeamUtilizationData {
  """The environment for the utilization data."""
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")

  """The requested amount of resources"""
  requested: Float!

  """The team."""
  team: Team!

  """The environment for the utilization data."""
  teamEnvironment: TeamEnvironment!

  """The current resource usage."""
  used: Float!
}

enum TeamVulnerabilityRiskScoreTrend {
  """Risk score is decreasing."""
  DOWN

  """Risk score is not changing."""
  FLAT

  """Risk score is increasing."""
  UP
}

type TeamVulnerabilitySummary {
  """Coverage of the team."""
  coverage: Float!

  """Number of vulnerabilities with severity CRITICAL."""
  critical: Int!

  """Number of vulnerabilities with severity HIGH."""
  high: Int!

  """Timestamp of the last update of the vulnerability summary."""
  lastUpdated: Time

  """Number of vulnerabilities with severity LOW."""
  low: Int!

  """Number of vulnerabilities with severity MEDIUM."""
  medium: Int!

  """Risk score of the team."""
  riskScore: Int!

  """Trend of vulnerability status for the team."""
  riskScoreTrend: TeamVulnerabilityRiskScoreTrend!

  """Number of workloads with a software bill of materials (SBOM) attached."""
  sbomCount: Int!

  """Number of vulnerabilities with severity UNASSIGNED."""
  unassigned: Int!
}

"""Input for filtering team workloads."""
input TeamVulnerabilitySummaryFilter {
  """Only return workloads from the given named environments."""
  environments: [String!]
}

"""Input for filtering team workloads."""
input TeamWorkloadsFilter {
  """Only return workloads from the given named environments."""
  environments: [String!]
}

type TenantVulnerabilitySummary {
  """SBOM Coverage of the tenant."""
  coverage: Float!

  """Number of vulnerabilities with severity CRITICAL."""
  critical: Int!

  """Number of vulnerabilities with severity HIGH."""
  high: Int!

  """Timestamp of the last update of the vulnerability summary."""
  lastUpdated: Time

  """Number of vulnerabilities with severity LOW."""
  low: Int!

  """Number of vulnerabilities with severity MEDIUM."""
  medium: Int!

  """Risk score of the tenant."""
  riskScore: Int!

  """Number of workloads with a software bill of materials (SBOM) attached."""
  sbomCount: Int!

  """Number of vulnerabilities with severity UNASSIGNED."""
  unassigned: Int!
}

"""
Time is a string in [RFC 3339](https://rfc-editor.org/rfc/rfc3339.html) format, with sub-second precision added if present.
"""
scalar Time

"""
TimeOfDay is the time of day, represented as a string in the format HH:MM:SS.
"""
scalar TimeOfDay

"""
TokenX authentication.

Read more: https://docs.nais.io/auth/tokenx/
"""
type TokenXAuthIntegration implements AuthIntegration {
  """The name of the integration."""
  name: String!
}

input TriggerJobInput {
  """Name of the environment where the job runs."""
  environmentName: String!

  """Name of the job."""
  name: String!

  """Name of the new run. Must be unique within the team."""
  runName: String!

  """Slug of the team that owns the job."""
  teamSlug: Slug!
}

type TriggerJobPayload {
  """The job that was triggered."""
  job: Job

  """The new job run."""
  jobRun: JobRun
}

type UnleashInstance implements Node {
  allowedTeams(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): TeamConnection!
  apiIngress: String!
  id: ID!
  metrics: UnleashInstanceMetrics!
  name: String!
  ready: Boolean!

  """
  Release channel details if using channel-based version management.
  Returns the full release channel object with current version and update policy.
  """
  releaseChannel: UnleashReleaseChannel

  """
  Release channel name if using channel-based version management.
  Populated from CRD spec.releaseChannel.name field.
  """
  releaseChannelName: String
  version: String!
  webIngress: String!
}

type UnleashInstanceCreatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type UnleashInstanceDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type UnleashInstanceMetrics {
  apiTokens: Int!
  cpuRequests: Float!
  cpuUtilization: Float!
  memoryRequests: Float!
  memoryUtilization: Float!
  toggles: Int!
}

type UnleashInstanceUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the update."""
  data: UnleashInstanceUpdatedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type UnleashInstanceUpdatedActivityLogEntryData {
  """Allowed team slug."""
  allowedTeamSlug: Slug

  """Revoked team slug."""
  revokedTeamSlug: Slug

  """Updated release channel."""
  updatedReleaseChannel: String
}

"""
UnleashReleaseChannel represents an available release channel for Unleash instances.
Release channels provide automatic version updates based on the channel's update policy.
"""
type UnleashReleaseChannel {
  """Current Unleash version on this channel."""
  currentVersion: String!

  """When the channel version was last updated."""
  lastUpdated: Time

  """
  Unique name of the release channel (e.g., 'stable', 'rapid', 'regular').
  """
  name: String!

  """
  Rollout strategy type for version updates:
  - 'sequential': Updates instances one-by-one in order
  - 'canary': Gradual rollout with canary deployment
  - 'parallel': Updates multiple instances simultaneously
  """
  type: String!
}

input UpdateImageVulnerabilityInput {
  """The reason for suppressing the vulnerability."""
  reason: String!

  """New state of the vulnerability."""
  state: ImageVulnerabilitySuppressionState

  """Should the vulnerability be suppressed."""
  suppress: Boolean!

  """The id of the vulnerability to suppress."""
  vulnerabilityID: ID!
}

type UpdateImageVulnerabilityPayload {
  """The vulnerability updated."""
  vulnerability: ImageVulnerability
}

input UpdateOpenSearchInput {
  """The environment name that the OpenSearch instance belongs to."""
  environmentName: String!

  """Available memory for the OpenSearch instance."""
  memory: OpenSearchMemory!

  """Name of the OpenSearch instance."""
  name: String!

  """Available storage in GB."""
  storageGB: Int!

  """The team that owns the OpenSearch instance."""
  teamSlug: Slug!

  """Tier of the OpenSearch instance."""
  tier: OpenSearchTier!

  """Major version of the OpenSearch instance."""
  version: OpenSearchMajorVersion!
}

type UpdateOpenSearchPayload {
  """OpenSearch instance that was updated."""
  openSearch: OpenSearch!
}

input UpdateSecretValueInput {
  """The environment the secret exists in."""
  environment: String!

  """The name of the secret."""
  name: String!

  """The team that owns the secret."""
  team: Slug!

  """The secret value to set."""
  value: SecretValueInput!
}

type UpdateSecretValuePayload {
  """The updated secret."""
  secret: Secret
}

input UpdateServiceAccountInput {
  """
  The new description of the service account.
  
  If not specified, the description will remain unchanged.
  """
  description: String

  """The ID of the service account to update."""
  serviceAccountID: ID!
}

type UpdateServiceAccountPayload {
  """The updated service account."""
  serviceAccount: ServiceAccount
}

input UpdateServiceAccountTokenInput {
  """
  The new description of the service account token.
  
  If not specified, the description will remain unchanged.
  """
  description: String

  """
  The new name of the service account token.
  
  If not specified, the name will remain unchanged.
  """
  name: String

  """The ID of the service account token to update."""
  serviceAccountTokenID: ID!
}

type UpdateServiceAccountTokenPayload {
  """The service account that the token belongs to."""
  serviceAccount: ServiceAccount

  """The updated service account token."""
  serviceAccountToken: ServiceAccountToken
}

input UpdateTeamEnvironmentInput {
  """Name of the environment to update."""
  environmentName: String!

  """
  Slack alerts channel for the environment. Set to an empty string to remove the existing value.
  """
  slackAlertsChannel: String

  """Slug of the team to update."""
  slug: Slug!
}

type UpdateTeamEnvironmentPayload {
  """The updated team environment."""
  environment: TeamEnvironment @deprecated(reason: "Use the `teamEnvironment` field instead.")

  """The updated team environment."""
  teamEnvironment: TeamEnvironment
}

input UpdateTeamInput {
  """
  An optional new purpose / description of the team.
  
  When omitted the existing value will not be updated.
  """
  purpose: String

  """
  An optional new Slack channel for the team.
  
  When omitted the existing value will not be updated.
  """
  slackChannel: String

  """Slug of the team to update."""
  slug: Slug!
}

type UpdateTeamPayload {
  """The updated team."""
  team: Team
}

input UpdateUnleashInstanceInput {
  """
  Subscribe the instance to a release channel for automatic version updates.
  If not specified, the release channel will not be changed.
  """
  releaseChannel: String

  """The team that owns the Unleash instance to update."""
  teamSlug: Slug!
}

type UpdateUnleashInstancePayload {
  unleash: UnleashInstance
}

input UpdateValkeyInput {
  """The environment name that the entry belongs to."""
  environmentName: String!

  """Maximum memory policy for the Valkey instance."""
  maxMemoryPolicy: ValkeyMaxMemoryPolicy

  """Available memory for the Valkey instance."""
  memory: ValkeyMemory!

  """Name of the Valkey instance."""
  name: String!

  """
  Configure keyspace notifications for the Valkey instance. See https://valkey.io/topics/notifications/ for details.
  """
  notifyKeyspaceEvents: String

  """The team that owns the Valkey instance."""
  teamSlug: Slug!

  """Tier of the Valkey instance."""
  tier: ValkeyTier!
}

type UpdateValkeyPayload {
  """Valkey instance that was updated."""
  valkey: Valkey!
}

"""
The user type represents a user of the Nais platform and the Nais GraphQL API.
"""
type User implements Node {
  """The email address of the user."""
  email: String!

  """
  The external ID of the user. This value is managed by the Nais API user synchronization.
  """
  externalID: String!

  """The globally unique ID of the user."""
  id: ID!

  """True if the user is global admin."""
  isAdmin: Boolean!

  """The full name of the user."""
  name: String!

  """List of teams the user is connected to."""
  teams(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: UserTeamOrder
  ): TeamMemberConnection!
}

"""User connection."""
type UserConnection {
  """List of edges."""
  edges: [UserEdge!]!

  """List of nodes."""
  nodes: [User!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""User created log entry."""
type UserCreatedUserSyncLogEntry implements Node & UserSyncLogEntry {
  """Creation time of the entry."""
  createdAt: Time!

  """ID of the entry."""
  id: ID!

  """Message that summarizes the log entry."""
  message: String!

  """The email address of the created user."""
  userEmail: String!

  """The ID of the created user."""
  userID: ID!

  """The name of the created user."""
  userName: String!
}

"""User deleted log entry."""
type UserDeletedUserSyncLogEntry implements Node & UserSyncLogEntry {
  """Creation time of the entry."""
  createdAt: Time!

  """ID of the entry."""
  id: ID!

  """Message that summarizes the log entry."""
  message: String!

  """The email address of the deleted user."""
  userEmail: String!

  """The ID of the deleted user."""
  userID: ID!

  """The name of the deleted user."""
  userName: String!
}

"""User edge."""
type UserEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The user."""
  node: User!
}

"""Ordering options when fetching users."""
input UserOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: UserOrderField!
}

"""Possible fields to order users by."""
enum UserOrderField {
  """The email address of the user."""
  EMAIL

  """The name of the user."""
  NAME
}

"""Interface for user sync log entries."""
interface UserSyncLogEntry {
  """Creation time of the entry."""
  createdAt: Time!

  """ID of the entry."""
  id: ID!

  """Message that summarizes the log entry."""
  message: String!

  """The email address of the affected user."""
  userEmail: String!

  """The ID of the affected user."""
  userID: ID!

  """The name of the affected user."""
  userName: String!
}

"""User sync log entry connection."""
type UserSyncLogEntryConnection {
  """List of edges."""
  edges: [UserSyncLogEntryEdge!]!

  """List of nodes."""
  nodes: [UserSyncLogEntry!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

"""User sync log edge."""
type UserSyncLogEntryEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The log entry."""
  node: UserSyncLogEntry!
}

"""Ordering options when fetching the teams a user is connected to."""
input UserTeamOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: UserTeamOrderField!
}

"""Possible fields to order user teams by."""
enum UserTeamOrderField {
  """The unique slug of the team."""
  TEAM_SLUG
}

"""User updated log entry."""
type UserUpdatedUserSyncLogEntry implements Node & UserSyncLogEntry {
  """Creation time of the entry."""
  createdAt: Time!

  """ID of the entry."""
  id: ID!

  """Message that summarizes the log entry."""
  message: String!

  """The old email address of the user."""
  oldUserEmail: String!

  """The old name of the user."""
  oldUserName: String!

  """The email address of the updated user."""
  userEmail: String!

  """The ID of the updated user."""
  userID: ID!

  """The name of the updated user."""
  userName: String!
}

"""Resource type."""
enum UtilizationResourceType {
  CPU
  MEMORY
}

"""Resource utilization type."""
type UtilizationSample {
  """The instance for the utilization data."""
  instance: String!

  """Timestamp of the value."""
  timestamp: Time!

  """Value of the used resource at the given timestamp."""
  value: Float!
}

type Valkey implements ActivityLogger & Node & Persistence {
  access(after: Cursor, before: Cursor, first: Int, last: Int, orderBy: ValkeyAccessOrder): ValkeyAccessConnection!

  """Activity log associated with the reconciler."""
  activityLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter items."""
    filter: ActivityLogFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ActivityLogEntryConnection!
  cost: ValkeyCost!
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")
  id: ID!

  """Issues that affects the instance."""
  issues(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filtering options for items returned from the connection."""
    filter: ResourceIssueFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: IssueOrder
  ): IssueConnection!

  """Fetch maintenances updates for the Valkey instance."""
  maintenance: ValkeyMaintenance!

  """Maximum memory policy for the Valkey instance."""
  maxMemoryPolicy: ValkeyMaxMemoryPolicy

  """Available memory for the Valkey instance."""
  memory: ValkeyMemory!
  name: String!

  """
  Keyspace notifications for the Valkey instance. See https://valkey.io/topics/notifications/ for details.
  """
  notifyKeyspaceEvents: String
  state: ValkeyState!
  team: Team!
  teamEnvironment: TeamEnvironment!
  terminationProtection: Boolean!

  """Availability tier for the Valkey instance."""
  tier: ValkeyTier!
  workload: Workload @deprecated(reason: "Owners of valkeys have been removed, so this will always be null.")
}

type ValkeyAccess {
  access: String!
  workload: Workload!
}

type ValkeyAccessConnection {
  edges: [ValkeyAccessEdge!]!
  nodes: [ValkeyAccess!]!
  pageInfo: PageInfo!
}

type ValkeyAccessEdge {
  cursor: Cursor!
  node: ValkeyAccess!
}

input ValkeyAccessOrder {
  direction: OrderDirection!
  field: ValkeyAccessOrderField!
}

enum ValkeyAccessOrderField {
  ACCESS
  WORKLOAD
}

type ValkeyConnection {
  edges: [ValkeyEdge!]!
  nodes: [Valkey!]!
  pageInfo: PageInfo!
}

type ValkeyCost {
  sum: Float!
}

type ValkeyCreatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type ValkeyDeletedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type ValkeyEdge {
  cursor: Cursor!
  node: Valkey!
}

type ValkeyIssue implements Issue & Node {
  event: String!
  id: ID!
  message: String!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
  valkey: Valkey!
}

type ValkeyMaintenance {
  updates(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ValkeyMaintenanceUpdateConnection!

  """The day and time of the week when the maintenance will be scheduled."""
  window: MaintenanceWindow
}

type ValkeyMaintenanceUpdate implements ServiceMaintenanceUpdate {
  """
  Deadline for installing the maintenance. If set, maintenance is mandatory and will be forcibly applied.
  """
  deadline: Time

  """Description of the maintenance."""
  description: String!

  """
  The time when the update will be automatically applied. If set, maintenance is mandatory and will be forcibly applied.
  """
  startAt: Time

  """Title of the maintenance."""
  title: String!
}

type ValkeyMaintenanceUpdateConnection {
  """List of edges."""
  edges: [ValkeyMaintenanceUpdateEdge!]!

  """List of nodes."""
  nodes: [ValkeyMaintenanceUpdate!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type ValkeyMaintenanceUpdateEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The ValkeyMaintenanceUpdate."""
  node: ValkeyMaintenanceUpdate!
}

enum ValkeyMaxMemoryPolicy {
  """Keeps frequently used keys; removes least frequently used (LFU) keys"""
  ALLKEYS_LFU

  """Keeps most recently used keys; removes least recently used (LRU) keys"""
  ALLKEYS_LRU

  """Randomly removes keys to make space for the new data added."""
  ALLKEYS_RANDOM

  """
  New values aren't saved when memory limit is reached. When a database uses replication, this applies to the primary database.
  """
  NO_EVICTION

  """Removes least frequently used keys with a TTL set."""
  VOLATILE_LFU

  """Removes least recently used keys with a time-to-live (TTL) set."""
  VOLATILE_LRU

  """Randomly removes keys with a TTL set."""
  VOLATILE_RANDOM

  """
  Removes keys with a TTL set, the keys with the shortest remaining time-to-live value first.
  """
  VOLATILE_TTL
}

enum ValkeyMemory {
  GB_1
  GB_4
  GB_8
  GB_14
  GB_28
  GB_56
  GB_112
  GB_200
}

input ValkeyOrder {
  direction: OrderDirection!
  field: ValkeyOrderField!
}

enum ValkeyOrderField {
  ENVIRONMENT

  """Order Valkeys by issue severity"""
  ISSUES
  NAME
  STATE
}

enum ValkeyState {
  POWEROFF
  REBALANCING
  REBUILDING
  RUNNING
  UNKNOWN
}

enum ValkeyTier {
  HIGH_AVAILABILITY
  SINGLE_NODE
}

type ValkeyUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the entry."""
  data: ValkeyUpdatedActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug!
}

type ValkeyUpdatedActivityLogEntryData {
  updatedFields: [ValkeyUpdatedActivityLogEntryDataUpdatedField!]!
}

type ValkeyUpdatedActivityLogEntryDataUpdatedField {
  """The name of the field."""
  field: String!

  """The new value of the field."""
  newValue: String

  """The old value of the field."""
  oldValue: String
}

"""Input for viewing secret values."""
input ViewSecretValuesInput {
  """The environment the secret exists in."""
  environment: String!

  """The name of the secret."""
  name: String!

  """Reason for viewing the secret values. Must be at least 10 characters."""
  reason: String!

  """The team that owns the secret."""
  team: Slug!
}

"""Payload returned when viewing secret values."""
type ViewSecretValuesPayload {
  """The secret values."""
  values: [SecretValue!]!
}

type VulnerabilityActivityLogEntryData {
  """The unique identifier of the vulnerability. E.g. CVE-****-****."""
  identifier: String!

  """The new suppression state of the vulnerability."""
  newSuppression: ImageVulnerabilitySuppression

  """The package affected by the vulnerability."""
  package: String!

  """The previous suppression state of the vulnerability."""
  previousSuppression: ImageVulnerabilitySuppression

  """The severity of the vulnerability."""
  severity: ImageVulnerabilitySeverity!
}

"""Trend of mean time to fix vulnerabilities grouped by severity."""
type VulnerabilityFixHistory {
  """Mean time to fix samples."""
  samples: [VulnerabilityFixSample!]!
}

"""One MTTR sample for a severity at a point in time."""
type VulnerabilityFixSample {
  """Snapshot date of the sample."""
  date: Time!

  """Mean time to fix in days."""
  days: Int!

  """Earliest time a vulnerability was fixed in this sample."""
  firstFixedAt: Time

  """Number of vulnerabilities fixed in this sample."""
  fixedCount: Int!

  """Latest time a vulnerability was fixed in this sample."""
  lastFixedAt: Time

  """Severity of vulnerabilities in this sample."""
  severity: ImageVulnerabilitySeverity!

  """Total number of workloads with this severity of vulnerabilities."""
  totalWorkloads: Int!
}

"""Ordering options when fetching vulnerability summaries for workloads."""
input VulnerabilitySummaryOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: VulnerabilitySummaryOrderByField!
}

enum VulnerabilitySummaryOrderByField {
  """Order by the name of the environment the workload is deployed in."""
  ENVIRONMENT

  """Order by name."""
  NAME

  """
  Order by risk score"
  """
  VULNERABILITY_RISK_SCORE

  """
  Order by vulnerability severity critical"
  """
  VULNERABILITY_SEVERITY_CRITICAL

  """
  Order by vulnerability severity high"
  """
  VULNERABILITY_SEVERITY_HIGH

  """
  Order by vulnerability severity low"
  """
  VULNERABILITY_SEVERITY_LOW

  """
  Order by vulnerability severity medium"
  """
  VULNERABILITY_SEVERITY_MEDIUM

  """
  Order by vulnerability severity unassigned"
  """
  VULNERABILITY_SEVERITY_UNASSIGNED
}

type VulnerabilityUpdatedActivityLogEntry implements ActivityLogEntry & Node {
  """
  The identity of the actor who performed the action. The value is either the name of a service account, or the email address of a user.
  """
  actor: String!

  """Creation time of the entry."""
  createdAt: Time!

  """Data associated with the update."""
  data: VulnerabilityActivityLogEntryData!

  """The environment name that the entry belongs to."""
  environmentName: String

  """ID of the entry."""
  id: ID!

  """Message that summarizes the entry."""
  message: String!

  """Name of the resource that was affected by the action."""
  resourceName: String!

  """Type of the resource that was affected by the action."""
  resourceType: ActivityLogEntryResourceType!

  """The team slug that the entry belongs to."""
  teamSlug: Slug
}

type VulnerableImageIssue implements Issue & Node {
  critical: Int!
  id: ID!
  message: String!
  riskScore: Int!
  severity: Severity!
  teamEnvironment: TeamEnvironment!
  workload: Workload!
}

"""The days of the week."""
enum Weekday {
  """Friday"""
  FRIDAY

  """Monday"""
  MONDAY

  """Saturday"""
  SATURDAY

  """Sunday"""
  SUNDAY

  """Thursday"""
  THURSDAY

  """Tuesday"""
  TUESDAY

  """Wednesday"""
  WEDNESDAY
}

"""Interface for workloads."""
interface Workload {
  """Activity log associated with the workload."""
  activityLog(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filter items."""
    filter: ActivityLogFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): ActivityLogEntryConnection!

  """
  BigQuery datasets referenced by the workload. This does not currently support pagination, but will return all available datasets.
  """
  bigQueryDatasets(
    """Ordering options for items returned from the connection."""
    orderBy: BigQueryDatasetOrder
  ): BigQueryDatasetConnection!

  """
  Google Cloud Storage referenced by the workload. This does not currently support pagination, but will return all available buckets.
  """
  buckets(
    """Ordering options for items returned from the connection."""
    orderBy: BucketOrder
  ): BucketConnection!

  """The cost for a workload."""
  cost: WorkloadCost!

  """If set, when the workload was marked for deletion."""
  deletionStartedAt: Time

  """List of deployments for the workload."""
  deployments(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): DeploymentConnection!

  """The environment the workload is deployed in."""
  environment: TeamEnvironment! @deprecated(reason: "Use the `teamEnvironment` field instead.")

  """The globally unique ID of the workload."""
  id: ID!

  """The container image of the workload."""
  image: ContainerImage!

  """Get the vulnerability summary history for workload."""
  imageVulnerabilityHistory(
    """Get vulnerability summary from given date until today."""
    from: Date!
  ): ImageVulnerabilityHistory!

  """Issues that affects the workload."""
  issues(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """Filtering options for items returned from the connection."""
    filter: ResourceIssueFilter

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int

    """Ordering options for items returned from the connection."""
    orderBy: IssueOrder
  ): IssueConnection!

  """
  Kafka topics the workload has access to. This does not currently support pagination, but will return all available Kafka topics.
  """
  kafkaTopicAcls(
    """Ordering options for items returned from the connection."""
    orderBy: KafkaTopicAclOrder
  ): KafkaTopicAclConnection!

  """List of log destinations for the workload."""
  logDestinations: [LogDestination!]!

  """The workload manifest."""
  manifest: WorkloadManifest!

  """The name of the workload."""
  name: String!

  """Network policies for the workload."""
  networkPolicy: NetworkPolicy!

  """OpenSearch instance referenced by the workload."""
  openSearch: OpenSearch

  """
  Postgres instances referenced by the workload. This does not currently support pagination, but will return all available Postgres instances.
  """
  postgresInstances(
    """Ordering options for items returned from the connection."""
    orderBy: PostgresInstanceOrder
  ): PostgresInstanceConnection!

  """The resources allocated to the workload."""
  resources: WorkloadResources!

  """Secrets used by the workload."""
  secrets(
    """Get items after this cursor."""
    after: Cursor

    """Get items before this cursor."""
    before: Cursor

    """
    Get the first n items in the connection. This can be used in combination with the after parameter.
    """
    first: Int

    """
    Get the last n items in the connection. This can be used in combination with the before parameter.
    """
    last: Int
  ): SecretConnection!

  """
  SQL instances referenced by the workload. This does not currently support pagination, but will return all available SQL instances.
  """
  sqlInstances(
    """Ordering options for items returned from the connection."""
    orderBy: SqlInstanceOrder
  ): SqlInstanceConnection!

  """The team that owns the workload."""
  team: Team!

  """The team environment for the workload."""
  teamEnvironment: TeamEnvironment!

  """
  Valkey instances referenced by the workload. This does not currently support pagination, but will return all available Valkey instances.
  """
  valkeys(
    """Ordering options for items returned from the connection."""
    orderBy: ValkeyOrder
  ): ValkeyConnection!

  """Get the mean time to fix history for a workload."""
  vulnerabilityFixHistory(from: Date!): VulnerabilityFixHistory!
}

"""Workload connection."""
type WorkloadConnection {
  """List of edges."""
  edges: [WorkloadEdge!]!

  """List of nodes."""
  nodes: [Workload!]!

  """Pagination information."""
  pageInfo: PageInfo!
}

type WorkloadCost {
  """Get the cost for a workload within a time period."""
  daily(
    """Start date of the period, inclusive."""
    from: Date!

    """End date of the period, inclusive."""
    to: Date!
  ): WorkloadCostPeriod!

  """The cost for the last 12 months."""
  monthly: WorkloadCostPeriod!
}

type WorkloadCostPeriod {
  """The cost series."""
  series: [ServiceCostSeries!]!

  """The total cost for the period."""
  sum: Float!
}

type WorkloadCostSample {
  """The cost in euros."""
  cost: Float!

  """The workload."""
  workload: Workload

  """The name of the workload."""
  workloadName: String!
}

type WorkloadCostSeries {
  """
  The date for the cost. When calculating the cost for a monthly period, the date will be the last day of the month that has cost data.
  """
  date: Date!

  """The sum of the cost across all workloads."""
  sum: Float!

  """The cost for the workloads in the environment."""
  workloads: [WorkloadCostSample!]!
}

"""Workload edge."""
type WorkloadEdge {
  """Cursor for this edge that can be used for pagination."""
  cursor: Cursor!

  """The Workload."""
  node: Workload!
}

type WorkloadLogLine {
  """The name of the instance that generated the log line."""
  instance: String!

  """The log message."""
  message: String!

  """The timestamp of the log line."""
  time: Time!
}

input WorkloadLogSubscriptionFilter {
  """Filter logs to a specific application."""
  application: String

  """Filter logs to a specific environment."""
  environment: String!

  """Filter logs to a set of specific instance names."""
  instances: [String!]

  """Filter logs to a specific job."""
  job: String

  """Filter logs to a specific team."""
  team: Slug!
}

"""Interface for workload manifests."""
interface WorkloadManifest {
  """The manifest content, serialized as a YAML document."""
  content: String!
}

"""Ordering options when fetching workloads."""
input WorkloadOrder {
  """The direction to order items by."""
  direction: OrderDirection!

  """The field to order items by."""
  field: WorkloadOrderField!
}

"""Fields to order workloads by."""
enum WorkloadOrderField {
  """Order by the deployment time."""
  DEPLOYMENT_TIME

  """Order by the name of the environment the workload is deployed in."""
  ENVIRONMENT

  """Order by whether the workload has a software bill of materials (SBOM)"""
  HAS_SBOM

  """Order workloads by issue severity"""
  ISSUES

  """Order by name."""
  NAME

  """Order by the last time the vulnerabilities were scanned."""
  VULNERABILITY_LAST_SCANNED

  """Order by risk score"""
  VULNERABILITY_RISK_SCORE

  """Order apps by vulnerability severity critical"""
  VULNERABILITY_SEVERITY_CRITICAL

  """Order apps by vulnerability severity high"""
  VULNERABILITY_SEVERITY_HIGH

  """Order apps by vulnerability severity low"""
  VULNERABILITY_SEVERITY_LOW

  """Order apps by vulnerability severity medium"""
  VULNERABILITY_SEVERITY_MEDIUM

  """Order apps by vulnerability severity unassigned"""
  VULNERABILITY_SEVERITY_UNASSIGNED
}

"""Resource quantities for a workload."""
type WorkloadResourceQuantity {
  """The number of CPU cores."""
  cpu: Float

  """The amount of memory in bytes."""
  memory: Int
}

"""Interface for resources allocated to workloads."""
interface WorkloadResources {
  """Instances using resources above this threshold will be killed."""
  limits: WorkloadResourceQuantity!

  """Resources requested by the workload."""
  requests: WorkloadResourceQuantity!
}

type WorkloadUtilization {
  """Get the current usage for the requested resource type."""
  current(resourceType: UtilizationResourceType!): Float!

  """Gets the limit of the resources for the requested resource type."""
  limit(resourceType: UtilizationResourceType!): Float

  """
  Gets the limit of the resources between start and end with step size for given resource type.
  """
  limitSeries(input: WorkloadUtilizationSeriesInput!): [UtilizationSample!]!

  """Gets the recommended amount of resources for the workload."""
  recommendations: WorkloadUtilizationRecommendations!

  """
  Gets the requested amount of resources for the requested resource type.
  """
  requested(resourceType: UtilizationResourceType!): Float!

  """
  Gets the requested amount of resources between start and end with step size for given resource type.
  """
  requestedSeries(input: WorkloadUtilizationSeriesInput!): [UtilizationSample!]!

  """Usage between start and end with step size for given resource type."""
  series(input: WorkloadUtilizationSeriesInput!): [UtilizationSample!]!
}

type WorkloadUtilizationData {
  """The requested amount of resources"""
  requested: Float!

  """The current resource usage."""
  used: Float!

  """The workload."""
  workload: Workload!
}

type WorkloadUtilizationRecommendations {
  cpuRequestCores: Float!
  memoryLimitBytes: Int!
  memoryRequestBytes: Int!
}

input WorkloadUtilizationSeriesInput {
  """Fetch resource usage until this timestamp."""
  end: Time!

  """Resource type."""
  resourceType: UtilizationResourceType!

  """Fetch resource usage from this timestamp."""
  start: Time!
}

type WorkloadVulnerabilitySummary implements Node {
  """True if the workload has a software bill of materials (SBOM) attached."""
  hasSBOM: Boolean!

  """The globally unique ID of the workload vulnerability summary node."""
  id: ID!

  """The vulnerability summary for the workload."""
  summary: ImageVulnerabilitySummary!

  """The workload"""
  workload: Workload!
}

type WorkloadVulnerabilitySummaryConnection {
  """List of edges."""
  edges: [WorkloadVulnerabilitySummaryEdge!]!

  """List of nodes."""
  nodes: [WorkloadVulnerabilitySummary!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type WorkloadVulnerabilitySummaryEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The workload vulnerability summary."""
  node: WorkloadVulnerabilitySummary!
}

type WorkloadWithVulnerability {
  vulnerability: ImageVulnerability!
  workload: Workload!
}

type WorkloadWithVulnerabilityConnection {
  """List of edges."""
  edges: [WorkloadWithVulnerabilityEdge!]!

  """List of nodes."""
  nodes: [WorkloadWithVulnerability!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

type WorkloadWithVulnerabilityEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The vulnerability."""
  node: WorkloadWithVulnerability!
}